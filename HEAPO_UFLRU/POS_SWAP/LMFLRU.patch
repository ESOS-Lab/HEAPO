--- rmap_uflru.c	2016-12-12 10:38:41.111981028 +0900
+++ rmap_cflru.c	2016-12-12 10:38:38.931981092 +0900
@@ -207,7 +207,6 @@
 }
 
 
-
 /*
  * This is a useful helper function for locking the anon_vma root as
  * we traverse the vma->anon_vma_chain, looping over anon_vma's that
@@ -536,6 +535,54 @@
 	return address;
 }
 
+// POS SWAP
+/**
+ * pos_anon_vma_prepare - attach an anon_vma to a pos memory region
+ * @vma: the memory region in question
+ */
+int pos_anon_vma_prepare(struct vm_area_struct *vma, struct page *page)
+{
+        struct anon_vma *anon_vma;
+        struct anon_vma *root_anon_vma;
+        struct anon_vma_chain *avc;
+
+        might_sleep();
+	//printk("[POSDEBUG] %s page %d is vma %p, mapcount %d, count %d\n",__func__, page_to_pfn(page),vma, atomic_read(&page->_mapcount),page_count(page));
+        anon_vma = page_anon_vma(page);
+        if (!anon_vma)
+	{
+//		printk("[POSDEBUG] No anon_vma to page %d, mp %d\n ", page_to_pfn(page),atomic_read(&page->_mapcount));
+                return -ENOMEM;
+        }
+	
+	if(vma->anon_vma == anon_vma)
+		return 0;
+	avc = anon_vma_chain_alloc(GFP_KERNEL);
+        if (!avc)
+                return -ENOMEM;
+	
+        get_anon_vma(anon_vma->root);
+        vma->anon_vma = anon_vma;
+        anon_vma_lock_write(anon_vma);
+        anon_vma_chain_link(vma, avc, anon_vma);
+        anon_vma_unlock_write(anon_vma);
+    
+//	printk("[POSDEBUG]after %s page %d is map %d, count %d\n",__func__, page_to_pfn(page),atomic_read(&page->_mapcount),page_count(page));
+/*	
+	pgoff_t pgoff = page->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);
+        struct anon_vma_chain *temp_avc;
+	int count=0;
+        anon_vma_interval_tree_foreach(temp_avc, &anon_vma->rb_root, pgoff, pgoff) {
+        	struct vm_area_struct *temp_vma = temp_avc->vma;
+        	unsigned long address = vma_address(page, temp_vma);
+		count++;
+		printk("[POSDEBUG] %d 's %d 's vma is %p and address is %p\n", page_to_pfn(page),count,temp_vma, address);        
+		if(count>10)
+			break;
+	}
+*/
+	return 0;
+}
 /*
  * At what user virtual address is page expected in vma?
  * Caller should check the page is actually part of the vma.
@@ -1234,13 +1281,19 @@
 	} else
 		dec_mm_counter(mm, MM_FILEPAGES);
 	page_remove_rmap(page);
+	
 	if(is_nvram(page_zone(page)))
 	{
-		if(page_count(page)==3)
-			page_cache_release(page);	
+	//	printk("[POSDEBUG] %s, page %ld before relase map %d cnt %d\n",__func__,page_to_pfn(page),atomic_read(&page->_mapcount), atomic_read(&page->_count));
+		if(atomic_read(&page->_count)==3)
+			page_cache_release(page);
+		printk("[POSDEBUG] %s, page %ld before relase map %d cnt %d\n",__func__,page_to_pfn(page),atomic_read(&page->_mapcount), atomic_read(&page->_count));
 	}
 	else
+	{
 		page_cache_release(page);
+	}		
+			
 out_unmap:
 	pte_unmap_unlock(pte, ptl);
 	if (ret != SWAP_FAIL)
@@ -1631,38 +1684,38 @@
 	int ret = SWAP_AGAIN;
 	if(is_nvram(page_zone(page)))
 	{
-		//printk("[POSDEBUG] %s start to %d mapcount %d ret %d\n",__func__,page_to_pfn(page),atomic_read(&page->_mapcount),ret);
+		printk("[POSDEBUG] %s start to %d mapcount %d count %d ret %d\n",__func__,page_to_pfn(page),atomic_read(&page->_mapcount),page_count(page),ret);
 		anon_vma = rmap_walk_anon_lock(page, rwc);
 		if (!anon_vma)
 			return ret;
 
-		///printk("[POSDEBUG] Rmap walk anon start\n");
+		//printk("[POSDEBUG] %d Rmap walk anon start\n",page_to_pfn(page));
 		int count=0;
 		anon_vma_interval_tree_foreach(avc, &anon_vma->rb_root, pgoff, pgoff) {
-			count ++;
+			count++;
 			struct vm_area_struct *vma = avc->vma;
 			unsigned long address = vma_address(page, vma);
-			//printk("[POSDEBUG] %d ",count);
+			printk("[POSDEBUG] page %d at vma %p and add %p 's %d circle count %d is ",page_to_pfn(page), vma, address, count, page_count(page));
 			if (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))
 			{
-				//printk("i ");
+				printk("invalid\n");
 				continue;
 			}
-			//printk("v ");
+			printk("valid\n");
 			ret = rwc->rmap_one(page, vma, address, rwc->arg);
 			if (ret != SWAP_AGAIN)
 			{
-				//printk("ret %d FAIL",ret);
+				//printk("rmapone is FAIL and ret is %d\n",ret);
 				break;
 			}
-			//printk(", ");
+			//printk("rmapone is SUCC and mapcount is %d, count %d\n",atomic_read(&page->_mapcount),page_count(page));
 			if (rwc->done && rwc->done(page))
 			{
-				//printk("Done");
+				//printk("Done\n");
 				break;
 			}
+			printk("\n");
 		}
-		//printk("\n");
 	}else
 	{
 		anon_vma = rmap_walk_anon_lock(page, rwc);
@@ -1685,48 +1738,6 @@
 	return ret;
 }
 
-// POS SWAP
-/**
- * pos_anon_vma_prepare - attach an anon_vma to a pos memory region
- * @vma: the memory region in question
- */
-int pos_anon_vma_prepare(struct vm_area_struct *vma, struct page *page)
-{
-        struct anon_vma *anon_vma;
-        struct anon_vma *root_anon_vma;
-        struct anon_vma_chain *avc;
-
-        might_sleep();
-        anon_vma = page_anon_vma(page);
-        if (!anon_vma)
-                return -ENOMEM;
-	if(vma->anon_vma == anon_vma)
-		return 0;
-	avc = anon_vma_chain_alloc(GFP_KERNEL);
-        if (!avc)
-                return -ENOMEM;
-
-        get_anon_vma(anon_vma->root);
-        vma->anon_vma = anon_vma;
-        anon_vma_lock_write(anon_vma);
-        anon_vma_chain_link(vma, avc, anon_vma);
-        anon_vma_unlock_write(anon_vma);
-    
-/*	
-	pgoff_t pgoff = page->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);
-        struct anon_vma_chain *temp_avc;
-	int count=0;
-        anon_vma_interval_tree_foreach(temp_avc, &anon_vma->rb_root, pgoff, pgoff) {
-        	struct vm_area_struct *temp_vma = temp_avc->vma;
-        	unsigned long address = vma_address(page, temp_vma);
-		count++;
-		printk("[POSDEBUG] %d 's %d 's vma is %p and address is %p\n", page_to_pfn(page),count,temp_vma, address);        
-		if(count>10)
-			break;
-	}
-  */  
-	return 0;
-}
 /*
  * rmap_walk_file - do something to file page using the object-based rmap method
  * @page: the page to be handled
