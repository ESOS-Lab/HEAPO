!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOC_CMA	./internal.h	387;"	d
ALLOC_CPUSET	./internal.h	386;"	d
ALLOC_FAIR	./internal.h	388;"	d
ALLOC_HARDER	./internal.h	384;"	d
ALLOC_HIGH	./internal.h	385;"	d
ALLOC_NO_WATERMARKS	./internal.h	379;"	d
ALLOC_WMARK_HIGH	./internal.h	378;"	d
ALLOC_WMARK_LOW	./internal.h	377;"	d
ALLOC_WMARK_MASK	./internal.h	382;"	d
ALLOC_WMARK_MIN	./internal.h	376;"	d
ARCH_KMALLOC_FLAGS	./slab.c	157;"	d	file:
ARCH_LOW_ADDRESS_LIMIT	./bootmem.c	807;"	d	file:
ARCH_LOW_ADDRESS_LIMIT	./nobootmem.c	383;"	d	file:
BAD_ALIEN_MAGIC	./slab.c	435;"	d	file:
BANDWIDTH_INTERVAL	./page-writeback.c	58;"	d	file:
BATCHREFILL_LIMIT	./slab.c	283;"	d	file:
BDI_SHOW	./backing-dev.c	176;"	d	file:
BLOCKS_PER_PAGE	./shmem.c	73;"	d	file:
BOGO_DIRENT_SIZE	./shmem.c	77;"	d	file:
BOOT_CPUCACHE_ENTRIES	./slab.c	227;"	d	file:
BUILD_EMBED_FIRST_CHUNK	./percpu.c	1429;"	d	file:
BUILD_PAGE_FIRST_CHUNK	./percpu.c	1434;"	d	file:
BYTES_PER_POINTER	./kmemleak.c	114;"	d	file:
BYTES_PER_WORD	./slab.c	153;"	d	file:
Bad_file	./swapfile.c	/^static const char Bad_file[] = "Bad swap file entry ";$/;"	v	file:
Bad_offset	./swapfile.c	/^static const char Bad_offset[] = "Bad swap offset entry ";$/;"	v	file:
CACHE_CACHE	./slab.c	238;"	d	file:
CACHE_CREATE_MASK	./slab.h	91;"	d
CFLGS_OFF_SLAB	./slab.c	280;"	d	file:
CHARGE_BATCH	./memcontrol.c	2377;"	d	file:
CHARGE_NOMEM	./memcontrol.c	/^	CHARGE_NOMEM,		\/* we can't do more. return -ENOMEM *\/$/;"	e	enum:__anon4	file:
CHARGE_OK	./memcontrol.c	/^	CHARGE_OK,		\/* success *\/$/;"	e	enum:__anon4	file:
CHARGE_RETRY	./memcontrol.c	/^	CHARGE_RETRY,		\/* need to retry but retry is not bad *\/$/;"	e	enum:__anon4	file:
CHARGE_WOULDBLOCK	./memcontrol.c	/^	CHARGE_WOULDBLOCK,	\/* GFP_WAIT wasn't set and no enough res. *\/$/;"	e	enum:__anon4	file:
CHUNK_SHIFT	./zbud.c	67;"	d	file:
CHUNK_SIZE	./zbud.c	68;"	d	file:
CLASS_IDX_BITS	./zsmalloc.c	228;"	d	file:
CLASS_IDX_MASK	./zsmalloc.c	230;"	d	file:
CLUSTER_MASK	./rmap.c	1280;"	d	file:
CLUSTER_SIZE	./rmap.c	1279;"	d	file:
COMPAT_SYSCALL_DEFINE3	./mempolicy.c	/^COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,$/;"	f
COMPAT_SYSCALL_DEFINE5	./mempolicy.c	/^COMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,$/;"	f
COMPAT_SYSCALL_DEFINE6	./mempolicy.c	/^COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,$/;"	f
COMPAT_SYSCALL_DEFINE6	./process_vm_access.c	/^COMPAT_SYSCALL_DEFINE6(process_vm_readv, compat_pid_t, pid,$/;"	f
COMPAT_SYSCALL_DEFINE6	./process_vm_access.c	/^COMPAT_SYSCALL_DEFINE6(process_vm_writev, compat_pid_t, pid,$/;"	f
CREATE_TRACE_POINTS	./compaction.c	38;"	d	file:
CREATE_TRACE_POINTS	./filemap.c	39;"	d	file:
CREATE_TRACE_POINTS	./migrate.c	43;"	d	file:
CREATE_TRACE_POINTS	./oom_kill.c	39;"	d	file:
CREATE_TRACE_POINTS	./swap.c	37;"	d	file:
CREATE_TRACE_POINTS	./util.c	19;"	d	file:
CREATE_TRACE_POINTS	./vmscan.c	55;"	d	file:
DEBUG	./slab.c	143;"	d	file:
DEBUG	./slab.c	147;"	d	file:
DEBUG	./zsmalloc.c	76;"	d	file:
DEBUG_DEFAULT_FLAGS	./slub.c	162;"	d	file:
DEBUG_METADATA_FLAGS	./slub.c	170;"	d	file:
DELAYED	./memory-failure.c	/^	DELAYED,	\/* Will be handled later *\/$/;"	e	enum:outcome	file:
DIRTY_POLL_THRESH	./page-writeback.c	53;"	d	file:
DMAPOOL_DEBUG	./dmapool.c	42;"	d	file:
DOWN	./slab.h	/^	DOWN,			\/* No slab functionality yet *\/$/;"	e	enum:slab_state
DO_NUMA	./ksm.c	46;"	d	file:
DO_NUMA	./ksm.c	49;"	d	file:
DO_PAGES_STAT_CHUNK_NR	./migrate.c	1423;"	d	file:
FAILED	./memory-failure.c	/^	FAILED,		\/* Error: handling failed *\/$/;"	e	enum:outcome	file:
FAKE_FS_POOLID_OFFSET	./cleancache.c	48;"	d	file:
FAKE_SHARED_FS_POOLID_OFFSET	./cleancache.c	49;"	d	file:
FAULT_AROUND_ORDER	./memory.c	3408;"	d	file:
FIRST	./zbud.c	/^	FIRST,$/;"	e	enum:buddy	file:
FLUSHING_CACHED_CHARGE	./memcontrol.c	2383;"	d	file:
FORCED_DEBUG	./slab.c	145;"	d	file:
FORCED_DEBUG	./slab.c	149;"	d	file:
FRACTION_OF_NODE_MEM	./quicklist.c	24;"	d	file:
FREELIST_BYTE_INDEX	./slab.c	160;"	d	file:
FS_NO_BACKEND	./cleancache.c	51;"	d	file:
FS_UNKNOWN	./cleancache.c	52;"	d	file:
FULL	./slab.h	/^	FULL			\/* Everything is working *\/$/;"	e	enum:slab_state
FULLNESS_BITS	./zsmalloc.c	229;"	d	file:
FULLNESS_MASK	./zsmalloc.c	231;"	d	file:
GFP_VMALLOC32	./vmalloc.c	1829;"	d	file:
GFP_VMALLOC32	./vmalloc.c	1831;"	d	file:
GFP_VMALLOC32	./vmalloc.c	1833;"	d	file:
HAVE_PTE_SPECIAL	./memory.c	752;"	d	file:
HAVE_PTE_SPECIAL	./memory.c	754;"	d	file:
HEX_ASCII	./kmemleak.c	177;"	d	file:
HEX_GROUP_SIZE	./kmemleak.c	175;"	d	file:
HEX_MAX_LINES	./kmemleak.c	179;"	d	file:
HEX_ROW_SIZE	./kmemleak.c	173;"	d	file:
HPAGE_RESV_MASK	./hugetlb.c	377;"	d	file:
HPAGE_RESV_OWNER	./hugetlb.c	375;"	d	file:
HPAGE_RESV_UNMAPPED	./hugetlb.c	376;"	d	file:
HSTATE_ATTR	./hugetlb.c	1555;"	d	file:
HSTATE_ATTR_RO	./hugetlb.c	1552;"	d	file:
ID_STR_LENGTH	./slub.c	5144;"	d	file:
IGNORED	./memory-failure.c	/^	IGNORED,	\/* Error: cannot be handled *\/$/;"	e	enum:outcome	file:
INC_CACHE_INFO	./swap_state.c	47;"	d	file:
INDEX_AC	./slab.c	251;"	d	file:
INDEX_NODE	./slab.c	252;"	d	file:
INIT_BW	./backing-dev.c	440;"	d	file:
INIT_MM_CONTEXT	./init-mm.c	13;"	d	file:
ISA_POOL_SIZE	./bounce.c	23;"	d	file:
ISOLATE_ABORT	./compaction.c	/^	ISOLATE_ABORT,		\/* Abort compaction now *\/$/;"	e	enum:__anon10	file:
ISOLATE_NONE	./compaction.c	/^	ISOLATE_NONE,		\/* No pages isolated, continue scanning *\/$/;"	e	enum:__anon10	file:
ISOLATE_SUCCESS	./compaction.c	/^	ISOLATE_SUCCESS,	\/* Pages isolated, migrate *\/$/;"	e	enum:__anon10	file:
K	./backing-dev.c	115;"	d	file:
K	./backing-dev.c	174;"	d	file:
K	./backing-dev.c	88;"	d	file:
K	./memcontrol.c	1671;"	d	file:
K	./oom_kill.c	409;"	d	file:
K	./oom_kill.c	519;"	d	file:
K	./page_alloc.c	3057;"	d	file:
KMEMLEAK_ALLOC	./kmemleak.c	/^	KMEMLEAK_ALLOC,$/;"	e	enum:__anon11	file:
KMEMLEAK_ALLOC_PERCPU	./kmemleak.c	/^	KMEMLEAK_ALLOC_PERCPU,$/;"	e	enum:__anon11	file:
KMEMLEAK_BLACK	./kmemleak.c	129;"	d	file:
KMEMLEAK_FREE	./kmemleak.c	/^	KMEMLEAK_FREE,$/;"	e	enum:__anon11	file:
KMEMLEAK_FREE_PART	./kmemleak.c	/^	KMEMLEAK_FREE_PART,$/;"	e	enum:__anon11	file:
KMEMLEAK_FREE_PERCPU	./kmemleak.c	/^	KMEMLEAK_FREE_PERCPU,$/;"	e	enum:__anon11	file:
KMEMLEAK_GREY	./kmemleak.c	128;"	d	file:
KMEMLEAK_IGNORE	./kmemleak.c	/^	KMEMLEAK_IGNORE,$/;"	e	enum:__anon11	file:
KMEMLEAK_NOT_LEAK	./kmemleak.c	/^	KMEMLEAK_NOT_LEAK,$/;"	e	enum:__anon11	file:
KMEMLEAK_NO_SCAN	./kmemleak.c	/^	KMEMLEAK_NO_SCAN$/;"	e	enum:__anon11	file:
KMEMLEAK_SCAN_AREA	./kmemleak.c	/^	KMEMLEAK_SCAN_AREA,$/;"	e	enum:__anon11	file:
KMEM_ACCOUNTED_ACTIVE	./memcontrol.c	/^	KMEM_ACCOUNTED_ACTIVE, \/* accounted by this cgroup itself *\/$/;"	e	enum:__anon3	file:
KMEM_ACCOUNTED_DEAD	./memcontrol.c	/^	KMEM_ACCOUNTED_DEAD, \/* dead memcg with pending kmem charges *\/$/;"	e	enum:__anon3	file:
KSM_ATTR	./ksm.c	2087;"	d	file:
KSM_ATTR_RO	./ksm.c	2085;"	d	file:
KSM_KMEM_CACHE	./ksm.c	246;"	d	file:
KSM_RUN_MERGE	./ksm.c	236;"	d	file:
KSM_RUN_OFFLINE	./ksm.c	238;"	d	file:
KSM_RUN_STOP	./ksm.c	235;"	d	file:
KSM_RUN_UNMERGE	./ksm.c	237;"	d	file:
LAST	./zbud.c	/^	LAST$/;"	e	enum:buddy	file:
LATENCY_LIMIT	./mremap.c	162;"	d	file:
LATENCY_LIMIT	./swapfile.c	179;"	d	file:
MAKE_ALL_LISTS	./slab.c	273;"	d	file:
MAKE_LIST	./slab.c	267;"	d	file:
MAX	./zsmalloc.c	137;"	d	file:
MAX_INITIALIZABLE_FS	./cleancache.c	47;"	d	file:
MAX_NODE_LOAD	./page_alloc.c	3396;"	d	file:
MAX_OBJS_PER_PAGE	./slub.c	184;"	d	file:
MAX_PARTIAL	./slub.c	160;"	d	file:
MAX_PAUSE	./page-writeback.c	47;"	d	file:
MAX_PHYSMEM_BITS	./zsmalloc.c	124;"	d	file:
MAX_PHYSMEM_BITS	./zsmalloc.c	130;"	d	file:
MAX_READAHEAD	./readahead.c	235;"	d	file:
MAX_SCAN_SIZE	./kmemleak.c	112;"	d	file:
MAX_SLABINFO_WRITE	./slab.c	4142;"	d	file:
MAX_TRACE	./kmemleak.c	108;"	d	file:
MC_TARGET_NONE	./memcontrol.c	/^	MC_TARGET_NONE = 0,$/;"	e	enum:mc_target_type	file:
MC_TARGET_PAGE	./memcontrol.c	/^	MC_TARGET_PAGE,$/;"	e	enum:mc_target_type	file:
MC_TARGET_SWAP	./memcontrol.c	/^	MC_TARGET_SWAP,$/;"	e	enum:mc_target_type	file:
MEMCG_CACHES_MAX_SIZE	./memcontrol.c	642;"	d	file:
MEMCG_CACHES_MIN_SIZE	./memcontrol.c	641;"	d	file:
MEMFILE_ATTR	./hugetlb_cgroup.c	31;"	d	file:
MEMFILE_ATTR	./memcontrol.c	480;"	d	file:
MEMFILE_IDX	./hugetlb_cgroup.c	30;"	d	file:
MEMFILE_PRIVATE	./hugetlb_cgroup.c	29;"	d	file:
MEMFILE_PRIVATE	./memcontrol.c	478;"	d	file:
MEMFILE_TYPE	./memcontrol.c	479;"	d	file:
MEMORY_FAILURE_FIFO_ORDER	./memory-failure.c	1237;"	d	file:
MEMORY_FAILURE_FIFO_SIZE	./memory-failure.c	1238;"	d	file:
MEM_CGROUP_CHARGE_TYPE_ANON	./memcontrol.c	/^	MEM_CGROUP_CHARGE_TYPE_ANON,$/;"	e	enum:charge_type	file:
MEM_CGROUP_CHARGE_TYPE_CACHE	./memcontrol.c	/^	MEM_CGROUP_CHARGE_TYPE_CACHE = 0,$/;"	e	enum:charge_type	file:
MEM_CGROUP_CHARGE_TYPE_DROP	./memcontrol.c	/^	MEM_CGROUP_CHARGE_TYPE_DROP,	\/* a page was unused swap cache *\/$/;"	e	enum:charge_type	file:
MEM_CGROUP_CHARGE_TYPE_SWAPOUT	./memcontrol.c	/^	MEM_CGROUP_CHARGE_TYPE_SWAPOUT,	\/* for accounting swapcache *\/$/;"	e	enum:charge_type	file:
MEM_CGROUP_EVENTS_NSTATS	./memcontrol.c	/^	MEM_CGROUP_EVENTS_NSTATS,$/;"	e	enum:mem_cgroup_events_index	file:
MEM_CGROUP_EVENTS_PGFAULT	./memcontrol.c	/^	MEM_CGROUP_EVENTS_PGFAULT,	\/* # of page-faults *\/$/;"	e	enum:mem_cgroup_events_index	file:
MEM_CGROUP_EVENTS_PGMAJFAULT	./memcontrol.c	/^	MEM_CGROUP_EVENTS_PGMAJFAULT,	\/* # of major page-faults *\/$/;"	e	enum:mem_cgroup_events_index	file:
MEM_CGROUP_EVENTS_PGPGIN	./memcontrol.c	/^	MEM_CGROUP_EVENTS_PGPGIN,	\/* # of pages paged in *\/$/;"	e	enum:mem_cgroup_events_index	file:
MEM_CGROUP_EVENTS_PGPGOUT	./memcontrol.c	/^	MEM_CGROUP_EVENTS_PGPGOUT,	\/* # of pages paged out *\/$/;"	e	enum:mem_cgroup_events_index	file:
MEM_CGROUP_ID_MAX	./memcontrol.c	526;"	d	file:
MEM_CGROUP_MAX_RECLAIM_LOOPS	./memcontrol.c	459;"	d	file:
MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS	./memcontrol.c	460;"	d	file:
MEM_CGROUP_NTARGETS	./memcontrol.c	/^	MEM_CGROUP_NTARGETS,$/;"	e	enum:mem_cgroup_events_target	file:
MEM_CGROUP_RECLAIM_NOSWAP	./memcontrol.c	488;"	d	file:
MEM_CGROUP_RECLAIM_NOSWAP_BIT	./memcontrol.c	487;"	d	file:
MEM_CGROUP_RECLAIM_RETRIES	./memcontrol.c	72;"	d	file:
MEM_CGROUP_RECLAIM_SHRINK	./memcontrol.c	490;"	d	file:
MEM_CGROUP_RECLAIM_SHRINK_BIT	./memcontrol.c	489;"	d	file:
MEM_CGROUP_TARGET_NUMAINFO	./memcontrol.c	/^	MEM_CGROUP_TARGET_NUMAINFO,$/;"	e	enum:mem_cgroup_events_target	file:
MEM_CGROUP_TARGET_SOFTLIMIT	./memcontrol.c	/^	MEM_CGROUP_TARGET_SOFTLIMIT,$/;"	e	enum:mem_cgroup_events_target	file:
MEM_CGROUP_TARGET_THRESH	./memcontrol.c	/^	MEM_CGROUP_TARGET_THRESH,$/;"	e	enum:mem_cgroup_events_target	file:
MIN_PARTIAL	./slub.c	153;"	d	file:
MMAP_LOTSAMISS	./filemap.c	1813;"	d	file:
MMINIT_TRACE	./internal.h	/^	MMINIT_TRACE$/;"	e	enum:mminit_level
MMINIT_VERIFY	./internal.h	/^	MMINIT_VERIFY,$/;"	e	enum:mminit_level
MMINIT_WARNING	./internal.h	/^	MMINIT_WARNING,$/;"	e	enum:mminit_level
MM_SLAB_H	./slab.h	2;"	d
MM_SLOTS_HASH_BITS	./huge_memory.c	69;"	d	file:
MM_SLOTS_HASH_BITS	./ksm.c	194;"	d	file:
MOVE_CHARGE_TYPE_ANON	./memcontrol.c	/^	MOVE_CHARGE_TYPE_ANON,	\/* private anonymous page and swap of it *\/$/;"	e	enum:move_type	file:
MOVE_CHARGE_TYPE_FILE	./memcontrol.c	/^	MOVE_CHARGE_TYPE_FILE,	\/* file page(including tmpfs) and swap of it *\/$/;"	e	enum:move_type	file:
MPOL_MF_DISCONTIG_OK	./mempolicy.c	102;"	d	file:
MPOL_MF_INVERT	./mempolicy.c	103;"	d	file:
MSECS_MIN_AGE	./kmemleak.c	109;"	d	file:
NCHUNKS	./zbud.c	69;"	d	file:
NCHUNKS_ORDER	./zbud.c	65;"	d	file:
NR_CHARGE_TYPE	./memcontrol.c	/^	NR_CHARGE_TYPE,$/;"	e	enum:charge_type	file:
NR_DIRTY_BG_THRESHOLD	./vmstat.c	/^	NR_DIRTY_BG_THRESHOLD,$/;"	e	enum:writeback_stat_item	file:
NR_DIRTY_THRESHOLD	./vmstat.c	/^	NR_DIRTY_THRESHOLD,$/;"	e	enum:writeback_stat_item	file:
NR_MOVE_TYPE	./memcontrol.c	/^	NR_MOVE_TYPE,$/;"	e	enum:move_type	file:
NR_OFFLINE_AT_ONCE_PAGES	./memory_hotplug.c	1267;"	d	file:
NR_VM_WRITEBACK_STAT_ITEMS	./vmstat.c	/^	NR_VM_WRITEBACK_STAT_ITEMS,$/;"	e	enum:writeback_stat_item	file:
NUMA	./ksm.c	45;"	d	file:
NUMA	./ksm.c	48;"	d	file:
NUMAINFO_EVENTS_TARGET	./memcontrol.c	137;"	d	file:
NUMA_ZONELIST_ORDER_LEN	./page_alloc.c	3308;"	d	file:
NUM_INIT_LISTS	./slab.c	236;"	d	file:
OBJECT_ALLOCATED	./kmemleak.c	166;"	d	file:
OBJECT_NO_SCAN	./kmemleak.c	170;"	d	file:
OBJECT_REPORTED	./kmemleak.c	168;"	d	file:
OBJ_INDEX_BITS	./zsmalloc.c	134;"	d	file:
OBJ_INDEX_MASK	./zsmalloc.c	135;"	d	file:
OFF_SLAB	./slab.c	281;"	d	file:
OOM_CONTROL	./memcontrol.c	482;"	d	file:
OO_MASK	./slub.c	183;"	d	file:
OO_SHIFT	./slub.c	182;"	d	file:
PAGEREF_ACTIVATE	./vmscan.c	/^	PAGEREF_ACTIVATE,$/;"	e	enum:page_references	file:
PAGEREF_KEEP	./vmscan.c	/^	PAGEREF_KEEP,$/;"	e	enum:page_references	file:
PAGEREF_RECLAIM	./vmscan.c	/^	PAGEREF_RECLAIM,$/;"	e	enum:page_references	file:
PAGEREF_RECLAIM_CLEAN	./vmscan.c	/^	PAGEREF_RECLAIM_CLEAN,$/;"	e	enum:page_references	file:
PAGES_PER_WAITQUEUE	./page_alloc.c	3866;"	d	file:
PAGE_ACTIVATE	./vmscan.c	/^	PAGE_ACTIVATE,$/;"	e	enum:__anon13	file:
PAGE_CLEAN	./vmscan.c	/^	PAGE_CLEAN,$/;"	e	enum:__anon13	file:
PAGE_KEEP	./vmscan.c	/^	PAGE_KEEP,$/;"	e	enum:__anon13	file:
PAGE_KERNEL_EXEC	./nommu.c	376;"	d	file:
PAGE_KERNEL_EXEC	./vmalloc.c	1807;"	d	file:
PAGE_SUCCESS	./vmscan.c	/^	PAGE_SUCCESS,$/;"	e	enum:__anon13	file:
PARTIAL	./slab.h	/^	PARTIAL,		\/* SLUB: kmem_cache_node available *\/$/;"	e	enum:slab_state
PARTIAL_ARRAYCACHE	./slab.h	/^	PARTIAL_ARRAYCACHE,	\/* SLAB: kmalloc size for arraycache available *\/$/;"	e	enum:slab_state
PARTIAL_NODE	./slab.h	/^	PARTIAL_NODE,		\/* SLAB: kmalloc size for node struct available *\/$/;"	e	enum:slab_state
PA_HASH_ORDER	./highmem.c	316;"	d	file:
PCGF_NOCOPY_AT_SPLIT	./memcontrol.c	3641;"	d	file:
PCPU_DFL_MAP_ALLOC	./percpu.c	78;"	d	file:
PCPU_SETUP_BUG_ON	./percpu.c	1235;"	d	file:
PCPU_SETUP_BUG_ON	./percpu.c	1305;"	d	file:
PCPU_SLOT_BASE_SHIFT	./percpu.c	77;"	d	file:
POOL_SIZE	./bounce.c	22;"	d	file:
PRECHARGE_COUNT_AT_ONCE	./memcontrol.c	6544;"	d	file:
PVM_MAX_KMALLOC_PAGES	./process_vm_access.c	67;"	d	file:
PVM_MAX_PP_ARRAY_COUNT	./process_vm_access.c	134;"	d	file:
PageHeadHuge	./hugetlb.c	/^int PageHeadHuge(struct page *page_head)$/;"	f
PageHuge	./hugetlb.c	/^EXPORT_SYMBOL_GPL(PageHuge);$/;"	v
PageHuge	./hugetlb.c	/^int PageHuge(struct page *page)$/;"	f
RATELIMIT_CALC_SHIFT	./page-writeback.c	60;"	d	file:
REAPTIMEOUT_AC	./slab.c	291;"	d	file:
REAPTIMEOUT_NODE	./slab.c	292;"	d	file:
RECLAIM_OFF	./vmscan.c	3459;"	d	file:
RECLAIM_SWAP	./vmscan.c	3462;"	d	file:
RECLAIM_WRITE	./vmscan.c	3461;"	d	file:
RECLAIM_ZONE	./vmscan.c	3460;"	d	file:
RECOVERED	./memory-failure.c	/^	RECOVERED,	\/* Successfully recovered *\/$/;"	e	enum:outcome	file:
REDZONE_ALIGN	./slab.c	154;"	d	file:
SCAN_ANON	./vmscan.c	/^	SCAN_ANON,$/;"	e	enum:scan_balance	file:
SCAN_EQUAL	./vmscan.c	/^	SCAN_EQUAL,$/;"	e	enum:scan_balance	file:
SCAN_FILE	./vmscan.c	/^	SCAN_FILE,$/;"	e	enum:scan_balance	file:
SCAN_FRACT	./vmscan.c	/^	SCAN_FRACT,$/;"	e	enum:scan_balance	file:
SC_PER_PAGE	./page_cgroup.c	338;"	d	file:
SECS_FIRST_SCAN	./kmemleak.c	110;"	d	file:
SECS_SCAN_WAIT	./kmemleak.c	111;"	d	file:
SECTIONS_SHIFT	./mm_init.c	20;"	d	file:
SEQNR_MASK	./ksm.c	181;"	d	file:
SGP_CACHE	./shmem.c	/^	SGP_CACHE,	\/* don't exceed i_size, may allocate page *\/$/;"	e	enum:sgp_type	file:
SGP_DIRTY	./shmem.c	/^	SGP_DIRTY,	\/* like SGP_CACHE, but set new page dirty *\/$/;"	e	enum:sgp_type	file:
SGP_FALLOC	./shmem.c	/^	SGP_FALLOC,	\/* like SGP_WRITE, but make existing page Uptodate *\/$/;"	e	enum:sgp_type	file:
SGP_READ	./shmem.c	/^	SGP_READ,	\/* don't exceed i_size, don't allocate page *\/$/;"	e	enum:sgp_type	file:
SGP_WRITE	./shmem.c	/^	SGP_WRITE,	\/* may exceed i_size, may allocate !Uptodate page *\/$/;"	e	enum:sgp_type	file:
SHMEM_SB	./shmem.c	/^static inline struct shmem_sb_info *SHMEM_SB(struct super_block *sb)$/;"	f	file:
SHORT_SYMLINK_LEN	./shmem.c	80;"	d	file:
SHRINK_BATCH	./vmscan.c	218;"	d	file:
SIZE_AC	./slab.c	239;"	d	file:
SIZE_NODE	./slab.c	240;"	d	file:
SLABINFO_RIGHTS	./slab_common.c	602;"	d	file:
SLABINFO_RIGHTS	./slab_common.c	604;"	d	file:
SLAB_ATTR	./slub.c	4411;"	d	file:
SLAB_ATTR_RO	./slub.c	4407;"	d	file:
SLAB_CACHE_FLAGS	./slab.h	82;"	d
SLAB_CACHE_FLAGS	./slab.h	85;"	d
SLAB_CACHE_FLAGS	./slab.h	88;"	d
SLAB_CORE_FLAGS	./slab.h	69;"	d
SLAB_DEBUG_FLAGS	./slab.h	73;"	d
SLAB_DEBUG_FLAGS	./slab.h	75;"	d
SLAB_DEBUG_FLAGS	./slab.h	78;"	d
SLAB_MAX_ORDER_HI	./slab.c	393;"	d	file:
SLAB_MAX_ORDER_LO	./slab.c	394;"	d	file:
SLAB_OBJ_MAX_NUM	./slab.c	169;"	d	file:
SLAB_OBJ_PFMEMALLOC	./slab.c	206;"	d	file:
SLOB_BREAK1	./slob.c	98;"	d	file:
SLOB_BREAK2	./slob.c	99;"	d	file:
SLOB_UNIT	./slob.c	124;"	d	file:
SLOB_UNITS	./slob.c	125;"	d	file:
SLUB_DEBUG_CMPXCHG	./slub.c	147;"	d	file:
SLUB_MERGE_SAME	./slub.c	179;"	d	file:
SLUB_NEVER_MERGE	./slub.c	175;"	d	file:
SLUB_RESILIENCY_TEST	./slub.c	144;"	d	file:
SL_ALL	./slub.c	/^	SL_ALL,			\/* All slabs *\/$/;"	e	enum:slab_stat_type	file:
SL_CPU	./slub.c	/^	SL_CPU,			\/* Only slabs used for cpu caches *\/$/;"	e	enum:slab_stat_type	file:
SL_OBJECTS	./slub.c	/^	SL_OBJECTS,		\/* Determine allocated objects not slabs *\/$/;"	e	enum:slab_stat_type	file:
SL_PARTIAL	./slub.c	/^	SL_PARTIAL,		\/* Only partially allocated slabs *\/$/;"	e	enum:slab_stat_type	file:
SL_TOTAL	./slub.c	/^	SL_TOTAL		\/* Determine object capacity not slabs *\/$/;"	e	enum:slab_stat_type	file:
SOFTLIMIT_EVENTS_TARGET	./memcontrol.c	136;"	d	file:
SO_ALL	./slub.c	4278;"	d	file:
SO_CPU	./slub.c	4280;"	d	file:
SO_OBJECTS	./slub.c	4281;"	d	file:
SO_PARTIAL	./slub.c	4279;"	d	file:
SO_TOTAL	./slub.c	4282;"	d	file:
STABLE_FLAG	./ksm.c	183;"	d	file:
STATS	./slab.c	144;"	d	file:
STATS	./slab.c	148;"	d	file:
STATS_ADD_REAPED	./slab.c	299;"	d	file:
STATS_ADD_REAPED	./slab.c	323;"	d	file:
STATS_DEC_ACTIVE	./slab.c	296;"	d	file:
STATS_DEC_ACTIVE	./slab.c	320;"	d	file:
STATS_INC_ACOVERFLOW	./slab.c	308;"	d	file:
STATS_INC_ACOVERFLOW	./slab.c	328;"	d	file:
STATS_INC_ACTIVE	./slab.c	295;"	d	file:
STATS_INC_ACTIVE	./slab.c	319;"	d	file:
STATS_INC_ALLOCED	./slab.c	297;"	d	file:
STATS_INC_ALLOCED	./slab.c	321;"	d	file:
STATS_INC_ALLOCHIT	./slab.c	314;"	d	file:
STATS_INC_ALLOCHIT	./slab.c	330;"	d	file:
STATS_INC_ALLOCMISS	./slab.c	315;"	d	file:
STATS_INC_ALLOCMISS	./slab.c	331;"	d	file:
STATS_INC_ERR	./slab.c	305;"	d	file:
STATS_INC_ERR	./slab.c	325;"	d	file:
STATS_INC_FREEHIT	./slab.c	316;"	d	file:
STATS_INC_FREEHIT	./slab.c	332;"	d	file:
STATS_INC_FREEMISS	./slab.c	317;"	d	file:
STATS_INC_FREEMISS	./slab.c	333;"	d	file:
STATS_INC_GROWN	./slab.c	298;"	d	file:
STATS_INC_GROWN	./slab.c	322;"	d	file:
STATS_INC_NODEALLOCS	./slab.c	306;"	d	file:
STATS_INC_NODEALLOCS	./slab.c	326;"	d	file:
STATS_INC_NODEFREES	./slab.c	307;"	d	file:
STATS_INC_NODEFREES	./slab.c	327;"	d	file:
STATS_SET_FREEABLE	./slab.c	309;"	d	file:
STATS_SET_FREEABLE	./slab.c	329;"	d	file:
STATS_SET_HIGH	./slab.c	300;"	d	file:
STATS_SET_HIGH	./slab.c	324;"	d	file:
STAT_ATTR	./slub.c	4859;"	d	file:
SWAPFILE_CLUSTER	./swapfile.c	178;"	d	file:
SYSCALL_DEFINE0	./mlock.c	/^SYSCALL_DEFINE0(munlockall)$/;"	f
SYSCALL_DEFINE1	./mlock.c	/^SYSCALL_DEFINE1(mlockall, int, flags)$/;"	f
SYSCALL_DEFINE1	./mmap.c	/^SYSCALL_DEFINE1(brk, unsigned long, brk)$/;"	f
SYSCALL_DEFINE1	./mmap.c	/^SYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)$/;"	f
SYSCALL_DEFINE1	./nommu.c	/^SYSCALL_DEFINE1(brk, unsigned long, brk)$/;"	f
SYSCALL_DEFINE1	./nommu.c	/^SYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)$/;"	f
SYSCALL_DEFINE1	./swapfile.c	/^SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)$/;"	f
SYSCALL_DEFINE2	./mlock.c	/^SYSCALL_DEFINE2(mlock, unsigned long, start, size_t, len)$/;"	f
SYSCALL_DEFINE2	./mlock.c	/^SYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)$/;"	f
SYSCALL_DEFINE2	./mmap.c	/^SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)$/;"	f
SYSCALL_DEFINE2	./nommu.c	/^SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)$/;"	f
SYSCALL_DEFINE2	./swapfile.c	/^SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)$/;"	f
SYSCALL_DEFINE3	./madvise.c	/^SYSCALL_DEFINE3(madvise, unsigned long, start, size_t, len_in, int, behavior)$/;"	f
SYSCALL_DEFINE3	./mempolicy.c	/^SYSCALL_DEFINE3(set_mempolicy, int, mode, unsigned long __user *, nmask,$/;"	f
SYSCALL_DEFINE3	./mincore.c	/^SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,$/;"	f
SYSCALL_DEFINE3	./mprotect.c	/^SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,$/;"	f
SYSCALL_DEFINE3	./msync.c	/^SYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)$/;"	f
SYSCALL_DEFINE3	./readahead.c	/^SYSCALL_DEFINE3(readahead, int, fd, loff_t, offset, size_t, count)$/;"	f
SYSCALL_DEFINE4	./fadvise.c	/^SYSCALL_DEFINE4(fadvise64, int, fd, loff_t, offset, size_t, len, int, advice)$/;"	f
SYSCALL_DEFINE4	./fadvise.c	/^SYSCALL_DEFINE4(fadvise64_64, int, fd, loff_t, offset, loff_t, len, int, advice)$/;"	f
SYSCALL_DEFINE4	./mempolicy.c	/^SYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,$/;"	f
SYSCALL_DEFINE5	./fremap.c	/^SYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,$/;"	f
SYSCALL_DEFINE5	./mempolicy.c	/^SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,$/;"	f
SYSCALL_DEFINE5	./mremap.c	/^SYSCALL_DEFINE5(mremap, unsigned long, addr, unsigned long, old_len,$/;"	f
SYSCALL_DEFINE5	./nommu.c	/^SYSCALL_DEFINE5(mremap, unsigned long, addr, unsigned long, old_len,$/;"	f
SYSCALL_DEFINE6	./mempolicy.c	/^SYSCALL_DEFINE6(mbind, unsigned long, start, unsigned long, len,$/;"	f
SYSCALL_DEFINE6	./migrate.c	/^SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,$/;"	f
SYSCALL_DEFINE6	./mmap.c	/^SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,$/;"	f
SYSCALL_DEFINE6	./nommu.c	/^SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,$/;"	f
SYSCALL_DEFINE6	./process_vm_access.c	/^SYSCALL_DEFINE6(process_vm_readv, pid_t, pid, const struct iovec __user *, lvec,$/;"	f
SYSCALL_DEFINE6	./process_vm_access.c	/^SYSCALL_DEFINE6(process_vm_writev, pid_t, pid,$/;"	f
TASK_RSS_EVENTS_THRESH	./memory.c	163;"	d	file:
TEXTS_FOR_ZONES	./vmstat.c	732;"	d	file:
TEXT_FOR_DMA	./vmstat.c	715;"	d	file:
TEXT_FOR_DMA	./vmstat.c	717;"	d	file:
TEXT_FOR_DMA32	./vmstat.c	721;"	d	file:
TEXT_FOR_DMA32	./vmstat.c	723;"	d	file:
TEXT_FOR_HIGHMEM	./vmstat.c	727;"	d	file:
TEXT_FOR_HIGHMEM	./vmstat.c	729;"	d	file:
THRESHOLDS_EVENTS_TARGET	./memcontrol.c	135;"	d	file:
TID_STEP	./slub.c	1738;"	d	file:
TID_STEP	./slub.c	1744;"	d	file:
TRACK_ADDRS_COUNT	./slub.c	197;"	d	file:
TRACK_ALLOC	./slub.c	/^enum track_item { TRACK_ALLOC, TRACK_FREE };$/;"	e	enum:track_item	file:
TRACK_FREE	./slub.c	/^enum track_item { TRACK_ALLOC, TRACK_FREE };$/;"	e	enum:track_item	file:
UNSTABLE_FLAG	./ksm.c	182;"	d	file:
UP	./slab.h	/^	UP,			\/* Slab caches usable but not all extras yet *\/$/;"	e	enum:slab_state
Unused_file	./swapfile.c	/^static const char Unused_file[] = "Unused swap file entry ";$/;"	v	file:
Unused_offset	./swapfile.c	/^static const char Unused_offset[] = "Unused swap offset entry ";$/;"	v	file:
VMALLOC_PAGES	./vmalloc.c	740;"	d	file:
VMALLOC_SPACE	./vmalloc.c	735;"	d	file:
VMALLOC_SPACE	./vmalloc.c	737;"	d	file:
VMAP_BBMAP_BITS	./vmalloc.c	746;"	d	file:
VMAP_BBMAP_BITS_MAX	./vmalloc.c	742;"	d	file:
VMAP_BBMAP_BITS_MIN	./vmalloc.c	743;"	d	file:
VMAP_BLOCK_SIZE	./vmalloc.c	751;"	d	file:
VMAP_MAX	./vmalloc.c	745;"	d	file:
VMAP_MAX_ALLOC	./vmalloc.c	741;"	d	file:
VMAP_MIN	./vmalloc.c	744;"	d	file:
VMPRESSURE_CRITICAL	./vmpressure.c	/^	VMPRESSURE_CRITICAL,$/;"	e	enum:vmpressure_levels	file:
VMPRESSURE_LOW	./vmpressure.c	/^	VMPRESSURE_LOW = 0,$/;"	e	enum:vmpressure_levels	file:
VMPRESSURE_MEDIUM	./vmpressure.c	/^	VMPRESSURE_MEDIUM,$/;"	e	enum:vmpressure_levels	file:
VMPRESSURE_NUM_LEVELS	./vmpressure.c	/^	VMPRESSURE_NUM_LEVELS,$/;"	e	enum:vmpressure_levels	file:
VM_ACCT	./shmem.c	74;"	d	file:
VM_COMPLETIONS_PERIOD_LEN	./page-writeback.c	156;"	d	file:
VM_LAZY_FREE	./vmalloc.c	270;"	d	file:
VM_LAZY_FREEING	./vmalloc.c	271;"	d	file:
VM_NO_THP	./huge_memory.c	1896;"	d	file:
VM_VM_AREA	./vmalloc.c	272;"	d	file:
WRITEBACK_TAG_BATCH	./page-writeback.c	1824;"	d	file:
ZHDR_SIZE_ALIGNED	./zbud.c	70;"	d	file:
ZONELIST_ORDER_DEFAULT	./page_alloc.c	3293;"	d	file:
ZONELIST_ORDER_NODE	./page_alloc.c	3294;"	d	file:
ZONELIST_ORDER_ZONE	./page_alloc.c	3295;"	d	file:
ZONE_RECLAIM_FULL	./internal.h	355;"	d
ZONE_RECLAIM_NOSCAN	./internal.h	354;"	d
ZONE_RECLAIM_PRIORITY	./vmscan.c	3469;"	d	file:
ZONE_RECLAIM_SOME	./internal.h	356;"	d
ZONE_RECLAIM_SUCCESS	./internal.h	357;"	d
ZSWAP_COMPOP_COMPRESS	./zswap.c	/^	ZSWAP_COMPOP_COMPRESS,$/;"	e	enum:comp_op	file:
ZSWAP_COMPOP_DECOMPRESS	./zswap.c	/^	ZSWAP_COMPOP_DECOMPRESS$/;"	e	enum:comp_op	file:
ZSWAP_COMPRESSOR_DEFAULT	./zswap.c	83;"	d	file:
ZSWAP_SWAPCACHE_EXIST	./zswap.c	/^	ZSWAP_SWAPCACHE_EXIST,$/;"	e	enum:zswap_get_swap_ret	file:
ZSWAP_SWAPCACHE_FAIL	./zswap.c	/^	ZSWAP_SWAPCACHE_FAIL,$/;"	e	enum:zswap_get_swap_ret	file:
ZSWAP_SWAPCACHE_NEW	./zswap.c	/^	ZSWAP_SWAPCACHE_NEW,$/;"	e	enum:zswap_get_swap_ret	file:
ZS_ALIGN	./zsmalloc.c	102;"	d	file:
ZS_ALMOST_EMPTY	./zsmalloc.c	/^	ZS_ALMOST_EMPTY,$/;"	e	enum:fullness_group	file:
ZS_ALMOST_FULL	./zsmalloc.c	/^	ZS_ALMOST_FULL,$/;"	e	enum:fullness_group	file:
ZS_EMPTY	./zsmalloc.c	/^	ZS_EMPTY,$/;"	e	enum:fullness_group	file:
ZS_FULL	./zsmalloc.c	/^	ZS_FULL$/;"	e	enum:fullness_group	file:
ZS_MAX_ALLOC_SIZE	./zsmalloc.c	141;"	d	file:
ZS_MAX_PAGES_PER_ZSPAGE	./zsmalloc.c	109;"	d	file:
ZS_MAX_ZSPAGE_ORDER	./zsmalloc.c	108;"	d	file:
ZS_MIN_ALLOC_SIZE	./zsmalloc.c	139;"	d	file:
ZS_SIZE_CLASSES	./zsmalloc.c	157;"	d	file:
ZS_SIZE_CLASS_DELTA	./zsmalloc.c	156;"	d	file:
_KMEM	./memcontrol.c	/^	_KMEM,$/;"	e	enum:res_type	file:
_MEM	./memcontrol.c	/^	_MEM,$/;"	e	enum:res_type	file:
_MEMSWAP	./memcontrol.c	/^	_MEMSWAP,$/;"	e	enum:res_type	file:
_OOM_TYPE	./memcontrol.c	/^	_OOM_TYPE,$/;"	e	enum:res_type	file:
_PFN_BITS	./zsmalloc.c	133;"	d	file:
_ZS_NR_FULLNESS_GROUPS	./zsmalloc.c	/^	_ZS_NR_FULLNESS_GROUPS,$/;"	e	enum:fullness_group	file:
__CMPXCHG_DOUBLE	./slub.c	188;"	d	file:
__MM_INTERNAL_H	./internal.h	12;"	d
__OBJECT_POISON	./slub.c	187;"	d	file:
____cache_alloc	./slab.c	/^static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)$/;"	f	file:
____cache_alloc_node	./slab.c	/^static inline void *____cache_alloc_node(struct kmem_cache *cachep,$/;"	f	file:
____cache_alloc_node	./slab.c	/^static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,$/;"	f	file:
____cacheline_aligned_in_smp	./hugetlb.c	/^static struct mutex *htlb_fault_mutex_table ____cacheline_aligned_in_smp;$/;"	v	typeref:struct:htlb_fault_mutex_table	file:
____cacheline_aligned_in_smp	./mmap.c	/^struct percpu_counter vm_committed_as ____cacheline_aligned_in_smp;$/;"	v	typeref:struct:vm_committed_as
____cacheline_internodealigned_in_smp	./sparse.c	/^	____cacheline_internodealigned_in_smp;$/;"	v	typeref:struct:mem_section
___alloc_bootmem	./bootmem.c	/^static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,$/;"	f	file:
___alloc_bootmem	./nobootmem.c	/^static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,$/;"	f	file:
___alloc_bootmem_node	./bootmem.c	/^void * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,$/;"	f
___alloc_bootmem_node	./nobootmem.c	/^static void * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,$/;"	f	file:
___alloc_bootmem_node_nopanic	./bootmem.c	/^void * __init ___alloc_bootmem_node_nopanic(pg_data_t *pgdat,$/;"	f
___alloc_bootmem_node_nopanic	./nobootmem.c	/^void * __init ___alloc_bootmem_node_nopanic(pg_data_t *pgdat,$/;"	f
___alloc_bootmem_nopanic	./bootmem.c	/^static void * __init ___alloc_bootmem_nopanic(unsigned long size,$/;"	f	file:
___alloc_bootmem_nopanic	./nobootmem.c	/^static void * __init ___alloc_bootmem_nopanic(unsigned long size,$/;"	f	file:
__absent_pages_in_range	./page_alloc.c	/^unsigned long __meminit __absent_pages_in_range(int nid,$/;"	f
__ac_get_obj	./slab.c	/^static void *__ac_get_obj(struct kmem_cache *cachep, struct array_cache *ac,$/;"	f	file:
__ac_put_obj	./slab.c	/^static void *__ac_put_obj(struct kmem_cache *cachep, struct array_cache *ac,$/;"	f	file:
__access_remote_vm	./memory.c	/^static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,$/;"	f	file:
__access_remote_vm	./nommu.c	/^static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,$/;"	f	file:
__activate_page	./swap.c	/^static void __activate_page(struct page *page, struct lruvec *lruvec,$/;"	f	file:
__add_pages	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(__add_pages);$/;"	v
__add_pages	./memory_hotplug.c	/^int __ref __add_pages(int nid, struct zone *zone, unsigned long phys_start_pfn,$/;"	f
__add_partial	./slub.c	/^__add_partial(struct kmem_cache_node *n, struct page *page, int tail)$/;"	f	file:
__add_section	./memory_hotplug.c	/^static int __meminit __add_section(int nid, struct zone *zone,$/;"	f	file:
__add_to_page_cache_locked	./filemap.c	/^static int __add_to_page_cache_locked(struct page *page,$/;"	f	file:
__add_to_swap_cache	./swap_state.c	/^int __add_to_swap_cache(struct page *page, swp_entry_t entry)$/;"	f
__add_zone	./memory_hotplug.c	/^static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)$/;"	f	file:
__addr_to_pcpu_ptr	./percpu.c	83;"	d	file:
__addr_to_pcpu_ptr	./percpu.c	96;"	d	file:
__alloc_bootmem	./bootmem.c	/^void * __init __alloc_bootmem(unsigned long size, unsigned long align,$/;"	f
__alloc_bootmem	./nobootmem.c	/^void * __init __alloc_bootmem(unsigned long size, unsigned long align,$/;"	f
__alloc_bootmem_low	./bootmem.c	/^void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,$/;"	f
__alloc_bootmem_low	./nobootmem.c	/^void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,$/;"	f
__alloc_bootmem_low_node	./bootmem.c	/^void * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_low_node	./nobootmem.c	/^void * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_low_nopanic	./bootmem.c	/^void * __init __alloc_bootmem_low_nopanic(unsigned long size,$/;"	f
__alloc_bootmem_low_nopanic	./nobootmem.c	/^void * __init __alloc_bootmem_low_nopanic(unsigned long size,$/;"	f
__alloc_bootmem_node	./bootmem.c	/^void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_node	./nobootmem.c	/^void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_node_high	./bootmem.c	/^void * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_node_high	./nobootmem.c	/^void * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_node_nopanic	./bootmem.c	/^void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_node_nopanic	./nobootmem.c	/^void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,$/;"	f
__alloc_bootmem_nopanic	./bootmem.c	/^void * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,$/;"	f
__alloc_bootmem_nopanic	./nobootmem.c	/^void * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,$/;"	f
__alloc_contig_migrate_range	./page_alloc.c	/^static int __alloc_contig_migrate_range(struct compact_control *cc,$/;"	f	file:
__alloc_memory_core_early	./nobootmem.c	/^static void * __init __alloc_memory_core_early(int nid, u64 size, u64 align,$/;"	f	file:
__alloc_pages_direct_compact	./page_alloc.c	/^__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,$/;"	f	file:
__alloc_pages_direct_reclaim	./page_alloc.c	/^__alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,$/;"	f	file:
__alloc_pages_high_priority	./page_alloc.c	/^__alloc_pages_high_priority(gfp_t gfp_mask, unsigned int order,$/;"	f	file:
__alloc_pages_may_oom	./page_alloc.c	/^__alloc_pages_may_oom(gfp_t gfp_mask, unsigned int order,$/;"	f	file:
__alloc_pages_nodemask	./page_alloc.c	/^EXPORT_SYMBOL(__alloc_pages_nodemask);$/;"	v
__alloc_pages_nodemask	./page_alloc.c	/^__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,$/;"	f
__alloc_pages_slowpath	./page_alloc.c	/^__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,$/;"	f	file:
__alloc_percpu	./percpu.c	/^EXPORT_SYMBOL_GPL(__alloc_percpu);$/;"	v
__alloc_percpu	./percpu.c	/^void __percpu *__alloc_percpu(size_t size, size_t align)$/;"	f
__alloc_reserved_percpu	./percpu.c	/^void __percpu *__alloc_reserved_percpu(size_t size, size_t align)$/;"	f
__basepage_index	./hugetlb.c	/^pgoff_t __basepage_index(struct page *page)$/;"	f
__bdi_update_bandwidth	./page-writeback.c	/^void __bdi_update_bandwidth(struct backing_dev_info *bdi,$/;"	f
__bdi_writeout_inc	./page-writeback.c	/^static inline void __bdi_writeout_inc(struct backing_dev_info *bdi)$/;"	f	file:
__blk_queue_bounce	./bounce.c	/^static void __blk_queue_bounce(struct request_queue *q, struct bio **bio_orig,$/;"	f	file:
__bounce_end_io_read	./bounce.c	/^static void __bounce_end_io_read(struct bio *bio, mempool_t *pool, int err)$/;"	f	file:
__build_all_zonelists	./page_alloc.c	/^static int __build_all_zonelists(void *data)$/;"	f	file:
__cache_free	./slab.c	/^static inline void __cache_free(struct kmem_cache *cachep, void *objp,$/;"	f	file:
__cache_shrink	./slab.c	/^static int __cache_shrink(struct kmem_cache *cachep)$/;"	f	file:
__cacheline_aligned	./sparse.c	/^static u16 section_to_node_table[NR_MEM_SECTIONS] __cacheline_aligned;$/;"	v	file:
__cacheline_aligned	./sparse.c	/^static u8 section_to_node_table[NR_MEM_SECTIONS] __cacheline_aligned;$/;"	v	file:
__cacheline_aligned_in_smp	./vmstat.c	/^atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS] __cacheline_aligned_in_smp;$/;"	v
__cleancache_get_page	./cleancache.c	/^EXPORT_SYMBOL(__cleancache_get_page);$/;"	v
__cleancache_get_page	./cleancache.c	/^int __cleancache_get_page(struct page *page)$/;"	f
__cleancache_init_fs	./cleancache.c	/^EXPORT_SYMBOL(__cleancache_init_fs);$/;"	v
__cleancache_init_fs	./cleancache.c	/^void __cleancache_init_fs(struct super_block *sb)$/;"	f
__cleancache_init_shared_fs	./cleancache.c	/^EXPORT_SYMBOL(__cleancache_init_shared_fs);$/;"	v
__cleancache_init_shared_fs	./cleancache.c	/^void __cleancache_init_shared_fs(char *uuid, struct super_block *sb)$/;"	f
__cleancache_invalidate_fs	./cleancache.c	/^EXPORT_SYMBOL(__cleancache_invalidate_fs);$/;"	v
__cleancache_invalidate_fs	./cleancache.c	/^void __cleancache_invalidate_fs(struct super_block *sb)$/;"	f
__cleancache_invalidate_inode	./cleancache.c	/^EXPORT_SYMBOL(__cleancache_invalidate_inode);$/;"	v
__cleancache_invalidate_inode	./cleancache.c	/^void __cleancache_invalidate_inode(struct address_space *mapping)$/;"	f
__cleancache_invalidate_page	./cleancache.c	/^EXPORT_SYMBOL(__cleancache_invalidate_page);$/;"	v
__cleancache_invalidate_page	./cleancache.c	/^void __cleancache_invalidate_page(struct address_space *mapping,$/;"	f
__cleancache_put_page	./cleancache.c	/^EXPORT_SYMBOL(__cleancache_put_page);$/;"	v
__cleancache_put_page	./cleancache.c	/^void __cleancache_put_page(struct page *page)$/;"	f
__cmpxchg_double_slab	./slub.c	/^static inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,$/;"	f	file:
__collapse_huge_page_copy	./huge_memory.c	/^static void __collapse_huge_page_copy(pte_t *pte, struct page *page,$/;"	f	file:
__collapse_huge_page_isolate	./huge_memory.c	/^static int __collapse_huge_page_isolate(struct vm_area_struct *vma,$/;"	f	file:
__compact_pgdat	./compaction.c	/^static void __compact_pgdat(pg_data_t *pgdat, struct compact_control *cc)$/;"	f	file:
__copy_gigantic_page	./migrate.c	/^static void __copy_gigantic_page(struct page *dst, struct page *src,$/;"	f	file:
__dec_zone_page_state	./vmstat.c	/^EXPORT_SYMBOL(__dec_zone_page_state);$/;"	v
__dec_zone_page_state	./vmstat.c	/^void __dec_zone_page_state(struct page *page, enum zone_stat_item item)$/;"	f
__dec_zone_state	./vmstat.c	/^void __dec_zone_state(struct zone *zone, enum zone_stat_item item)$/;"	f
__delete_from_page_cache	./filemap.c	/^void __delete_from_page_cache(struct page *page, void *shadow)$/;"	f
__delete_from_swap_cache	./swap_state.c	/^void __delete_from_swap_cache(struct page *page)$/;"	f
__delete_object	./kmemleak.c	/^static void __delete_object(struct kmemleak_object *object)$/;"	f	file:
__do_cache_alloc	./slab.c	/^__do_cache_alloc(struct kmem_cache *cache, gfp_t flags)$/;"	f	file:
__do_cache_alloc	./slab.c	/^__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)$/;"	f	file:
__do_fault	./memory.c	/^static int __do_fault(struct vm_area_struct *vma, unsigned long address,$/;"	f	file:
__do_huge_pmd_anonymous_page	./huge_memory.c	/^static int __do_huge_pmd_anonymous_page(struct mm_struct *mm,$/;"	f	file:
__do_kmalloc	./slab.c	/^static __always_inline void *__do_kmalloc(size_t size, gfp_t flags,$/;"	f	file:
__do_kmalloc_node	./slab.c	/^__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)$/;"	f	file:
__do_kmalloc_node	./slob.c	/^__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)$/;"	f	file:
__do_krealloc	./util.c	/^static __always_inline void *__do_krealloc(const void *p, size_t new_size,$/;"	f	file:
__do_page_cache_readahead	./readahead.c	/^int __do_page_cache_readahead(struct address_space *mapping, struct file *filp,$/;"	f
__do_tune_cpucache	./slab.c	/^static int __do_tune_cpucache(struct kmem_cache *cachep, int limit,$/;"	f	file:
__drain_alien_cache	./slab.c	/^static void __drain_alien_cache(struct kmem_cache *cachep,$/;"	f	file:
__early_ioremap	./early_ioremap.c	/^__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)$/;"	f	file:
__early_pfn_to_nid	./page_alloc.c	/^int __meminit __early_pfn_to_nid(unsigned long pfn)$/;"	f
__earlyonly_bootmem_alloc	./sparse-vmemmap.c	/^static void * __init_refok __earlyonly_bootmem_alloc(int node,$/;"	f	file:
__filemap_fdatawrite	./filemap.c	/^static inline int __filemap_fdatawrite(struct address_space *mapping,$/;"	f	file:
__filemap_fdatawrite_range	./filemap.c	/^int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,$/;"	f
__find_buddy_index	./page_alloc.c	/^__find_buddy_index(unsigned long page_idx, unsigned int order)$/;"	f	file:
__find_vmap_area	./vmalloc.c	/^static struct vmap_area *__find_vmap_area(unsigned long addr)$/;"	f	file:
__first_valid_page	./page_isolation.c	/^__first_valid_page(unsigned long pfn, unsigned long nr_pages)$/;"	f	file:
__flush_cpu_slab	./slub.c	/^static inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)$/;"	f	file:
__follow_pte	./memory.c	/^static int __follow_pte(struct mm_struct *mm, unsigned long address,$/;"	f	file:
__fragmentation_index	./vmstat.c	/^static int __fragmentation_index(unsigned int order, struct contig_page_info *info)$/;"	f	file:
__free	./bootmem.c	/^static void __init __free(bootmem_data_t *bdata,$/;"	f	file:
__free_memcg_kmem_pages	./page_alloc.c	/^void __free_memcg_kmem_pages(struct page *page, unsigned int order)$/;"	f
__free_memory_core	./nobootmem.c	/^static unsigned long __init __free_memory_core(phys_addr_t start,$/;"	f	file:
__free_one_page	./page_alloc.c	/^static inline void __free_one_page(struct page *page,$/;"	f	file:
__free_page_cgroup	./page_cgroup.c	/^static void __free_page_cgroup(unsigned long pfn)$/;"	f	file:
__free_pages	./page_alloc.c	/^EXPORT_SYMBOL(__free_pages);$/;"	v
__free_pages	./page_alloc.c	/^void __free_pages(struct page *page, unsigned int order)$/;"	f
__free_pages_bootmem	./page_alloc.c	/^void __init __free_pages_bootmem(struct page *page, unsigned int order)$/;"	f
__free_pages_memory	./nobootmem.c	/^static void __init __free_pages_memory(unsigned long start, unsigned long end)$/;"	f	file:
__free_pages_ok	./page_alloc.c	/^static void __free_pages_ok(struct page *page, unsigned int order)$/;"	f	file:
__free_slab	./slub.c	/^static void __free_slab(struct kmem_cache *s, struct page *page)$/;"	f	file:
__free_vmap_area	./vmalloc.c	/^static void __free_vmap_area(struct vmap_area *va)$/;"	f	file:
__frontswap_clear	./frontswap.c	/^static inline void __frontswap_clear(struct swap_info_struct *sis,$/;"	f	file:
__frontswap_curr_pages	./frontswap.c	/^static unsigned long __frontswap_curr_pages(void)$/;"	f	file:
__frontswap_init	./frontswap.c	/^EXPORT_SYMBOL(__frontswap_init);$/;"	v
__frontswap_init	./frontswap.c	/^void __frontswap_init(unsigned type, unsigned long *map)$/;"	f
__frontswap_invalidate_area	./frontswap.c	/^EXPORT_SYMBOL(__frontswap_invalidate_area);$/;"	v
__frontswap_invalidate_area	./frontswap.c	/^void __frontswap_invalidate_area(unsigned type)$/;"	f
__frontswap_invalidate_page	./frontswap.c	/^EXPORT_SYMBOL(__frontswap_invalidate_page);$/;"	v
__frontswap_invalidate_page	./frontswap.c	/^void __frontswap_invalidate_page(unsigned type, pgoff_t offset)$/;"	f
__frontswap_load	./frontswap.c	/^EXPORT_SYMBOL(__frontswap_load);$/;"	v
__frontswap_load	./frontswap.c	/^int __frontswap_load(struct page *page)$/;"	f
__frontswap_shrink	./frontswap.c	/^static int __frontswap_shrink(unsigned long target_pages,$/;"	f	file:
__frontswap_store	./frontswap.c	/^EXPORT_SYMBOL(__frontswap_store);$/;"	v
__frontswap_store	./frontswap.c	/^int __frontswap_store(struct page *page)$/;"	f
__frontswap_test	./frontswap.c	/^EXPORT_SYMBOL(__frontswap_test);$/;"	v
__frontswap_test	./frontswap.c	/^bool __frontswap_test(struct swap_info_struct *sis,$/;"	f
__frontswap_unuse_pages	./frontswap.c	/^static int __frontswap_unuse_pages(unsigned long total, unsigned long *unused,$/;"	f	file:
__generic_file_aio_write	./filemap.c	/^EXPORT_SYMBOL(__generic_file_aio_write);$/;"	v
__generic_file_aio_write	./filemap.c	/^ssize_t __generic_file_aio_write(struct kiocb *iocb, const struct iovec *iov,$/;"	f
__get_any_page	./memory-failure.c	/^static int __get_any_page(struct page *p, unsigned long pfn, int flags)$/;"	f	file:
__get_free_pages	./page_alloc.c	/^EXPORT_SYMBOL(__get_free_pages);$/;"	v
__get_free_pages	./page_alloc.c	/^unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)$/;"	f
__get_locked_pte	./memory.c	/^pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,$/;"	f
__get_page_tail	./swap.c	/^EXPORT_SYMBOL(__get_page_tail);$/;"	v
__get_page_tail	./swap.c	/^bool __get_page_tail(struct page *page)$/;"	f
__get_page_tail_foll	./internal.h	/^static inline void __get_page_tail_foll(struct page *page,$/;"	f
__get_user_pages	./memory.c	/^EXPORT_SYMBOL(__get_user_pages);$/;"	v
__get_user_pages	./memory.c	/^long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,$/;"	f
__get_user_pages	./nommu.c	/^long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,$/;"	f
__get_user_pages_fast	./util.c	/^EXPORT_SYMBOL_GPL(__get_user_pages_fast);$/;"	v
__get_user_pages_fast	./util.c	/^int __weak __get_user_pages_fast(unsigned long start,$/;"	f
__get_vm_area	./vmalloc.c	/^EXPORT_SYMBOL_GPL(__get_vm_area);$/;"	v
__get_vm_area	./vmalloc.c	/^struct vm_struct *__get_vm_area(unsigned long size, unsigned long flags,$/;"	f
__get_vm_area_caller	./vmalloc.c	/^struct vm_struct *__get_vm_area_caller(unsigned long size, unsigned long flags,$/;"	f
__get_vm_area_node	./vmalloc.c	/^static struct vm_struct *__get_vm_area_node(unsigned long size,$/;"	f	file:
__handle_mm_fault	./memory.c	/^static int __handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
__hugepage_set_anon_rmap	./rmap.c	/^static void __hugepage_set_anon_rmap(struct page *page,$/;"	f	file:
__hugetlb_cgroup_file_init	./hugetlb_cgroup.c	/^static void __init __hugetlb_cgroup_file_init(int idx)$/;"	f	file:
__inc_zone_page_state	./vmstat.c	/^EXPORT_SYMBOL(__inc_zone_page_state);$/;"	v
__inc_zone_page_state	./vmstat.c	/^void __inc_zone_page_state(struct page *page, enum zone_stat_item item)$/;"	f
__inc_zone_state	./vmstat.c	/^void __inc_zone_state(struct zone *zone, enum zone_stat_item item)$/;"	f
__initconst	./percpu.c	/^const char * const pcpu_fc_names[PCPU_FC_NR] __initconst = {$/;"	v
__initdata	./bootmem.c	/^bootmem_data_t bootmem_node_data[MAX_NUMNODES] __initdata;$/;"	v
__initdata	./bootmem.c	/^static int reset_managed_pages_done __initdata;$/;"	v	file:
__initdata	./bootmem.c	/^static struct list_head bdata_list __initdata = LIST_HEAD_INIT(bdata_list);$/;"	v	typeref:struct:bdata_list	file:
__initdata	./early_ioremap.c	/^static int after_paging_init __initdata;$/;"	v	file:
__initdata	./early_ioremap.c	/^static int early_ioremap_debug __initdata;$/;"	v	file:
__initdata	./early_ioremap.c	/^static unsigned long prev_size[FIX_BTMAPS_SLOTS] __initdata;$/;"	v	file:
__initdata	./early_ioremap.c	/^static unsigned long slot_virt[FIX_BTMAPS_SLOTS] __initdata;$/;"	v	file:
__initdata	./early_ioremap.c	/^static void __iomem *prev_map[FIX_BTMAPS_SLOTS] __initdata;$/;"	v	file:
__initdata	./kmemleak.c	/^	early_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE] __initdata;$/;"	v	typeref:struct:early_log	file:
__initdata	./kmemleak.c	/^static int crt_early_log __initdata;$/;"	v	file:
__initdata	./memcontrol.c	/^static int really_do_swap_account __initdata = 0;$/;"	v	file:
__initdata	./memcontrol.c	/^static int really_do_swap_account __initdata = 1;$/;"	v	file:
__initdata	./nobootmem.c	/^static int reset_managed_pages_done __initdata;$/;"	v	file:
__initdata	./percpu.c	/^enum pcpu_fc pcpu_chosen_fc __initdata = PCPU_FC_AUTO;$/;"	v	typeref:enum:pcpu_chosen_fc
__initdata	./slab.c	/^static bool slab_max_order_set __initdata;$/;"	v	file:
__initdata	./vmalloc.c	/^static struct vm_struct *vmlist __initdata;$/;"	v	typeref:struct:vmlist	file:
__initdata_memblock	./memblock.c	/^bool movable_node_enabled __initdata_memblock = false;$/;"	v
__initdata_memblock	./memblock.c	/^int memblock_debug __initdata_memblock;$/;"	v
__initdata_memblock	./memblock.c	/^static int memblock_can_resize __initdata_memblock;$/;"	v	file:
__initdata_memblock	./memblock.c	/^static int memblock_memory_in_slab __initdata_memblock = 0;$/;"	v	file:
__initdata_memblock	./memblock.c	/^static int memblock_reserved_in_slab __initdata_memblock = 0;$/;"	v	file:
__initdata_memblock	./memblock.c	/^static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;$/;"	v	typeref:struct:memblock_memory_init_regions	file:
__initdata_memblock	./memblock.c	/^static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;$/;"	v	typeref:struct:memblock_reserved_init_regions	file:
__initdata_memblock	./memblock.c	/^struct memblock memblock __initdata_memblock = {$/;"	v	typeref:struct:memblock
__insert_vm_struct	./mmap.c	/^static void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)$/;"	f	file:
__insert_vmap_area	./vmalloc.c	/^static void __insert_vmap_area(struct vmap_area *va)$/;"	f	file:
__iovec_copy_from_user_inatomic	./iov_iter.c	/^static size_t __iovec_copy_from_user_inatomic(char *vaddr,$/;"	f	file:
__isolate_balloon_page	./balloon_compaction.c	/^static inline void __isolate_balloon_page(struct page *page)$/;"	f	file:
__isolate_free_page	./page_alloc.c	/^static int __isolate_free_page(struct page *page, unsigned int order)$/;"	f	file:
__isolate_lru_page	./vmscan.c	/^int __isolate_lru_page(struct page *page, isolate_mode_t mode)$/;"	f
__kfree_section_memmap	./sparse.c	/^static void __kfree_section_memmap(struct page *memmap)$/;"	f	file:
__khugepaged_enter	./huge_memory.c	/^int __khugepaged_enter(struct mm_struct *mm)$/;"	f
__khugepaged_exit	./huge_memory.c	/^void __khugepaged_exit(struct mm_struct *mm)$/;"	f
__kmalloc	./slab.c	/^EXPORT_SYMBOL(__kmalloc);$/;"	v
__kmalloc	./slab.c	/^void *__kmalloc(size_t size, gfp_t flags)$/;"	f
__kmalloc	./slob.c	/^EXPORT_SYMBOL(__kmalloc);$/;"	v
__kmalloc	./slob.c	/^void *__kmalloc(size_t size, gfp_t gfp)$/;"	f
__kmalloc	./slub.c	/^EXPORT_SYMBOL(__kmalloc);$/;"	v
__kmalloc	./slub.c	/^void *__kmalloc(size_t size, gfp_t flags)$/;"	f
__kmalloc_node	./slab.c	/^EXPORT_SYMBOL(__kmalloc_node);$/;"	v
__kmalloc_node	./slab.c	/^void *__kmalloc_node(size_t size, gfp_t flags, int node)$/;"	f
__kmalloc_node	./slob.c	/^EXPORT_SYMBOL(__kmalloc_node);$/;"	v
__kmalloc_node	./slob.c	/^void *__kmalloc_node(size_t size, gfp_t gfp, int node)$/;"	f
__kmalloc_node	./slub.c	/^EXPORT_SYMBOL(__kmalloc_node);$/;"	v
__kmalloc_node	./slub.c	/^void *__kmalloc_node(size_t size, gfp_t flags, int node)$/;"	f
__kmalloc_node_track_caller	./slab.c	/^EXPORT_SYMBOL(__kmalloc_node_track_caller);$/;"	v
__kmalloc_node_track_caller	./slab.c	/^void *__kmalloc_node_track_caller(size_t size, gfp_t flags,$/;"	f
__kmalloc_node_track_caller	./slob.c	/^void *__kmalloc_node_track_caller(size_t size, gfp_t gfp,$/;"	f
__kmalloc_node_track_caller	./slub.c	/^void *__kmalloc_node_track_caller(size_t size, gfp_t gfpflags,$/;"	f
__kmalloc_section_memmap	./sparse.c	/^static struct page *__kmalloc_section_memmap(void)$/;"	f	file:
__kmalloc_section_usemap	./sparse.c	/^static unsigned long *__kmalloc_section_usemap(void)$/;"	f	file:
__kmalloc_track_caller	./slab.c	/^EXPORT_SYMBOL(__kmalloc_track_caller);$/;"	v
__kmalloc_track_caller	./slab.c	/^void *__kmalloc_track_caller(size_t size, gfp_t flags, unsigned long caller)$/;"	f
__kmalloc_track_caller	./slob.c	/^void *__kmalloc_track_caller(size_t size, gfp_t gfp, unsigned long caller)$/;"	f
__kmalloc_track_caller	./slub.c	/^void *__kmalloc_track_caller(size_t size, gfp_t gfpflags, unsigned long caller)$/;"	f
__kmap_atomic_idx	./highmem.c	/^EXPORT_PER_CPU_SYMBOL(__kmap_atomic_idx);$/;"	v
__kmem_cache_alias	./slab.h	/^__kmem_cache_alias(const char *name, size_t size, size_t align,$/;"	f
__kmem_cache_alias	./slub.c	/^__kmem_cache_alias(const char *name, size_t size, size_t align,$/;"	f
__kmem_cache_create	./slab.c	/^__kmem_cache_create (struct kmem_cache *cachep, unsigned long flags)$/;"	f
__kmem_cache_create	./slob.c	/^int __kmem_cache_create(struct kmem_cache *c, unsigned long flags)$/;"	f
__kmem_cache_create	./slub.c	/^int __kmem_cache_create(struct kmem_cache *s, unsigned long flags)$/;"	f
__kmem_cache_destroy_memcg_children	./memcontrol.c	/^int __kmem_cache_destroy_memcg_children(struct kmem_cache *s)$/;"	f
__kmem_cache_free	./slob.c	/^static void __kmem_cache_free(void *b, int size)$/;"	f	file:
__kmem_cache_shutdown	./slab.c	/^int __kmem_cache_shutdown(struct kmem_cache *cachep)$/;"	f
__kmem_cache_shutdown	./slob.c	/^int __kmem_cache_shutdown(struct kmem_cache *c)$/;"	f
__kmem_cache_shutdown	./slub.c	/^int __kmem_cache_shutdown(struct kmem_cache *s)$/;"	f
__kmemleak_do_cleanup	./kmemleak.c	/^static void __kmemleak_do_cleanup(void)$/;"	f	file:
__krealloc	./util.c	/^EXPORT_SYMBOL(__krealloc);$/;"	v
__krealloc	./util.c	/^void *__krealloc(const void *p, size_t new_size, gfp_t flags)$/;"	f
__ksm_enter	./ksm.c	/^int __ksm_enter(struct mm_struct *mm)$/;"	f
__ksm_exit	./ksm.c	/^void __ksm_exit(struct mm_struct *mm)$/;"	f
__late_clear_fixmap	./early_ioremap.c	/^static inline void __init __late_clear_fixmap(enum fixed_addresses idx)$/;"	f	file:
__late_set_fixmap	./early_ioremap.c	/^static inline void __init __late_set_fixmap(enum fixed_addresses idx,$/;"	f	file:
__lock_page	./filemap.c	/^EXPORT_SYMBOL(__lock_page);$/;"	v
__lock_page	./filemap.c	/^void __lock_page(struct page *page)$/;"	f
__lock_page_killable	./filemap.c	/^EXPORT_SYMBOL_GPL(__lock_page_killable);$/;"	v
__lock_page_killable	./filemap.c	/^int __lock_page_killable(struct page *page)$/;"	f
__lock_page_or_retry	./filemap.c	/^int __lock_page_or_retry(struct page *page, struct mm_struct *mm,$/;"	f
__lru_cache_activate_page	./swap.c	/^static void __lru_cache_activate_page(struct page *page)$/;"	f	file:
__lru_cache_add	./swap.c	/^EXPORT_SYMBOL(__lru_cache_add);$/;"	v
__lru_cache_add	./swap.c	/^void __lru_cache_add(struct page *page)$/;"	f
__mem_cgroup_begin_update_page_stat	./memcontrol.c	/^void __mem_cgroup_begin_update_page_stat(struct page *page,$/;"	f
__mem_cgroup_cancel_charge	./memcontrol.c	/^static void __mem_cgroup_cancel_charge(struct mem_cgroup *memcg,$/;"	f	file:
__mem_cgroup_cancel_local_charge	./memcontrol.c	/^static void __mem_cgroup_cancel_local_charge(struct mem_cgroup *memcg,$/;"	f	file:
__mem_cgroup_clear_mc	./memcontrol.c	/^static void __mem_cgroup_clear_mc(void)$/;"	f	file:
__mem_cgroup_commit_charge	./memcontrol.c	/^static void __mem_cgroup_commit_charge(struct mem_cgroup *memcg,$/;"	f	file:
__mem_cgroup_commit_charge_swapin	./memcontrol.c	/^__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *memcg,$/;"	f	file:
__mem_cgroup_count_vm_event	./memcontrol.c	/^EXPORT_SYMBOL(__mem_cgroup_count_vm_event);$/;"	v
__mem_cgroup_count_vm_event	./memcontrol.c	/^void __mem_cgroup_count_vm_event(struct mm_struct *mm, enum vm_event_item idx)$/;"	f
__mem_cgroup_end_update_page_stat	./memcontrol.c	/^void __mem_cgroup_end_update_page_stat(struct page *page, unsigned long *flags)$/;"	f
__mem_cgroup_free	./memcontrol.c	/^static void __mem_cgroup_free(struct mem_cgroup *memcg)$/;"	f	file:
__mem_cgroup_insert_exceeded	./memcontrol.c	/^__mem_cgroup_insert_exceeded(struct mem_cgroup *memcg,$/;"	f	file:
__mem_cgroup_iter_next	./memcontrol.c	/^static struct mem_cgroup *__mem_cgroup_iter_next(struct mem_cgroup *root,$/;"	f	file:
__mem_cgroup_largest_soft_limit_node	./memcontrol.c	/^__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)$/;"	f	file:
__mem_cgroup_remove_exceeded	./memcontrol.c	/^__mem_cgroup_remove_exceeded(struct mem_cgroup *memcg,$/;"	f	file:
__mem_cgroup_same_or_subtree	./memcontrol.c	/^bool __mem_cgroup_same_or_subtree(const struct mem_cgroup *root_memcg,$/;"	f
__mem_cgroup_threshold	./memcontrol.c	/^static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)$/;"	f	file:
__mem_cgroup_try_charge_swapin	./memcontrol.c	/^static int __mem_cgroup_try_charge_swapin(struct mm_struct *mm,$/;"	f	file:
__mem_cgroup_uncharge_common	./memcontrol.c	/^__mem_cgroup_uncharge_common(struct page *page, enum charge_type ctype,$/;"	f	file:
__mem_cgroup_usage_register_event	./memcontrol.c	/^static int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,$/;"	f	file:
__mem_cgroup_usage_unregister_event	./memcontrol.c	/^static void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,$/;"	f	file:
__memblock_alloc_base	./memblock.c	/^phys_addr_t __init __memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)$/;"	f
__memblock_dump_all	./memblock.c	/^void __init_memblock __memblock_dump_all(void)$/;"	f
__memblock_find_range_bottom_up	./memblock.c	/^__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,$/;"	f	file:
__memblock_find_range_top_down	./memblock.c	/^__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,$/;"	f	file:
__memblock_free_early	./memblock.c	/^void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)$/;"	f
__memblock_free_late	./memblock.c	/^void __init __memblock_free_late(phys_addr_t base, phys_addr_t size)$/;"	f
__memblock_remove	./memblock.c	/^static int __init_memblock __memblock_remove(struct memblock_type *type,$/;"	f	file:
__memcg_activate_kmem	./memcontrol.c	/^static int __memcg_activate_kmem(struct mem_cgroup *memcg,$/;"	f	file:
__memcg_create_cache_enqueue	./memcontrol.c	/^static void __memcg_create_cache_enqueue(struct mem_cgroup *memcg,$/;"	f	file:
__memcg_kmem_commit_charge	./memcontrol.c	/^void __memcg_kmem_commit_charge(struct page *page, struct mem_cgroup *memcg,$/;"	f
__memcg_kmem_get_cache	./memcontrol.c	/^EXPORT_SYMBOL(__memcg_kmem_get_cache);$/;"	v
__memcg_kmem_get_cache	./memcontrol.c	/^struct kmem_cache *__memcg_kmem_get_cache(struct kmem_cache *cachep,$/;"	f
__memcg_kmem_newpage_charge	./memcontrol.c	/^__memcg_kmem_newpage_charge(gfp_t gfp, struct mem_cgroup **_memcg, int order)$/;"	f
__memcg_kmem_uncharge_pages	./memcontrol.c	/^void __memcg_kmem_uncharge_pages(struct page *page, int order)$/;"	f
__meminitdata	./mm_init.c	/^static struct notifier_block compute_batch_nb __meminitdata = {$/;"	v	typeref:struct:compute_batch_nb	file:
__migrate_balloon_page	./balloon_compaction.c	/^static inline int __migrate_balloon_page(struct address_space *mapping,$/;"	f	file:
__migration_entry_wait	./migrate.c	/^static void __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,$/;"	f	file:
__mlock_posix_error_return	./mlock.c	/^static int __mlock_posix_error_return(long retval)$/;"	f	file:
__mlock_vma_pages_range	./mlock.c	/^long __mlock_vma_pages_range(struct vm_area_struct *vma,$/;"	f
__mm_populate	./mlock.c	/^int __mm_populate(unsigned long start, unsigned long len, int ignore_errors)$/;"	f
__mmu_notifier_change_pte	./mmu_notifier.c	/^void __mmu_notifier_change_pte(struct mm_struct *mm, unsigned long address,$/;"	f
__mmu_notifier_clear_flush_young	./mmu_notifier.c	/^int __mmu_notifier_clear_flush_young(struct mm_struct *mm,$/;"	f
__mmu_notifier_invalidate_page	./mmu_notifier.c	/^void __mmu_notifier_invalidate_page(struct mm_struct *mm,$/;"	f
__mmu_notifier_invalidate_range_end	./mmu_notifier.c	/^EXPORT_SYMBOL_GPL(__mmu_notifier_invalidate_range_end);$/;"	v
__mmu_notifier_invalidate_range_end	./mmu_notifier.c	/^void __mmu_notifier_invalidate_range_end(struct mm_struct *mm,$/;"	f
__mmu_notifier_invalidate_range_start	./mmu_notifier.c	/^EXPORT_SYMBOL_GPL(__mmu_notifier_invalidate_range_start);$/;"	v
__mmu_notifier_invalidate_range_start	./mmu_notifier.c	/^void __mmu_notifier_invalidate_range_start(struct mm_struct *mm,$/;"	f
__mmu_notifier_mm_destroy	./mmu_notifier.c	/^void __mmu_notifier_mm_destroy(struct mm_struct *mm)$/;"	f
__mmu_notifier_register	./mmu_notifier.c	/^EXPORT_SYMBOL_GPL(__mmu_notifier_register);$/;"	v
__mmu_notifier_register	./mmu_notifier.c	/^int __mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)$/;"	f
__mmu_notifier_release	./mmu_notifier.c	/^void __mmu_notifier_release(struct mm_struct *mm)$/;"	f
__mmu_notifier_test_young	./mmu_notifier.c	/^int __mmu_notifier_test_young(struct mm_struct *mm,$/;"	f
__mod_zone_page_state	./vmstat.c	/^EXPORT_SYMBOL(__mod_zone_page_state);$/;"	v
__mod_zone_page_state	./vmstat.c	/^void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,$/;"	f
__mpol_dup	./mempolicy.c	/^struct mempolicy *__mpol_dup(struct mempolicy *old)$/;"	f
__mpol_equal	./mempolicy.c	/^bool __mpol_equal(struct mempolicy *a, struct mempolicy *b)$/;"	f
__mpol_put	./mempolicy.c	/^void __mpol_put(struct mempolicy *p)$/;"	f
__munlock_isolate_lru_page	./mlock.c	/^static bool __munlock_isolate_lru_page(struct page *page, bool getpage)$/;"	f	file:
__munlock_isolated_page	./mlock.c	/^static void __munlock_isolated_page(struct page *page)$/;"	f	file:
__munlock_isolation_failed	./mlock.c	/^static void __munlock_isolation_failed(struct page *page)$/;"	f	file:
__munlock_pagevec	./mlock.c	/^static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)$/;"	f	file:
__munlock_pagevec_fill	./mlock.c	/^static unsigned long __munlock_pagevec_fill(struct pagevec *pvec,$/;"	f	file:
__next_free_mem_range	./memblock.c	/^void __init_memblock __next_free_mem_range(u64 *idx, int nid,$/;"	f
__next_free_mem_range_rev	./memblock.c	/^void __init_memblock __next_free_mem_range_rev(u64 *idx, int nid,$/;"	f
__next_mem_pfn_range	./memblock.c	/^void __init_memblock __next_mem_pfn_range(int *idx, int nid,$/;"	f
__offline_isolated_pages	./page_alloc.c	/^__offline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)$/;"	f
__offline_pages	./memory_hotplug.c	/^static int __ref __offline_pages(unsigned long start_pfn,$/;"	f	file:
__online_page_free	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(__online_page_free);$/;"	v
__online_page_free	./memory_hotplug.c	/^void __online_page_free(struct page *page)$/;"	f
__online_page_increment_counters	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(__online_page_increment_counters);$/;"	v
__online_page_increment_counters	./memory_hotplug.c	/^void __online_page_increment_counters(struct page *page)$/;"	f
__online_page_set_limits	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(__online_page_set_limits);$/;"	v
__online_page_set_limits	./memory_hotplug.c	/^void __online_page_set_limits(struct page *page)$/;"	f
__page_cache_alloc	./filemap.c	/^EXPORT_SYMBOL(__page_cache_alloc);$/;"	v
__page_cache_alloc	./filemap.c	/^struct page *__page_cache_alloc(gfp_t gfp)$/;"	f
__page_cache_release	./swap.c	/^static void __page_cache_release(struct page *page)$/;"	f	file:
__page_check_address	./rmap.c	/^pte_t *__page_check_address(struct page *page, struct mm_struct *mm,$/;"	f
__page_check_anon_rmap	./rmap.c	/^static void __page_check_anon_rmap(struct page *page,$/;"	f	file:
__page_file_index	./swapfile.c	/^EXPORT_SYMBOL_GPL(__page_file_index);$/;"	v
__page_file_index	./swapfile.c	/^pgoff_t __page_file_index(struct page *page)$/;"	f
__page_file_mapping	./swapfile.c	/^EXPORT_SYMBOL_GPL(__page_file_mapping);$/;"	v
__page_file_mapping	./swapfile.c	/^struct address_space *__page_file_mapping(struct page *page)$/;"	f
__page_set_anon_rmap	./rmap.c	/^static void __page_set_anon_rmap(struct page *page,$/;"	f	file:
__pagevec_lru_add	./swap.c	/^EXPORT_SYMBOL(__pagevec_lru_add);$/;"	v
__pagevec_lru_add	./swap.c	/^void __pagevec_lru_add(struct pagevec *pvec)$/;"	f
__pagevec_lru_add_fn	./swap.c	/^static void __pagevec_lru_add_fn(struct page *page, struct lruvec *lruvec,$/;"	f	file:
__pagevec_release	./swap.c	/^EXPORT_SYMBOL(__pagevec_release);$/;"	v
__pagevec_release	./swap.c	/^void __pagevec_release(struct pagevec *pvec)$/;"	f
__paginginit	./internal.h	293;"	d
__paginginit	./internal.h	295;"	d
__paint_it	./kmemleak.c	/^static void __paint_it(struct kmemleak_object *object, int color)$/;"	f	file:
__parse_numa_zonelist_order	./page_alloc.c	/^static int __parse_numa_zonelist_order(char *s)$/;"	f	file:
__pcpu_map_pages	./percpu-vm.c	/^static int __pcpu_map_pages(unsigned long addr, struct page **pages,$/;"	f	file:
__pcpu_ptr_to_addr	./percpu.c	89;"	d	file:
__pcpu_ptr_to_addr	./percpu.c	97;"	d	file:
__pcpu_size_to_slot	./percpu.c	/^static int __pcpu_size_to_slot(int size)$/;"	f	file:
__pcpu_unmap_pages	./percpu-vm.c	/^static void __pcpu_unmap_pages(unsigned long addr, int nr_pages)$/;"	f	file:
__per_cpu_offset	./percpu.c	/^EXPORT_SYMBOL(__per_cpu_offset);$/;"	v
__perform_reclaim	./page_alloc.c	/^__perform_reclaim(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist,$/;"	f	file:
__pmd_alloc	./memory.c	/^int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)$/;"	f
__pmd_trans_huge_lock	./huge_memory.c	/^int __pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma,$/;"	f
__probe_kernel_read	./maccess.c	/^long __probe_kernel_read(void *dst, const void *src, size_t size)$/;"	f
__probe_kernel_write	./maccess.c	/^long __probe_kernel_write(void *dst, const void *src, size_t size)$/;"	f
__pte_alloc	./memory.c	/^int __pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
__pte_alloc_kernel	./memory.c	/^int __pte_alloc_kernel(pmd_t *pmd, unsigned long address)$/;"	f
__pud_alloc	./memory.c	/^int __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)$/;"	f
__purge_vmap_area_lazy	./vmalloc.c	/^static void __purge_vmap_area_lazy(unsigned long *start, unsigned long *end,$/;"	f	file:
__put_anon_vma	./rmap.c	/^void __put_anon_vma(struct anon_vma *anon_vma)$/;"	f
__put_compound_page	./swap.c	/^static void __put_compound_page(struct page *page)$/;"	f	file:
__put_single_page	./swap.c	/^static void __put_single_page(struct page *page)$/;"	f	file:
__putback_balloon_page	./balloon_compaction.c	/^static inline void __putback_balloon_page(struct page *page)$/;"	f	file:
__putback_lru_fast	./mlock.c	/^static void __putback_lru_fast(struct pagevec *pvec, int pgrescued)$/;"	f	file:
__putback_lru_fast_prepare	./mlock.c	/^static bool __putback_lru_fast_prepare(struct page *page, struct pagevec *pvec,$/;"	f	file:
__read_cache_page	./filemap.c	/^static struct page *__read_cache_page(struct address_space *mapping,$/;"	f	file:
__read_mostly	./cleancache.c	/^static struct cleancache_ops *cleancache_ops __read_mostly;$/;"	v	typeref:struct:cleancache_ops	file:
__read_mostly	./frontswap.c	/^static bool frontswap_tmem_exclusive_gets_enabled __read_mostly;$/;"	v	file:
__read_mostly	./frontswap.c	/^static bool frontswap_writethrough_enabled __read_mostly;$/;"	v	file:
__read_mostly	./frontswap.c	/^static struct frontswap_ops *frontswap_ops __read_mostly;$/;"	v	typeref:struct:frontswap_ops	file:
__read_mostly	./highmem.c	/^unsigned long totalhigh_pages __read_mostly;$/;"	v
__read_mostly	./huge_memory.c	/^static struct kmem_cache *mm_slot_cache __read_mostly;$/;"	v	typeref:struct:mm_slot_cache	file:
__read_mostly	./huge_memory.c	/^static struct page *huge_zero_page __read_mostly;$/;"	v	typeref:struct:huge_zero_page	file:
__read_mostly	./huge_memory.c	/^static struct task_struct *khugepaged_thread __read_mostly;$/;"	v	typeref:struct:khugepaged_thread	file:
__read_mostly	./huge_memory.c	/^static unsigned int khugepaged_alloc_sleep_millisecs __read_mostly = 60000;$/;"	v	file:
__read_mostly	./huge_memory.c	/^static unsigned int khugepaged_max_ptes_none __read_mostly = HPAGE_PMD_NR-1;$/;"	v	file:
__read_mostly	./huge_memory.c	/^static unsigned int khugepaged_pages_to_scan __read_mostly = HPAGE_PMD_NR*8;$/;"	v	file:
__read_mostly	./huge_memory.c	/^static unsigned int khugepaged_scan_sleep_millisecs __read_mostly = 10000;$/;"	v	file:
__read_mostly	./huge_memory.c	/^unsigned long transparent_hugepage_flags __read_mostly =$/;"	v
__read_mostly	./hugetlb.c	/^int hugetlb_max_hstate __read_mostly;$/;"	v
__read_mostly	./hugetlb_cgroup.c	/^static struct hugetlb_cgroup *root_h_cgroup __read_mostly;$/;"	v	typeref:struct:root_h_cgroup	file:
__read_mostly	./memcontrol.c	/^atomic_t memcg_moving __read_mostly;$/;"	v
__read_mostly	./memcontrol.c	/^int do_swap_account __read_mostly;$/;"	v
__read_mostly	./memcontrol.c	/^static struct mem_cgroup *root_mem_cgroup __read_mostly;$/;"	v	typeref:struct:root_mem_cgroup	file:
__read_mostly	./memcontrol.c	/^static struct mem_cgroup_tree soft_limit_tree __read_mostly;$/;"	v	typeref:struct:soft_limit_tree	file:
__read_mostly	./memcontrol.c	/^struct cgroup_subsys memory_cgrp_subsys __read_mostly;$/;"	v	typeref:struct:memory_cgrp_subsys
__read_mostly	./memory-failure.c	/^atomic_long_t num_poisoned_pages __read_mostly = ATOMIC_LONG_INIT(0);$/;"	v
__read_mostly	./memory-failure.c	/^int sysctl_memory_failure_early_kill __read_mostly = 0;$/;"	v
__read_mostly	./memory-failure.c	/^int sysctl_memory_failure_recovery __read_mostly = 1;$/;"	v
__read_mostly	./memory.c	/^int randomize_va_space __read_mostly =$/;"	v
__read_mostly	./memory.c	/^unsigned long highest_memmap_pfn __read_mostly;$/;"	v
__read_mostly	./memory.c	/^unsigned long zero_pfn __read_mostly;$/;"	v
__read_mostly	./migrate.c	/^static unsigned int migrate_interval_millisecs __read_mostly = 100;$/;"	v	file:
__read_mostly	./migrate.c	/^static unsigned int pteupdate_interval_millisecs __read_mostly = 1000;$/;"	v	file:
__read_mostly	./migrate.c	/^static unsigned int ratelimit_pages __read_mostly = 128 << (20 - PAGE_SHIFT);$/;"	v	file:
__read_mostly	./mmap.c	/^int sysctl_max_map_count __read_mostly = DEFAULT_MAX_MAP_COUNT;$/;"	v
__read_mostly	./mmap.c	/^int sysctl_overcommit_memory __read_mostly = OVERCOMMIT_GUESS;  \/* heuristic overcommit *\/$/;"	v
__read_mostly	./mmap.c	/^int sysctl_overcommit_ratio __read_mostly = 50;	\/* default is 50% *\/$/;"	v
__read_mostly	./mmap.c	/^unsigned long sysctl_admin_reserve_kbytes __read_mostly = 1UL << 13; \/* 8MB *\/$/;"	v
__read_mostly	./mmap.c	/^unsigned long sysctl_overcommit_kbytes __read_mostly;$/;"	v
__read_mostly	./mmap.c	/^unsigned long sysctl_user_reserve_kbytes __read_mostly = 1UL << 17; \/* 128MB *\/$/;"	v
__read_mostly	./nommu.c	/^unsigned long sysctl_admin_reserve_kbytes __read_mostly = 1UL << 13; \/* 8MB *\/$/;"	v
__read_mostly	./nommu.c	/^unsigned long sysctl_overcommit_kbytes __read_mostly;$/;"	v
__read_mostly	./nommu.c	/^unsigned long sysctl_user_reserve_kbytes __read_mostly = 1UL << 17; \/* 128MB *\/$/;"	v
__read_mostly	./page_alloc.c	/^bool oom_killer_disabled __read_mostly;$/;"	v
__read_mostly	./page_alloc.c	/^gfp_t gfp_allowed_mask __read_mostly = GFP_BOOT_MASK;$/;"	v
__read_mostly	./page_alloc.c	/^int nr_node_ids __read_mostly = MAX_NUMNODES;$/;"	v
__read_mostly	./page_alloc.c	/^int nr_online_nodes __read_mostly = 1;$/;"	v
__read_mostly	./page_alloc.c	/^int page_group_by_mobility_disabled __read_mostly;$/;"	v
__read_mostly	./page_alloc.c	/^int pageblock_order __read_mostly;$/;"	v
__read_mostly	./page_alloc.c	/^nodemask_t node_states[NR_NODE_STATES] __read_mostly = {$/;"	v
__read_mostly	./page_alloc.c	/^unsigned long dirty_balance_reserve __read_mostly;$/;"	v
__read_mostly	./page_alloc.c	/^unsigned long totalram_pages __read_mostly;$/;"	v
__read_mostly	./page_alloc.c	/^unsigned long totalreserve_pages __read_mostly;$/;"	v
__read_mostly	./percpu.c	/^const unsigned long *pcpu_unit_offsets __read_mostly;	\/* cpu -> unit offset *\/$/;"	v
__read_mostly	./percpu.c	/^static const int *pcpu_unit_map __read_mostly;		\/* cpu -> unit *\/$/;"	v	file:
__read_mostly	./percpu.c	/^static const size_t *pcpu_group_sizes __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static const unsigned long *pcpu_group_offsets __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static int pcpu_atom_size __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static int pcpu_nr_groups __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static int pcpu_nr_slots __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static int pcpu_nr_units __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static int pcpu_unit_pages __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static int pcpu_unit_size __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static size_t pcpu_chunk_struct_size __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static struct list_head *pcpu_slot __read_mostly; \/* chunk list slots *\/$/;"	v	typeref:struct:pcpu_slot	file:
__read_mostly	./percpu.c	/^static unsigned int pcpu_high_unit_cpu __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^static unsigned int pcpu_low_unit_cpu __read_mostly;$/;"	v	file:
__read_mostly	./percpu.c	/^unsigned long __per_cpu_offset[NR_CPUS] __read_mostly;$/;"	v
__read_mostly	./percpu.c	/^void *pcpu_base_addr __read_mostly;$/;"	v
__read_mostly	./shmem.c	/^static struct backing_dev_info shmem_backing_dev_info  __read_mostly = {$/;"	v	typeref:struct:shmem_backing_dev_info	file:
__read_mostly	./slab.c	/^static bool pfmemalloc_active __read_mostly;$/;"	v	file:
__read_mostly	./slab.c	/^static int use_alien_caches __read_mostly = 1;$/;"	v	file:
__read_mostly	./vmalloc.c	/^static bool vmap_initialized __read_mostly = false;$/;"	v	file:
__read_mostly	./vmstat.c	/^int sysctl_stat_interval __read_mostly = HZ;$/;"	v
__read_mostly	./zswap.c	/^static bool zswap_enabled __read_mostly;$/;"	v	file:
__releases	./memory.c	/^	__releases(ptl)$/;"	f
__releases	./nommu.c	/^	__releases(nommu_region_sem)$/;"	f
__remove_mapping	./vmscan.c	/^static int __remove_mapping(struct address_space *mapping, struct page *page,$/;"	f	file:
__remove_pages	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(__remove_pages);$/;"	v
__remove_pages	./memory_hotplug.c	/^int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,$/;"	f
__remove_partial	./slub.c	/^__remove_partial(struct kmem_cache_node *n, struct page *page)$/;"	f	file:
__remove_section	./memory_hotplug.c	/^static int __remove_section(struct zone *zone, struct mem_section *ms)$/;"	f	file:
__remove_shared_vm_struct	./mmap.c	/^static void __remove_shared_vm_struct(struct vm_area_struct *vma,$/;"	f	file:
__remove_zone	./memory_hotplug.c	/^static void __remove_zone(struct zone *zone, unsigned long start_pfn)$/;"	f	file:
__reserve	./bootmem.c	/^static int __init __reserve(bootmem_data_t *bdata, unsigned long sidx,$/;"	f	file:
__reset_isolation_suitable	./compaction.c	/^static void __reset_isolation_suitable(struct zone *zone)$/;"	f	file:
__rmqueue	./page_alloc.c	/^static struct page *__rmqueue(struct zone *zone, unsigned int order,$/;"	f	file:
__rmqueue_fallback	./page_alloc.c	/^__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)$/;"	f	file:
__rmqueue_smallest	./page_alloc.c	/^struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,$/;"	f	file:
__save_stack_trace	./kmemleak.c	/^static int __save_stack_trace(unsigned long *trace)$/;"	f	file:
__section_nr	./sparse.c	/^int __section_nr(struct mem_section* ms)$/;"	f
__set_page_dirty_no_writeback	./page-writeback.c	/^int __set_page_dirty_no_writeback(struct page *page)$/;"	f
__set_page_dirty_nobuffers	./page-writeback.c	/^EXPORT_SYMBOL(__set_page_dirty_nobuffers);$/;"	v
__set_page_dirty_nobuffers	./page-writeback.c	/^int __set_page_dirty_nobuffers(struct page *page)$/;"	f
__setup_per_zone_wmarks	./page_alloc.c	/^static void __setup_per_zone_wmarks(void)$/;"	f	file:
__shmem_file_setup	./shmem.c	/^static struct file *__shmem_file_setup(const char *name, loff_t size,$/;"	f	file:
__slab_alloc	./slub.c	/^static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,$/;"	f	file:
__slab_error	./slab.c	/^static void __slab_error(const char *function, struct kmem_cache *cachep,$/;"	f	file:
__slab_free	./slub.c	/^static void __slab_free(struct kmem_cache *s, struct page *page,$/;"	f	file:
__soft_offline_page	./memory-failure.c	/^static int __soft_offline_page(struct page *page, int flags)$/;"	f	file:
__split_huge_page	./huge_memory.c	/^static void __split_huge_page(struct page *page,$/;"	f	file:
__split_huge_page_map	./huge_memory.c	/^static int __split_huge_page_map(struct page *page,$/;"	f	file:
__split_huge_page_pmd	./huge_memory.c	/^void __split_huge_page_pmd(struct vm_area_struct *vma, unsigned long address,$/;"	f
__split_huge_page_refcount	./huge_memory.c	/^static void __split_huge_page_refcount(struct page *page,$/;"	f	file:
__split_huge_page_splitting	./huge_memory.c	/^static int __split_huge_page_splitting(struct page *page,$/;"	f	file:
__split_huge_zero_page_pmd	./huge_memory.c	/^static void __split_huge_zero_page_pmd(struct vm_area_struct *vma,$/;"	f	file:
__split_vma	./mmap.c	/^static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma,$/;"	f	file:
__swap_duplicate	./swapfile.c	/^static int __swap_duplicate(swp_entry_t entry, unsigned char usage)$/;"	f	file:
__swap_writepage	./page_io.c	/^int __swap_writepage(struct page *page, struct writeback_control *wbc,$/;"	f
__test_page_isolated_in_pageblock	./page_isolation.c	/^__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,$/;"	f	file:
__tlb_remove_page	./memory.c	/^int __tlb_remove_page(struct mmu_gather *tlb, struct page *page)$/;"	f
__try_to_reclaim_swap	./swapfile.c	/^__try_to_reclaim_swap(struct swap_info_struct *si, unsigned long offset)$/;"	f	file:
__unmap_and_move	./migrate.c	/^static int __unmap_and_move(struct page *page, struct page *newpage,$/;"	f	file:
__unmap_hugepage_range	./hugetlb.c	/^void __unmap_hugepage_range(struct mmu_gather *tlb, struct vm_area_struct *vma,$/;"	f
__unmap_hugepage_range_final	./hugetlb.c	/^void __unmap_hugepage_range_final(struct mmu_gather *tlb,$/;"	f
__vm_enough_memory	./mmap.c	/^int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)$/;"	f
__vm_enough_memory	./nommu.c	/^int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)$/;"	f
__vma_address	./rmap.c	/^__vma_address(struct page *page, struct vm_area_struct *vma)$/;"	f	file:
__vma_adjust_trans_huge	./huge_memory.c	/^void __vma_adjust_trans_huge(struct vm_area_struct *vma,$/;"	f
__vma_link	./mmap.c	/^__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
__vma_link_file	./mmap.c	/^static void __vma_link_file(struct vm_area_struct *vma)$/;"	f	file:
__vma_link_list	./util.c	/^void __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
__vma_link_rb	./mmap.c	/^void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
__vma_unlink	./mmap.c	/^__vma_unlink(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
__vmalloc	./nommu.c	/^EXPORT_SYMBOL(__vmalloc);$/;"	v
__vmalloc	./nommu.c	/^void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)$/;"	f
__vmalloc	./vmalloc.c	/^EXPORT_SYMBOL(__vmalloc);$/;"	v
__vmalloc	./vmalloc.c	/^void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)$/;"	f
__vmalloc_area_node	./vmalloc.c	/^static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,$/;"	f	file:
__vmalloc_node	./vmalloc.c	/^static void *__vmalloc_node(unsigned long size, unsigned long align,$/;"	f	file:
__vmalloc_node_flags	./vmalloc.c	/^static inline void *__vmalloc_node_flags(unsigned long size,$/;"	f	file:
__vmalloc_node_range	./vmalloc.c	/^void *__vmalloc_node_range(unsigned long size, unsigned long align,$/;"	f
__vunmap	./vmalloc.c	/^static void __vunmap(const void *addr, int deallocate_pages)$/;"	f	file:
__writepage	./page-writeback.c	/^static int __writepage(struct page *page, struct writeback_control *wbc,$/;"	f	file:
__xip_file_write	./filemap_xip.c	/^__xip_file_write(struct file *filp, const char __user *buf,$/;"	f	file:
__xip_sparse_page	./filemap_xip.c	/^static struct page *__xip_sparse_page;$/;"	v	typeref:struct:page	file:
__xip_unmap	./filemap_xip.c	/^__xip_unmap (struct address_space * mapping,$/;"	f	file:
__zone_reclaim	./vmscan.c	/^static int __zone_reclaim(struct zone *zone, gfp_t gfp_mask, unsigned int order)$/;"	f	file:
__zone_watermark_ok	./page_alloc.c	/^static bool __zone_watermark_ok(struct zone *z, int order, unsigned long mark,$/;"	f	file:
__zs_cpu_down	./zsmalloc.c	/^static inline void __zs_cpu_down(struct mapping_area *area)$/;"	f	file:
__zs_cpu_up	./zsmalloc.c	/^static inline int __zs_cpu_up(struct mapping_area *area)$/;"	f	file:
__zs_map_object	./zsmalloc.c	/^static inline void *__zs_map_object(struct mapping_area *area,$/;"	f	file:
__zs_map_object	./zsmalloc.c	/^static void *__zs_map_object(struct mapping_area *area,$/;"	f	file:
__zs_unmap_object	./zsmalloc.c	/^static inline void __zs_unmap_object(struct mapping_area *area,$/;"	f	file:
__zs_unmap_object	./zsmalloc.c	/^static void __zs_unmap_object(struct mapping_area *area,$/;"	f	file:
__zswap_cpu_notifier	./zswap.c	/^static int __zswap_cpu_notifier(unsigned long action, unsigned long cpu)$/;"	f	file:
_debug_guardpage_minorder	./page_alloc.c	/^unsigned int _debug_guardpage_minorder;$/;"	v
_enable_swap_info	./swapfile.c	/^static void _enable_swap_info(struct swap_info_struct *p, int prio,$/;"	f	file:
_install_special_mapping	./mmap.c	/^struct vm_area_struct *_install_special_mapping(struct mm_struct *mm,$/;"	f
_numa_mem_	./page_alloc.c	/^EXPORT_PER_CPU_SYMBOL(_numa_mem_);$/;"	v
absent_pages_in_range	./page_alloc.c	/^unsigned long __init absent_pages_in_range(unsigned long start_pfn,$/;"	f
ac_get_obj	./slab.c	/^static inline void *ac_get_obj(struct kmem_cache *cachep,$/;"	f	file:
ac_put_obj	./slab.c	/^static inline void ac_put_obj(struct kmem_cache *cachep, struct array_cache *ac,$/;"	f	file:
access_process_vm	./memory.c	/^int access_process_vm(struct task_struct *tsk, unsigned long addr,$/;"	f
access_process_vm	./nommu.c	/^int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write)$/;"	f
access_remote_vm	./memory.c	/^int access_remote_vm(struct mm_struct *mm, unsigned long addr,$/;"	f
access_remote_vm	./nommu.c	/^int access_remote_vm(struct mm_struct *mm, unsigned long addr,$/;"	f
account_page_dirtied	./page-writeback.c	/^EXPORT_SYMBOL(account_page_dirtied);$/;"	v
account_page_dirtied	./page-writeback.c	/^void account_page_dirtied(struct page *page, struct address_space *mapping)$/;"	f
account_page_redirty	./page-writeback.c	/^EXPORT_SYMBOL(account_page_redirty);$/;"	v
account_page_redirty	./page-writeback.c	/^void account_page_redirty(struct page *page)$/;"	f
account_page_writeback	./page-writeback.c	/^EXPORT_SYMBOL(account_page_writeback);$/;"	v
account_page_writeback	./page-writeback.c	/^void account_page_writeback(struct page *page)$/;"	f
accountable_mapping	./mmap.c	/^static inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)$/;"	f	file:
acct_isolated	./compaction.c	/^static void acct_isolated(struct zone *zone, bool locked, struct compact_control *cc)$/;"	f	file:
acct_stack_growth	./mmap.c	/^static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)$/;"	f	file:
acquire_slab	./slub.c	/^static inline void *acquire_slab(struct kmem_cache *s,$/;"	f	file:
action	./memory-failure.c	/^	int (*action)(struct page *p, unsigned long pfn);$/;"	m	struct:page_state	file:
action_name	./memory-failure.c	/^static const char *action_name[] = {$/;"	v	file:
action_result	./memory-failure.c	/^static void action_result(unsigned long pfn, char *msg, int result)$/;"	f	file:
activate_page	./swap.c	/^void activate_page(struct page *page)$/;"	f
activate_page_drain	./swap.c	/^static inline void activate_page_drain(int cpu)$/;"	f	file:
activate_page_drain	./swap.c	/^static void activate_page_drain(int cpu)$/;"	f	file:
active_objs	./slab.h	/^	unsigned long active_objs;$/;"	m	struct:slabinfo
active_slabs	./slab.h	/^	unsigned long active_slabs;$/;"	m	struct:slabinfo
add_caller	./slab.c	/^static inline int add_caller(unsigned long *n, unsigned long v)$/;"	f	file:
add_element	./mempool.c	/^static void add_element(mempool_t *pool, void *element)$/;"	f	file:
add_full	./slub.c	/^static inline void add_full(struct kmem_cache *s, struct kmem_cache_node *n,$/;"	f	file:
add_full	./slub.c	/^static void add_full(struct kmem_cache *s,$/;"	f	file:
add_location	./slub.c	/^static int add_location(struct loc_track *t, struct kmem_cache *s,$/;"	f	file:
add_memory	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(add_memory);$/;"	v
add_memory	./memory_hotplug.c	/^int __ref add_memory(int nid, u64 start, u64 size)$/;"	f
add_mm_counter_fast	./memory.c	/^static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)$/;"	f	file:
add_mm_rss_vec	./memory.c	/^static inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)$/;"	f	file:
add_nommu_region	./nommu.c	/^static void add_nommu_region(struct vm_region *region)$/;"	f	file:
add_page_to_unevictable_list	./swap.c	/^void add_page_to_unevictable_list(struct page *page)$/;"	f
add_page_wait_queue	./filemap.c	/^EXPORT_SYMBOL_GPL(add_page_wait_queue);$/;"	v
add_page_wait_queue	./filemap.c	/^void add_page_wait_queue(struct page *page, wait_queue_t *waiter)$/;"	f
add_partial	./slub.c	/^static inline void add_partial(struct kmem_cache_node *n,$/;"	f	file:
add_scan_area	./kmemleak.c	/^static void add_scan_area(unsigned long ptr, size_t size, gfp_t gfp)$/;"	f	file:
add_swap_count_continuation	./swapfile.c	/^int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)$/;"	f
add_swap_extent	./swapfile.c	/^add_swap_extent(struct swap_info_struct *sis, unsigned long start_page,$/;"	f
add_to_kill	./memory-failure.c	/^static void add_to_kill(struct task_struct *tsk, struct page *p,$/;"	f	file:
add_to_page_cache_locked	./filemap.c	/^EXPORT_SYMBOL(add_to_page_cache_locked);$/;"	v
add_to_page_cache_locked	./filemap.c	/^int add_to_page_cache_locked(struct page *page, struct address_space *mapping,$/;"	f
add_to_page_cache_lru	./filemap.c	/^EXPORT_SYMBOL_GPL(add_to_page_cache_lru);$/;"	v
add_to_page_cache_lru	./filemap.c	/^int add_to_page_cache_lru(struct page *page, struct address_space *mapping,$/;"	f
add_to_swap	./swap_state.c	/^int add_to_swap(struct page *page, struct list_head *list)$/;"	f
add_to_swap_cache	./swap_state.c	/^int add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp_mask)$/;"	f
add_total	./swap_state.c	/^	unsigned long add_total;$/;"	m	struct:__anon1	file:
add_vma_to_mm	./nommu.c	/^static void add_vma_to_mm(struct mm_struct *mm, struct vm_area_struct *vma)$/;"	f	file:
addr	./memory-failure.c	/^	unsigned long addr;$/;"	m	struct:to_kill	file:
addr	./migrate.c	/^	unsigned long addr;$/;"	m	struct:page_to_node	file:
addr	./mmap.c	/^	unsigned long addr;$/;"	m	struct:mmap_arg_struct	file:
addr	./nommu.c	/^	unsigned long addr;$/;"	m	struct:mmap_arg_struct	file:
addr	./pos.c	/^	unsigned long addr;$/;"	m	struct:seg_inform	file:
addr	./slub.c	/^	unsigned long addr;	\/* Called from address *\/$/;"	m	struct:track	file:
addr	./slub.c	/^	unsigned long addr;$/;"	m	struct:location	file:
addr_to_vb_idx	./vmalloc.c	/^static unsigned long addr_to_vb_idx(unsigned long addr)$/;"	f	file:
addr_valid	./memory-failure.c	/^	char addr_valid;$/;"	m	struct:to_kill	file:
address	./huge_memory.c	/^	unsigned long address;$/;"	m	struct:khugepaged_scan	file:
address	./ksm.c	/^	unsigned long address;		\/* + low bits used for flags below *\/$/;"	m	struct:rmap_item	file:
address	./ksm.c	/^	unsigned long address;$/;"	m	struct:ksm_scan	file:
addrs	./slub.c	/^	unsigned long addrs[TRACK_ADDRS_COUNT];	\/* Called from address *\/$/;"	m	struct:track	file:
adj_init_size	./page_alloc.c	5437;"	d	file:
adj_init_size	./page_alloc.c	5450;"	d	file:
adjust_managed_page_count	./page_alloc.c	/^EXPORT_SYMBOL(adjust_managed_page_count);$/;"	v
adjust_managed_page_count	./page_alloc.c	/^void adjust_managed_page_count(struct page *page, long count)$/;"	f
adjust_pool_surplus	./hugetlb.c	/^static int adjust_pool_surplus(struct hstate *h, nodemask_t *nodes_allowed,$/;"	f	file:
adjust_zone_range_for_zone_movable	./page_alloc.c	/^static void __meminit adjust_zone_range_for_zone_movable(int nid,$/;"	f	file:
age_active_anon	./vmscan.c	/^static void age_active_anon(struct zone *zone, struct scan_control *sc)$/;"	f	file:
alias_list	./slub.c	/^static struct saved_alias *alias_list;$/;"	v	typeref:struct:saved_alias	file:
aliases	./slub.c	/^SLAB_ATTR_RO(aliases);$/;"	v
aliases_show	./slub.c	/^static ssize_t aliases_show(struct kmem_cache *s, char *buf)$/;"	f	file:
alien	./slab.h	/^	struct array_cache **alien;	\/* on other nodes *\/$/;"	m	struct:kmem_cache_node	typeref:struct:kmem_cache_node::array_cache
align	./slub.c	/^SLAB_ATTR_RO(align);$/;"	v
align_idx	./bootmem.c	/^static unsigned long __init align_idx(struct bootmem_data *bdata,$/;"	f	file:
align_off	./bootmem.c	/^static unsigned long __init align_off(struct bootmem_data *bdata,$/;"	f	file:
align_show	./slub.c	/^static ssize_t align_show(struct kmem_cache *s, char *buf)$/;"	f	file:
aligned_vread	./vmalloc.c	/^static int aligned_vread(char *buf, char *addr, unsigned long count)$/;"	f	file:
aligned_vwrite	./vmalloc.c	/^static int aligned_vwrite(char *buf, char *addr, unsigned long count)$/;"	f	file:
all_unreclaimable	./vmscan.c	/^static bool all_unreclaimable(struct zonelist *zonelist,$/;"	f	file:
all_vm_events	./vmstat.c	/^EXPORT_SYMBOL_GPL(all_vm_events);$/;"	v
all_vm_events	./vmstat.c	/^void all_vm_events(unsigned long *ret)$/;"	f
alloc_alien_cache	./slab.c	/^static inline struct array_cache **alloc_alien_cache(int node, int limit, gfp_t gfp)$/;"	f	file:
alloc_alien_cache	./slab.c	/^static struct array_cache **alloc_alien_cache(int node, int limit, gfp_t gfp)$/;"	f	file:
alloc_arraycache	./slab.c	/^static struct array_cache *alloc_arraycache(int node, int entries,$/;"	f	file:
alloc_bootmem_bdata	./bootmem.c	/^static void * __init alloc_bootmem_bdata(struct bootmem_data *bdata,$/;"	f	file:
alloc_bootmem_core	./bootmem.c	/^static void * __init alloc_bootmem_core(unsigned long size,$/;"	f	file:
alloc_bootmem_huge_page	./hugetlb.c	/^int __weak alloc_bootmem_huge_page(struct hstate *h)$/;"	f
alloc_buddy_huge_page	./hugetlb.c	/^static struct page *alloc_buddy_huge_page(struct hstate *h, int nid)$/;"	f	file:
alloc_calls	./slub.c	/^SLAB_ATTR_RO(alloc_calls);$/;"	v
alloc_calls_show	./slub.c	/^static ssize_t alloc_calls_show(struct kmem_cache *s, char *buf)$/;"	f	file:
alloc_contig_range	./page_alloc.c	/^int alloc_contig_range(unsigned long start, unsigned long end,$/;"	f
alloc_debug_processing	./slub.c	/^static inline int alloc_debug_processing(struct kmem_cache *s,$/;"	f	file:
alloc_debug_processing	./slub.c	/^static noinline int alloc_debug_processing(struct kmem_cache *s,$/;"	f	file:
alloc_fresh_huge_page	./hugetlb.c	/^static int alloc_fresh_huge_page(struct hstate *h, nodemask_t *nodes_allowed)$/;"	f	file:
alloc_fresh_huge_page_node	./hugetlb.c	/^static struct page *alloc_fresh_huge_page_node(struct hstate *h, int nid)$/;"	f	file:
alloc_huge_page	./hugetlb.c	/^static struct page *alloc_huge_page(struct vm_area_struct *vma,$/;"	f	file:
alloc_huge_page_node	./hugetlb.c	/^struct page *alloc_huge_page_node(struct hstate *h, int nid)$/;"	f
alloc_huge_page_noerr	./hugetlb.c	/^struct page *alloc_huge_page_noerr(struct vm_area_struct *vma,$/;"	f
alloc_hugepage	./huge_memory.c	/^static inline struct page *alloc_hugepage(int defrag)$/;"	f	file:
alloc_hugepage_gfpmask	./huge_memory.c	/^static inline gfp_t alloc_hugepage_gfpmask(int defrag, gfp_t extra_gfp)$/;"	f	file:
alloc_hugepage_vma	./huge_memory.c	/^static inline struct page *alloc_hugepage_vma(int defrag,$/;"	f	file:
alloc_kmem_cache_cpus	./slub.c	/^static inline int alloc_kmem_cache_cpus(struct kmem_cache *s)$/;"	f	file:
alloc_kmem_cache_node	./slab.c	/^static int alloc_kmem_cache_node(struct kmem_cache *cachep, gfp_t gfp)$/;"	f	file:
alloc_large_system_hash	./page_alloc.c	/^void *__init alloc_large_system_hash(const char *tablename,$/;"	f
alloc_loc_track	./slub.c	/^static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)$/;"	f	file:
alloc_mem_cgroup_per_zone_info	./memcontrol.c	/^static int alloc_mem_cgroup_per_zone_info(struct mem_cgroup *memcg, int node)$/;"	f	file:
alloc_migrate_target	./page_isolation.c	/^struct page *alloc_migrate_target(struct page *page, unsigned long private,$/;"	f
alloc_misplaced_dst_page	./migrate.c	/^static struct page *alloc_misplaced_dst_page(struct page *page,$/;"	f	file:
alloc_mm_slot	./huge_memory.c	/^static inline struct mm_slot *alloc_mm_slot(void)$/;"	f	file:
alloc_mm_slot	./ksm.c	/^static inline struct mm_slot *alloc_mm_slot(void)$/;"	f	file:
alloc_new_pmd	./mremap.c	/^static pmd_t *alloc_new_pmd(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
alloc_node_mem_map	./page_alloc.c	/^static void __init_refok alloc_node_mem_map(struct pglist_data *pgdat)$/;"	f	file:
alloc_node_page_cgroup	./page_cgroup.c	/^static int __init alloc_node_page_cgroup(int nid)$/;"	f	file:
alloc_page_cgroup	./page_cgroup.c	/^static void *__meminit alloc_page_cgroup(size_t size, int nid)$/;"	f	file:
alloc_page_interleave	./mempolicy.c	/^static struct page *alloc_page_interleave(gfp_t gfp, unsigned order,$/;"	f	file:
alloc_pages_current	./mempolicy.c	/^EXPORT_SYMBOL(alloc_pages_current);$/;"	v
alloc_pages_current	./mempolicy.c	/^struct page *alloc_pages_current(gfp_t gfp, unsigned order)$/;"	f
alloc_pages_exact	./page_alloc.c	/^EXPORT_SYMBOL(alloc_pages_exact);$/;"	v
alloc_pages_exact	./page_alloc.c	/^void *alloc_pages_exact(size_t size, gfp_t gfp_mask)$/;"	f
alloc_pages_exact_nid	./page_alloc.c	/^EXPORT_SYMBOL(alloc_pages_exact_nid);$/;"	v
alloc_pages_exact_nid	./page_alloc.c	/^void *alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask)$/;"	f
alloc_pages_vma	./mempolicy.c	/^alloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,$/;"	f
alloc_rmap_item	./ksm.c	/^static inline struct rmap_item *alloc_rmap_item(void)$/;"	f	file:
alloc_slab_page	./slub.c	/^static inline struct page *alloc_slab_page(gfp_t flags, int node,$/;"	f	file:
alloc_slabmgmt	./slab.c	/^static void *alloc_slabmgmt(struct kmem_cache *cachep,$/;"	f	file:
alloc_sleep_millisecs_attr	./huge_memory.c	/^static struct kobj_attribute alloc_sleep_millisecs_attr =$/;"	v	typeref:struct:kobj_attribute	file:
alloc_sleep_millisecs_show	./huge_memory.c	/^static ssize_t alloc_sleep_millisecs_show(struct kobject *kobj,$/;"	f	file:
alloc_sleep_millisecs_store	./huge_memory.c	/^static ssize_t alloc_sleep_millisecs_store(struct kobject *kobj,$/;"	f	file:
alloc_stable_node	./ksm.c	/^static inline struct stable_node *alloc_stable_node(void)$/;"	f	file:
alloc_swap_info	./swapfile.c	/^static struct swap_info_struct *alloc_swap_info(void)$/;"	f	file:
alloc_usemap_and_memmap	./sparse.c	/^static void __init alloc_usemap_and_memmap(void (*alloc_func)$/;"	f	file:
alloc_vm_area	./nommu.c	/^EXPORT_SYMBOL_GPL(alloc_vm_area);$/;"	v
alloc_vm_area	./nommu.c	/^struct vm_struct *alloc_vm_area(size_t size, pte_t **ptes)$/;"	f
alloc_vm_area	./vmalloc.c	/^EXPORT_SYMBOL_GPL(alloc_vm_area);$/;"	v
alloc_vm_area	./vmalloc.c	/^struct vm_struct *alloc_vm_area(size_t size, pte_t **ptes)$/;"	f
alloc_vmap_area	./vmalloc.c	/^static struct vmap_area *alloc_vmap_area(unsigned long size,$/;"	f	file:
alloc_zspage	./zsmalloc.c	/^static struct page *alloc_zspage(struct size_class *class, gfp_t flags)$/;"	f	file:
allocate_slab	./slub.c	/^static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)$/;"	f	file:
allocation	./dmapool.c	/^	size_t allocation;$/;"	m	struct:dma_pool	file:
alternate_node_alloc	./slab.c	/^static inline void *alternate_node_alloc(struct kmem_cache *cachep,$/;"	f	file:
alternate_node_alloc	./slab.c	/^static void *alternate_node_alloc(struct kmem_cache *cachep, gfp_t flags)$/;"	f	file:
anon_ops	./shmem.c	/^static struct dentry_operations anon_ops = {$/;"	v	typeref:struct:dentry_operations	file:
anon_vma	./ksm.c	/^		struct anon_vma *anon_vma;	\/* when stable *\/$/;"	m	union:rmap_item::__anon7	typeref:struct:rmap_item::__anon7::anon_vma	file:
anon_vma_alloc	./rmap.c	/^static inline struct anon_vma *anon_vma_alloc(void)$/;"	f	file:
anon_vma_cachep	./rmap.c	/^static struct kmem_cache *anon_vma_cachep;$/;"	v	typeref:struct:kmem_cache	file:
anon_vma_chain_alloc	./rmap.c	/^static inline struct anon_vma_chain *anon_vma_chain_alloc(gfp_t gfp)$/;"	f	file:
anon_vma_chain_cachep	./rmap.c	/^static struct kmem_cache *anon_vma_chain_cachep;$/;"	v	typeref:struct:kmem_cache	file:
anon_vma_chain_free	./rmap.c	/^static void anon_vma_chain_free(struct anon_vma_chain *anon_vma_chain)$/;"	f	file:
anon_vma_chain_link	./rmap.c	/^static void anon_vma_chain_link(struct vm_area_struct *vma,$/;"	f	file:
anon_vma_clone	./rmap.c	/^int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)$/;"	f
anon_vma_compatible	./mmap.c	/^static int anon_vma_compatible(struct vm_area_struct *a, struct vm_area_struct *b)$/;"	f	file:
anon_vma_ctor	./rmap.c	/^static void anon_vma_ctor(void *data)$/;"	f	file:
anon_vma_fork	./rmap.c	/^int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)$/;"	f
anon_vma_free	./rmap.c	/^static inline void anon_vma_free(struct anon_vma *anon_vma)$/;"	f	file:
anon_vma_init	./rmap.c	/^void __init anon_vma_init(void)$/;"	f
anon_vma_interval_tree_insert	./interval_tree.c	/^void anon_vma_interval_tree_insert(struct anon_vma_chain *node,$/;"	f
anon_vma_interval_tree_iter_first	./interval_tree.c	/^anon_vma_interval_tree_iter_first(struct rb_root *root,$/;"	f
anon_vma_interval_tree_iter_next	./interval_tree.c	/^anon_vma_interval_tree_iter_next(struct anon_vma_chain *node,$/;"	f
anon_vma_interval_tree_post_update_vma	./mmap.c	/^anon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)$/;"	f	file:
anon_vma_interval_tree_pre_update_vma	./mmap.c	/^anon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)$/;"	f	file:
anon_vma_interval_tree_remove	./interval_tree.c	/^void anon_vma_interval_tree_remove(struct anon_vma_chain *node,$/;"	f
anon_vma_interval_tree_verify	./interval_tree.c	/^void anon_vma_interval_tree_verify(struct anon_vma_chain *node)$/;"	f
anon_vma_prepare	./rmap.c	/^int anon_vma_prepare(struct vm_area_struct *vma)$/;"	f
any_slab_objects	./slub.c	/^static int any_slab_objects(struct kmem_cache *s)$/;"	f	file:
apply_policy_zone	./mempolicy.c	/^static int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)$/;"	f	file:
apply_to_page_range	./memory.c	/^EXPORT_SYMBOL_GPL(apply_to_page_range);$/;"	v
apply_to_page_range	./memory.c	/^int apply_to_page_range(struct mm_struct *mm, unsigned long addr,$/;"	f
apply_to_pmd_range	./memory.c	/^static int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,$/;"	f	file:
apply_to_pte_range	./memory.c	/^static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,$/;"	f	file:
apply_to_pud_range	./memory.c	/^static int apply_to_pud_range(struct mm_struct *mm, pgd_t *pgd,$/;"	f	file:
arch_get_unmapped_area	./mmap.c	/^arch_get_unmapped_area(struct file *filp, unsigned long addr,$/;"	f
arch_get_unmapped_area	./nommu.c	/^unsigned long arch_get_unmapped_area(struct file *file, unsigned long addr,$/;"	f
arch_get_unmapped_area_topdown	./mmap.c	/^arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,$/;"	f
arch_mmap_check	./mmap.c	49;"	d	file:
arch_pick_mmap_layout	./util.c	/^void arch_pick_mmap_layout(struct mm_struct *mm)$/;"	f
arch_rebalance_pgtables	./mmap.c	53;"	d	file:
arch_zone_highest_possible_pfn	./page_alloc.c	/^static unsigned long __meminitdata arch_zone_highest_possible_pfn[MAX_NR_ZONES];$/;"	v	file:
arch_zone_lowest_possible_pfn	./page_alloc.c	/^static unsigned long __meminitdata arch_zone_lowest_possible_pfn[MAX_NR_ZONES];$/;"	v	file:
area_list	./kmemleak.c	/^	struct hlist_head area_list;$/;"	m	struct:kmemleak_object	typeref:struct:kmemleak_object::hlist_head	file:
array_cache	./slab.c	/^struct array_cache {$/;"	s	file:
arraycache_init	./slab.c	/^struct arraycache_init {$/;"	s	file:
attr	./failslab.c	/^	struct fault_attr attr;$/;"	m	struct:__anon12	typeref:struct:__anon12::fault_attr	file:
attr	./page_alloc.c	/^	struct fault_attr attr;$/;"	m	struct:__anon2	typeref:struct:__anon2::fault_attr	file:
attr	./slub.c	/^	struct attribute attr;$/;"	m	struct:slab_attribute	typeref:struct:slab_attribute::attribute	file:
avail	./slab.c	/^	unsigned int avail;$/;"	m	struct:array_cache	file:
avc_last_pgoff	./interval_tree.c	/^static inline unsigned long avc_last_pgoff(struct anon_vma_chain *avc)$/;"	f	file:
avc_start_pgoff	./interval_tree.c	/^static inline unsigned long avc_start_pgoff(struct anon_vma_chain *avc)$/;"	f	file:
bad_page	./page_alloc.c	/^static void bad_page(struct page *page, const char *reason,$/;"	f	file:
bad_range	./page_alloc.c	/^static inline int bad_range(struct zone *zone, struct page *page)$/;"	f	file:
bad_range	./page_alloc.c	/^static int bad_range(struct zone *zone, struct page *page)$/;"	f	file:
balance_dirty_pages	./page-writeback.c	/^static void balance_dirty_pages(struct address_space *mapping,$/;"	f	file:
balance_dirty_pages_ratelimited	./page-writeback.c	/^EXPORT_SYMBOL(balance_dirty_pages_ratelimited);$/;"	v
balance_dirty_pages_ratelimited	./page-writeback.c	/^void balance_dirty_pages_ratelimited(struct address_space *mapping)$/;"	f
balance_pgdat	./vmscan.c	/^static unsigned long balance_pgdat(pg_data_t *pgdat, int order,$/;"	f	file:
balloon_devinfo_alloc	./balloon_compaction.c	/^EXPORT_SYMBOL_GPL(balloon_devinfo_alloc);$/;"	v
balloon_devinfo_alloc	./balloon_compaction.c	/^struct balloon_dev_info *balloon_devinfo_alloc(void *balloon_dev_descriptor)$/;"	f
balloon_mapping_alloc	./balloon_compaction.c	/^EXPORT_SYMBOL_GPL(balloon_mapping_alloc);$/;"	v
balloon_mapping_alloc	./balloon_compaction.c	/^struct address_space *balloon_mapping_alloc(struct balloon_dev_info *b_dev_info,$/;"	f
balloon_page_dequeue	./balloon_compaction.c	/^EXPORT_SYMBOL_GPL(balloon_page_dequeue);$/;"	v
balloon_page_dequeue	./balloon_compaction.c	/^struct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)$/;"	f
balloon_page_enqueue	./balloon_compaction.c	/^EXPORT_SYMBOL_GPL(balloon_page_enqueue);$/;"	v
balloon_page_enqueue	./balloon_compaction.c	/^struct page *balloon_page_enqueue(struct balloon_dev_info *b_dev_info)$/;"	f
balloon_page_isolate	./balloon_compaction.c	/^bool balloon_page_isolate(struct page *page)$/;"	f
balloon_page_migrate	./balloon_compaction.c	/^int balloon_page_migrate(struct page *newpage,$/;"	f
balloon_page_putback	./balloon_compaction.c	/^void balloon_page_putback(struct page *page)$/;"	f
base_addr	./percpu.c	/^	void			*base_addr;	\/* base address of this chunk *\/$/;"	m	struct:pcpu_chunk	file:
batchcount	./slab.c	/^	unsigned int batchcount;$/;"	m	struct:array_cache	file:
batchcount	./slab.h	/^	unsigned int batchcount;$/;"	m	struct:slabinfo
bdebug	./bootmem.c	50;"	d	file:
bdi_class	./backing-dev.c	/^static struct class *bdi_class;$/;"	v	typeref:struct:class	file:
bdi_class_init	./backing-dev.c	/^postcore_initcall(bdi_class_init);$/;"	v
bdi_class_init	./backing-dev.c	/^static __init int bdi_class_init(void)$/;"	f	file:
bdi_debug_init	./backing-dev.c	/^static inline void bdi_debug_init(void)$/;"	f	file:
bdi_debug_init	./backing-dev.c	/^static void bdi_debug_init(void)$/;"	f	file:
bdi_debug_register	./backing-dev.c	/^static inline void bdi_debug_register(struct backing_dev_info *bdi,$/;"	f	file:
bdi_debug_register	./backing-dev.c	/^static void bdi_debug_register(struct backing_dev_info *bdi, const char *name)$/;"	f	file:
bdi_debug_root	./backing-dev.c	/^static struct dentry *bdi_debug_root;$/;"	v	typeref:struct:dentry	file:
bdi_debug_stats_fops	./backing-dev.c	/^static const struct file_operations bdi_debug_stats_fops = {$/;"	v	typeref:struct:file_operations	file:
bdi_debug_stats_open	./backing-dev.c	/^static int bdi_debug_stats_open(struct inode *inode, struct file *file)$/;"	f	file:
bdi_debug_stats_show	./backing-dev.c	/^static int bdi_debug_stats_show(struct seq_file *m, void *v)$/;"	f	file:
bdi_debug_unregister	./backing-dev.c	/^static inline void bdi_debug_unregister(struct backing_dev_info *bdi)$/;"	f	file:
bdi_debug_unregister	./backing-dev.c	/^static void bdi_debug_unregister(struct backing_dev_info *bdi)$/;"	f	file:
bdi_destroy	./backing-dev.c	/^EXPORT_SYMBOL(bdi_destroy);$/;"	v
bdi_destroy	./backing-dev.c	/^void bdi_destroy(struct backing_dev_info *bdi)$/;"	f
bdi_dev	./backing-dev.c	/^ATTRIBUTE_GROUPS(bdi_dev);$/;"	v
bdi_dev_attrs	./backing-dev.c	/^static struct attribute *bdi_dev_attrs[] = {$/;"	v	typeref:struct:attribute	file:
bdi_dirty_limit	./page-writeback.c	/^unsigned long bdi_dirty_limit(struct backing_dev_info *bdi, unsigned long dirty)$/;"	f
bdi_dirty_limits	./page-writeback.c	/^static inline void bdi_dirty_limits(struct backing_dev_info *bdi,$/;"	f	file:
bdi_has_dirty_io	./backing-dev.c	/^int bdi_has_dirty_io(struct backing_dev_info *bdi)$/;"	f
bdi_init	./backing-dev.c	/^EXPORT_SYMBOL(bdi_init);$/;"	v
bdi_init	./backing-dev.c	/^int bdi_init(struct backing_dev_info *bdi)$/;"	f
bdi_list	./backing-dev.c	/^LIST_HEAD(bdi_list);$/;"	v
bdi_lock	./backing-dev.c	/^DEFINE_SPINLOCK(bdi_lock);$/;"	v
bdi_lock_two	./backing-dev.c	/^void bdi_lock_two(struct bdi_writeback *wb1, struct bdi_writeback *wb2)$/;"	f
bdi_max_pause	./page-writeback.c	/^static unsigned long bdi_max_pause(struct backing_dev_info *bdi,$/;"	f	file:
bdi_min_pause	./page-writeback.c	/^static long bdi_min_pause(struct backing_dev_info *bdi,$/;"	f	file:
bdi_min_ratio	./page-writeback.c	/^static unsigned int bdi_min_ratio;$/;"	v	file:
bdi_position_ratio	./page-writeback.c	/^static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,$/;"	f	file:
bdi_prune_sb	./backing-dev.c	/^static void bdi_prune_sb(struct backing_dev_info *bdi)$/;"	f	file:
bdi_register	./backing-dev.c	/^EXPORT_SYMBOL(bdi_register);$/;"	v
bdi_register	./backing-dev.c	/^int bdi_register(struct backing_dev_info *bdi, struct device *parent,$/;"	f
bdi_register_dev	./backing-dev.c	/^EXPORT_SYMBOL(bdi_register_dev);$/;"	v
bdi_register_dev	./backing-dev.c	/^int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev)$/;"	f
bdi_remove_from_list	./backing-dev.c	/^static void bdi_remove_from_list(struct backing_dev_info *bdi)$/;"	f	file:
bdi_seq	./backing-dev.c	/^static atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);$/;"	v	file:
bdi_set_max_ratio	./page-writeback.c	/^EXPORT_SYMBOL(bdi_set_max_ratio);$/;"	v
bdi_set_max_ratio	./page-writeback.c	/^int bdi_set_max_ratio(struct backing_dev_info *bdi, unsigned max_ratio)$/;"	f
bdi_set_min_ratio	./page-writeback.c	/^int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)$/;"	f
bdi_setup_and_register	./backing-dev.c	/^EXPORT_SYMBOL(bdi_setup_and_register);$/;"	v
bdi_setup_and_register	./backing-dev.c	/^int bdi_setup_and_register(struct backing_dev_info *bdi, char *name,$/;"	f
bdi_unregister	./backing-dev.c	/^EXPORT_SYMBOL(bdi_unregister);$/;"	v
bdi_unregister	./backing-dev.c	/^void bdi_unregister(struct backing_dev_info *bdi)$/;"	f
bdi_update_bandwidth	./page-writeback.c	/^static void bdi_update_bandwidth(struct backing_dev_info *bdi,$/;"	f	file:
bdi_update_dirty_ratelimit	./page-writeback.c	/^static void bdi_update_dirty_ratelimit(struct backing_dev_info *bdi,$/;"	f	file:
bdi_update_write_bandwidth	./page-writeback.c	/^static void bdi_update_write_bandwidth(struct backing_dev_info *bdi,$/;"	f	file:
bdi_wakeup_thread_delayed	./backing-dev.c	/^void bdi_wakeup_thread_delayed(struct backing_dev_info *bdi)$/;"	f
bdi_wb_init	./backing-dev.c	/^static void bdi_wb_init(struct bdi_writeback *wb, struct backing_dev_info *bdi)$/;"	f	file:
bdi_wb_shutdown	./backing-dev.c	/^static void bdi_wb_shutdown(struct backing_dev_info *bdi)$/;"	f	file:
bdi_wq	./backing-dev.c	/^struct workqueue_struct *bdi_wq;$/;"	v	typeref:struct:workqueue_struct
bdi_writeout_fraction	./page-writeback.c	/^static void bdi_writeout_fraction(struct backing_dev_info *bdi,$/;"	f	file:
bdi_writeout_inc	./page-writeback.c	/^EXPORT_SYMBOL_GPL(bdi_writeout_inc);$/;"	v
bdi_writeout_inc	./page-writeback.c	/^void bdi_writeout_inc(struct backing_dev_info *bdi)$/;"	f
blk_queue_bounce	./bounce.c	/^EXPORT_SYMBOL(blk_queue_bounce);$/;"	v
blk_queue_bounce	./bounce.c	/^void blk_queue_bounce(struct request_queue *q, struct bio **bio_orig)$/;"	f
block_dump	./page-writeback.c	/^int block_dump;$/;"	v
bootmap_bytes	./bootmem.c	/^static unsigned long __init bootmap_bytes(unsigned long pages)$/;"	f	file:
bootmem_bootmap_pages	./bootmem.c	/^unsigned long __init bootmem_bootmap_pages(unsigned long pages)$/;"	f
bootmem_debug	./bootmem.c	/^static int bootmem_debug;$/;"	v	file:
bootmem_debug_setup	./bootmem.c	/^static int __init bootmem_debug_setup(char *buf)$/;"	f	file:
bootstrap	./slub.c	/^static struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)$/;"	f	file:
bounce_copy_vec	./bounce.c	/^static void bounce_copy_vec(struct bio_vec *to, unsigned char *vfrom)$/;"	f	file:
bounce_copy_vec	./bounce.c	63;"	d	file:
bounce_end_io	./bounce.c	/^static void bounce_end_io(struct bio *bio, mempool_t *pool, int err)$/;"	f	file:
bounce_end_io_read	./bounce.c	/^static void bounce_end_io_read(struct bio *bio, int err)$/;"	f	file:
bounce_end_io_read_isa	./bounce.c	/^static void bounce_end_io_read_isa(struct bio *bio, int err)$/;"	f	file:
bounce_end_io_write	./bounce.c	/^static void bounce_end_io_write(struct bio *bio, int err)$/;"	f	file:
bounce_end_io_write_isa	./bounce.c	/^static void bounce_end_io_write_isa(struct bio *bio, int err)$/;"	f	file:
boundary	./dmapool.c	/^	size_t boundary;$/;"	m	struct:dma_pool	file:
break_cow	./ksm.c	/^static void break_cow(struct rmap_item *rmap_item)$/;"	f	file:
break_ksm	./ksm.c	/^static int break_ksm(struct vm_area_struct *vma, unsigned long addr)$/;"	f	file:
browse_rb	./mmap.c	/^static int browse_rb(struct rb_root *root)$/;"	f	file:
buddied	./zbud.c	/^	struct list_head buddied;$/;"	m	struct:zbud_pool	typeref:struct:zbud_pool::list_head	file:
buddy	./zbud.c	/^	struct list_head buddy;$/;"	m	struct:zbud_header	typeref:struct:zbud_header::list_head	file:
buddy	./zbud.c	/^enum buddy {$/;"	g	file:
buffer_migrate_lock_buffers	./migrate.c	/^static bool buffer_migrate_lock_buffers(struct buffer_head *head,$/;"	f	file:
buffer_migrate_lock_buffers	./migrate.c	/^static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,$/;"	f	file:
buffer_migrate_page	./migrate.c	/^EXPORT_SYMBOL(buffer_migrate_page);$/;"	v
buffer_migrate_page	./migrate.c	/^int buffer_migrate_page(struct address_space *mapping,$/;"	f
buffered_rmqueue	./page_alloc.c	/^struct page *buffered_rmqueue(struct zone *preferred_zone,$/;"	f	file:
build_all_zonelists	./page_alloc.c	/^void __ref build_all_zonelists(pg_data_t *pgdat, struct zone *zone)$/;"	f
build_thisnode_zonelists	./page_alloc.c	/^static void build_thisnode_zonelists(pg_data_t *pgdat)$/;"	f	file:
build_zonelist_cache	./page_alloc.c	/^static void build_zonelist_cache(pg_data_t *pgdat)$/;"	f	file:
build_zonelists	./page_alloc.c	/^static void build_zonelists(pg_data_t *pgdat)$/;"	f	file:
build_zonelists_in_node_order	./page_alloc.c	/^static void build_zonelists_in_node_order(pg_data_t *pgdat, int node)$/;"	f	file:
build_zonelists_in_zone_order	./page_alloc.c	/^static void build_zonelists_in_zone_order(pg_data_t *pgdat, int nr_nodes)$/;"	f	file:
build_zonelists_node	./page_alloc.c	/^static int build_zonelists_node(pg_data_t *pgdat, struct zonelist *zonelist,$/;"	f	file:
cache	./slab.c	/^	struct array_cache cache;$/;"	m	struct:arraycache_init	typeref:struct:arraycache_init::array_cache	file:
cache_alloc_debugcheck_after	./slab.c	/^static void *cache_alloc_debugcheck_after(struct kmem_cache *cachep,$/;"	f	file:
cache_alloc_debugcheck_after	./slab.c	3010;"	d	file:
cache_alloc_debugcheck_before	./slab.c	/^static inline void cache_alloc_debugcheck_before(struct kmem_cache *cachep,$/;"	f	file:
cache_alloc_refill	./slab.c	/^static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags,$/;"	f	file:
cache_dma	./slub.c	/^SLAB_ATTR_RO(cache_dma);$/;"	v
cache_dma_show	./slub.c	/^static ssize_t cache_dma_show(struct kmem_cache *s, char *buf)$/;"	f	file:
cache_estimate	./slab.c	/^static void cache_estimate(unsigned long gfporder, size_t buffer_size,$/;"	f	file:
cache_filter	./failslab.c	/^	int cache_filter;$/;"	m	struct:__anon12	file:
cache_flusharray	./slab.c	/^static void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)$/;"	f	file:
cache_free_alien	./slab.c	/^static inline int cache_free_alien(struct kmem_cache *cachep, void *objp)$/;"	f	file:
cache_free_debugcheck	./slab.c	/^static void *cache_free_debugcheck(struct kmem_cache *cachep, void *objp,$/;"	f	file:
cache_free_debugcheck	./slab.c	2854;"	d	file:
cache_from_memcg_idx	./slab.h	/^cache_from_memcg_idx(struct kmem_cache *s, int idx)$/;"	f
cache_from_obj	./slab.h	/^static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)$/;"	f
cache_grow	./slab.c	/^static int cache_grow(struct kmem_cache *cachep,$/;"	f	file:
cache_init_objs	./slab.c	/^static void cache_init_objs(struct kmem_cache *cachep,$/;"	f	file:
cache_kset	./slub.c	/^static inline struct kset *cache_kset(struct kmem_cache *s)$/;"	f	file:
cache_name	./slab.h	/^static inline const char *cache_name(struct kmem_cache *s)$/;"	f
cache_order	./slab.h	/^	unsigned int cache_order;$/;"	m	struct:slabinfo
cache_reap	./slab.c	/^static void cache_reap(struct work_struct *w)$/;"	f	file:
cache_show	./slab_common.c	/^int cache_show(struct kmem_cache *s, struct seq_file *m)$/;"	f
cached	./memcontrol.c	/^	struct mem_cgroup *cached; \/* this never be root cgroup *\/$/;"	m	struct:memcg_stock_pcp	typeref:struct:memcg_stock_pcp::mem_cgroup	file:
cached_align	./vmalloc.c	/^static unsigned long cached_align;$/;"	v	file:
cached_hole_size	./vmalloc.c	/^static unsigned long cached_hole_size;$/;"	v	file:
cached_vstart	./vmalloc.c	/^static unsigned long cached_vstart;$/;"	v	file:
cachep	./memcontrol.c	/^	struct kmem_cache *cachep;$/;"	m	struct:create_work	typeref:struct:create_work::kmem_cache	file:
cachep	./slab.c	/^	struct kmem_cache *cachep;$/;"	m	struct:ccupdate_struct	typeref:struct:ccupdate_struct::kmem_cache	file:
calc_checksum	./ksm.c	/^static u32 calc_checksum(struct page *page)$/;"	f	file:
calc_memmap_size	./page_alloc.c	/^static unsigned long __paginginit calc_memmap_size(unsigned long spanned_pages,$/;"	f	file:
calculate_alignment	./slab_common.c	/^unsigned long calculate_alignment(unsigned long flags,$/;"	f
calculate_node_totalpages	./page_alloc.c	/^static void __meminit calculate_node_totalpages(struct pglist_data *pgdat,$/;"	f	file:
calculate_normal_threshold	./vmstat.c	/^int calculate_normal_threshold(struct zone *zone)$/;"	f
calculate_nr_objs	./slab.c	/^static int calculate_nr_objs(size_t slab_size, size_t buffer_size,$/;"	f	file:
calculate_order	./slub.c	/^static inline int calculate_order(int size, int reserved)$/;"	f	file:
calculate_pressure_threshold	./vmstat.c	/^int calculate_pressure_threshold(struct zone *zone)$/;"	f
calculate_sizes	./slub.c	/^static int calculate_sizes(struct kmem_cache *s, int forced_order)$/;"	f	file:
calculate_slab_order	./slab.c	/^static size_t calculate_slab_order(struct kmem_cache *cachep,$/;"	f	file:
calculate_totalreserve_pages	./page_alloc.c	/^static void calculate_totalreserve_pages(void)$/;"	f	file:
calculate_zone_inactive_ratio	./page_alloc.c	/^static void __meminit calculate_zone_inactive_ratio(struct zone *zone)$/;"	f	file:
can_do_mlock	./mlock.c	/^EXPORT_SYMBOL(can_do_mlock);$/;"	v
can_do_mlock	./mlock.c	/^int can_do_mlock(void)$/;"	f
can_offline_normal	./memory_hotplug.c	/^static bool can_offline_normal(struct zone *zone, unsigned long nr_pages)$/;"	f	file:
can_online_high_movable	./memory_hotplug.c	/^static bool can_online_high_movable(struct zone *zone)$/;"	f	file:
can_vma_merge_after	./mmap.c	/^can_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,$/;"	f	file:
can_vma_merge_before	./mmap.c	/^can_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,$/;"	f	file:
cancel_dirty_page	./truncate.c	/^EXPORT_SYMBOL(cancel_dirty_page);$/;"	v
cancel_dirty_page	./truncate.c	/^void cancel_dirty_page(struct page *page, unsigned int account_size)$/;"	f
ccupdate_struct	./slab.c	/^struct ccupdate_struct {$/;"	s	file:
change_huge_pmd	./huge_memory.c	/^int change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f
change_pageblock_range	./page_alloc.c	/^static void change_pageblock_range(struct page *pageblock_page,$/;"	f	file:
change_pmd_range	./mprotect.c	/^static inline unsigned long change_pmd_range(struct vm_area_struct *vma,$/;"	f	file:
change_prot_numa	./mempolicy.c	/^static unsigned long change_prot_numa(struct vm_area_struct *vma,$/;"	f	file:
change_prot_numa	./mempolicy.c	/^unsigned long change_prot_numa(struct vm_area_struct *vma,$/;"	f
change_protection	./mprotect.c	/^unsigned long change_protection(struct vm_area_struct *vma, unsigned long start,$/;"	f
change_protection_range	./mprotect.c	/^static unsigned long change_protection_range(struct vm_area_struct *vma,$/;"	f	file:
change_pte_range	./mprotect.c	/^static unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f	file:
change_pud_range	./mprotect.c	/^static inline unsigned long change_pud_range(struct vm_area_struct *vma,$/;"	f	file:
charge_type	./memcontrol.c	/^enum charge_type {$/;"	g	file:
check_and_unmap_cpu_on_node	./memory_hotplug.c	/^static int check_and_unmap_cpu_on_node(pg_data_t *pgdat)$/;"	f	file:
check_bytes_and_report	./slub.c	/^static int check_bytes_and_report(struct kmem_cache *s, struct page *page,$/;"	f	file:
check_cpu_on_node	./memory_hotplug.c	/^static int check_cpu_on_node(pg_data_t *pgdat)$/;"	f	file:
check_early_ioremap_leak	./early_ioremap.c	/^late_initcall(check_early_ioremap_leak);$/;"	v
check_early_ioremap_leak	./early_ioremap.c	/^static int __init check_early_ioremap_leak(void)$/;"	f	file:
check_for_memory	./page_alloc.c	/^static void check_for_memory(pg_data_t *pgdat, int nid)$/;"	f	file:
check_hotplug_memory_range	./memory_hotplug.c	/^static int check_hotplug_memory_range(u64 start, u64 size)$/;"	f	file:
check_irq_off	./slab.c	/^static void check_irq_off(void)$/;"	f	file:
check_irq_off	./slab.c	2387;"	d	file:
check_irq_on	./slab.c	/^static void check_irq_on(void)$/;"	f	file:
check_irq_on	./slab.c	2388;"	d	file:
check_memblock_offlined_cb	./memory_hotplug.c	/^static int check_memblock_offlined_cb(struct memory_block *mem, void *arg)$/;"	f	file:
check_move_unevictable_pages	./vmscan.c	/^void check_move_unevictable_pages(struct page **pages, int nr_pages)$/;"	f
check_new_page	./page_alloc.c	/^static inline int check_new_page(struct page *page)$/;"	f	file:
check_numabalancing_enable	./mempolicy.c	/^static inline void __init check_numabalancing_enable(void)$/;"	f	file:
check_numabalancing_enable	./mempolicy.c	/^static void __init check_numabalancing_enable(void)$/;"	f	file:
check_object	./slub.c	/^static inline int check_object(struct kmem_cache *s, struct page *page,$/;"	f	file:
check_object	./slub.c	/^static int check_object(struct kmem_cache *s, struct page *page,$/;"	f	file:
check_pad_bytes	./slub.c	/^static int check_pad_bytes(struct kmem_cache *s, struct page *page, u8 *p)$/;"	f	file:
check_pages_isolated	./memory_hotplug.c	/^check_pages_isolated(unsigned long start_pfn, unsigned long end_pfn)$/;"	f	file:
check_pages_isolated_cb	./memory_hotplug.c	/^check_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,$/;"	f	file:
check_panic_on_oom	./oom_kill.c	/^void check_panic_on_oom(enum oom_constraint constraint, gfp_t gfp_mask,$/;"	f
check_poison_mem	./debug-pagealloc.c	/^static void check_poison_mem(unsigned char *mem, size_t bytes)$/;"	f	file:
check_poison_obj	./slab.c	/^static void check_poison_obj(struct kmem_cache *cachep, void *objp)$/;"	f	file:
check_slab	./slub.c	/^static int check_slab(struct kmem_cache *s, struct page *page)$/;"	f	file:
check_spinlock_acquired	./slab.c	/^static void check_spinlock_acquired(struct kmem_cache *cachep)$/;"	f	file:
check_spinlock_acquired	./slab.c	2389;"	d	file:
check_spinlock_acquired_node	./slab.c	/^static void check_spinlock_acquired_node(struct kmem_cache *cachep, int node)$/;"	f	file:
check_spinlock_acquired_node	./slab.c	2390;"	d	file:
check_stack_guard_page	./memory.c	/^static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)$/;"	f	file:
check_sync_rss_stat	./memory.c	/^static void check_sync_rss_stat(struct task_struct *task)$/;"	f	file:
check_usemap_section_nr	./sparse.c	/^static void __init check_usemap_section_nr(int nid, unsigned long *usemap)$/;"	f	file:
check_valid_pointer	./slub.c	/^static inline int check_valid_pointer(struct kmem_cache *s,$/;"	f	file:
checksum	./kmemleak.c	/^	u32 checksum;$/;"	m	struct:kmemleak_object	file:
claim_swapfile	./swapfile.c	/^static int claim_swapfile(struct swap_info_struct *p, struct inode *inode)$/;"	f	file:
cleancache_failed_gets	./cleancache.c	/^static u64 cleancache_failed_gets;$/;"	v	file:
cleancache_get_key	./cleancache.c	/^static int cleancache_get_key(struct inode *inode,$/;"	f	file:
cleancache_invalidates	./cleancache.c	/^static u64 cleancache_invalidates;$/;"	v	file:
cleancache_puts	./cleancache.c	/^static u64 cleancache_puts;$/;"	v	file:
cleancache_register_ops	./cleancache.c	/^EXPORT_SYMBOL(cleancache_register_ops);$/;"	v
cleancache_register_ops	./cleancache.c	/^struct cleancache_ops *cleancache_register_ops(struct cleancache_ops *ops)$/;"	f
cleancache_succ_gets	./cleancache.c	/^static u64 cleancache_succ_gets;$/;"	v	file:
clear_bdi_congested	./backing-dev.c	/^EXPORT_SYMBOL(clear_bdi_congested);$/;"	v
clear_bdi_congested	./backing-dev.c	/^void clear_bdi_congested(struct backing_dev_info *bdi, int sync)$/;"	f
clear_exceptional_entry	./truncate.c	/^static void clear_exceptional_entry(struct address_space *mapping,$/;"	f	file:
clear_gigantic_page	./memory.c	/^static void clear_gigantic_page(struct page *page,$/;"	f	file:
clear_huge_page	./memory.c	/^void clear_huge_page(struct page *page,$/;"	f
clear_hwpoisoned_pages	./sparse.c	/^static inline void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)$/;"	f	file:
clear_hwpoisoned_pages	./sparse.c	/^static void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)$/;"	f	file:
clear_obj_pfmemalloc	./slab.c	/^static inline void clear_obj_pfmemalloc(void **objp)$/;"	f	file:
clear_page_dirty_for_io	./page-writeback.c	/^EXPORT_SYMBOL(clear_page_dirty_for_io);$/;"	v
clear_page_dirty_for_io	./page-writeback.c	/^int clear_page_dirty_for_io(struct page *page)$/;"	f
clear_page_guard_flag	./page_alloc.c	/^static inline void clear_page_guard_flag(struct page *page) { }$/;"	f	file:
clear_page_guard_flag	./page_alloc.c	/^static inline void clear_page_guard_flag(struct page *page)$/;"	f	file:
clear_page_hwpoison_huge_page	./memory-failure.c	/^static void clear_page_hwpoison_huge_page(struct page *hpage)$/;"	f	file:
clear_page_mlock	./internal.h	/^static inline void clear_page_mlock(struct page *page) { }$/;"	f
clear_page_mlock	./mlock.c	/^void clear_page_mlock(struct page *page)$/;"	f
clear_page_poison	./debug-pagealloc.c	/^static inline void clear_page_poison(struct page *page)$/;"	f	file:
clear_slob_page_free	./slob.c	/^static inline void clear_slob_page_free(struct page *sp)$/;"	f	file:
clear_stat	./slub.c	/^static void clear_stat(struct kmem_cache *s, enum stat_item si)$/;"	f	file:
clear_vm_uninitialized_flag	./vmalloc.c	/^static void clear_vm_uninitialized_flag(struct vm_struct *vm)$/;"	f	file:
clear_zonelist_oom	./oom_kill.c	/^void clear_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)$/;"	f
cluster_count	./swapfile.c	/^static inline unsigned int cluster_count(struct swap_cluster_info *info)$/;"	f	file:
cluster_is_free	./swapfile.c	/^static inline bool cluster_is_free(struct swap_cluster_info *info)$/;"	f	file:
cluster_is_null	./swapfile.c	/^static inline bool cluster_is_null(struct swap_cluster_info *info)$/;"	f	file:
cluster_next	./swapfile.c	/^static inline unsigned int cluster_next(struct swap_cluster_info *info)$/;"	f	file:
cluster_set_count	./swapfile.c	/^static inline void cluster_set_count(struct swap_cluster_info *info,$/;"	f	file:
cluster_set_count_flag	./swapfile.c	/^static inline void cluster_set_count_flag(struct swap_cluster_info *info,$/;"	f	file:
cluster_set_flag	./swapfile.c	/^static inline void cluster_set_flag(struct swap_cluster_info *info,$/;"	f	file:
cluster_set_next	./swapfile.c	/^static inline void cluster_set_next(struct swap_cluster_info *info,$/;"	f	file:
cluster_set_next_flag	./swapfile.c	/^static inline void cluster_set_next_flag(struct swap_cluster_info *info,$/;"	f	file:
cluster_set_null	./swapfile.c	/^static inline void cluster_set_null(struct swap_cluster_info *info)$/;"	f	file:
cmdline_parse_core	./page_alloc.c	/^static int __init cmdline_parse_core(char *p, unsigned long *core)$/;"	f	file:
cmdline_parse_kernelcore	./page_alloc.c	/^static int __init cmdline_parse_kernelcore(char *p)$/;"	f	file:
cmdline_parse_movable_node	./memory_hotplug.c	/^static int __init cmdline_parse_movable_node(char *p)$/;"	f	file:
cmdline_parse_movablecore	./page_alloc.c	/^static int __init cmdline_parse_movablecore(char *p)$/;"	f	file:
cmp_and_merge_page	./ksm.c	/^static void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)$/;"	f	file:
cmpxchg_double_slab	./slub.c	/^static inline bool cmpxchg_double_slab(struct kmem_cache *s, struct page *page,$/;"	f	file:
collapse_huge_page	./huge_memory.c	/^static void collapse_huge_page(struct mm_struct *mm,$/;"	f	file:
collect_mm_slot	./huge_memory.c	/^static void collect_mm_slot(struct mm_slot *mm_slot)$/;"	f	file:
collect_procs	./memory-failure.c	/^static void collect_procs(struct page *page, struct list_head *tokill)$/;"	f	file:
collect_procs_anon	./memory-failure.c	/^static void collect_procs_anon(struct page *page, struct list_head *to_kill,$/;"	f	file:
collect_procs_file	./memory-failure.c	/^static void collect_procs_file(struct page *page, struct list_head *to_kill,$/;"	f	file:
color_gray	./kmemleak.c	/^static bool color_gray(const struct kmemleak_object *object)$/;"	f	file:
color_white	./kmemleak.c	/^static bool color_white(const struct kmemleak_object *object)$/;"	f	file:
colour_next	./slab.h	/^	unsigned int colour_next;	\/* Per-node cache coloring *\/$/;"	m	struct:kmem_cache_node
comm	./kmemleak.c	/^	char comm[TASK_COMM_LEN];	\/* executable name *\/$/;"	m	struct:kmemleak_object	file:
comp_op	./zswap.c	/^enum comp_op {$/;"	g	file:
compact_checklock_irqsave	./compaction.c	/^static bool compact_checklock_irqsave(spinlock_t *lock, unsigned long *flags,$/;"	f	file:
compact_control	./internal.h	/^struct compact_control {$/;"	s
compact_finished	./compaction.c	/^static int compact_finished(struct zone *zone,$/;"	f	file:
compact_node	./compaction.c	/^static void compact_node(int nid)$/;"	f	file:
compact_nodes	./compaction.c	/^static void compact_nodes(void)$/;"	f	file:
compact_pgdat	./compaction.c	/^void compact_pgdat(pg_data_t *pgdat, int order)$/;"	f
compact_trylock_irqsave	./compaction.c	/^static inline bool compact_trylock_irqsave(spinlock_t *lock,$/;"	f	file:
compact_zone	./compaction.c	/^static int compact_zone(struct zone *zone, struct compact_control *cc)$/;"	f	file:
compact_zone_order	./compaction.c	/^static unsigned long compact_zone_order(struct zone *zone,$/;"	f	file:
compaction_alloc	./compaction.c	/^static struct page *compaction_alloc(struct page *migratepage,$/;"	f	file:
compaction_ready	./vmscan.c	/^static inline bool compaction_ready(struct zone *zone, struct scan_control *sc)$/;"	f	file:
compaction_register_node	./compaction.c	/^int compaction_register_node(struct node *node)$/;"	f
compaction_suitable	./compaction.c	/^unsigned long compaction_suitable(struct zone *zone, int order)$/;"	f
compaction_unregister_node	./compaction.c	/^void compaction_unregister_node(struct node *node)$/;"	f
compare_thresholds	./memcontrol.c	/^static int compare_thresholds(const void *a, const void *b)$/;"	f	file:
compat_process_vm_rw	./process_vm_access.c	/^compat_process_vm_rw(compat_pid_t pid,$/;"	f	file:
compound	./memory-failure.c	752;"	d	file:
compound	./memory-failure.c	809;"	d	file:
congestion_wait	./backing-dev.c	/^EXPORT_SYMBOL(congestion_wait);$/;"	v
congestion_wait	./backing-dev.c	/^long congestion_wait(int sync, long timeout)$/;"	f
congestion_wqh	./backing-dev.c	/^static wait_queue_head_t congestion_wqh[2] = {$/;"	v	file:
constrained_alloc	./oom_kill.c	/^static enum oom_constraint constrained_alloc(struct zonelist *zonelist,$/;"	f	file:
consume_stock	./memcontrol.c	/^static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)$/;"	f	file:
contended	./internal.h	/^	bool contended;			\/* True if a lock was contended *\/$/;"	m	struct:compact_control
contig_hint	./percpu.c	/^	int			contig_hint;	\/* max contiguous size hint *\/$/;"	m	struct:pcpu_chunk	file:
contig_page_data	./bootmem.c	/^EXPORT_SYMBOL(contig_page_data);$/;"	v
contig_page_data	./bootmem.c	/^struct pglist_data __refdata contig_page_data = {$/;"	v	typeref:struct:__refdata
contig_page_data	./nobootmem.c	/^EXPORT_SYMBOL(contig_page_data);$/;"	v
contig_page_data	./nobootmem.c	/^struct pglist_data __refdata contig_page_data;$/;"	v	typeref:struct:__refdata
contig_page_info	./vmstat.c	/^struct contig_page_info {$/;"	s	file:
copy_huge_page	./migrate.c	/^static void copy_huge_page(struct page *dst, struct page *src)$/;"	f	file:
copy_huge_pmd	./huge_memory.c	/^int copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,$/;"	f
copy_hugetlb_page_range	./hugetlb.c	/^int copy_hugetlb_page_range(struct mm_struct *dst, struct mm_struct *src,$/;"	f
copy_nodes_to_user	./mempolicy.c	/^static int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,$/;"	f	file:
copy_one_pte	./memory.c	/^copy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,$/;"	f	file:
copy_page_range	./memory.c	/^int copy_page_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,$/;"	f
copy_page_to_iter	./iov_iter.c	/^EXPORT_SYMBOL(copy_page_to_iter);$/;"	v
copy_page_to_iter	./iov_iter.c	/^size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,$/;"	f
copy_pmd_range	./memory.c	/^static inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,$/;"	f	file:
copy_pte_range	./memory.c	/^int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,$/;"	f
copy_pud_range	./memory.c	/^static inline int copy_pud_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,$/;"	f	file:
copy_to_high_bio_irq	./bounce.c	/^static void copy_to_high_bio_irq(struct bio *to, struct bio *from)$/;"	f	file:
copy_user_gigantic_page	./memory.c	/^static void copy_user_gigantic_page(struct page *dst, struct page *src,$/;"	f	file:
copy_user_huge_page	./memory.c	/^void copy_user_huge_page(struct page *dst, struct page *src,$/;"	f
copy_vma	./mmap.c	/^struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,$/;"	f
count	./kmemleak.c	/^	int count;$/;"	m	struct:kmemleak_object	file:
count	./memcontrol.c	/^	long count[MEM_CGROUP_STAT_NSTATS];$/;"	m	struct:mem_cgroup_stat_cpu	file:
count	./slub.c	/^	unsigned long count;$/;"	m	struct:loc_track	file:
count	./slub.c	/^	unsigned long count;$/;"	m	struct:location	file:
count_compact_event	./compaction.c	/^static inline void count_compact_event(enum vm_event_item item)$/;"	f	file:
count_compact_event	./compaction.c	32;"	d	file:
count_compact_events	./compaction.c	/^static inline void count_compact_events(enum vm_event_item item, long delta)$/;"	f	file:
count_compact_events	./compaction.c	33;"	d	file:
count_free	./slub.c	/^static int count_free(struct page *page)$/;"	f	file:
count_history_pages	./readahead.c	/^static pgoff_t count_history_pages(struct address_space *mapping,$/;"	f	file:
count_inuse	./slub.c	/^static int count_inuse(struct page *page)$/;"	f	file:
count_partial	./slub.c	/^static unsigned long count_partial(struct kmem_cache_node *n,$/;"	f	file:
count_shadow_nodes	./workingset.c	/^static unsigned long count_shadow_nodes(struct shrinker *shrinker,$/;"	f	file:
count_swap_pages	./swapfile.c	/^unsigned int count_swap_pages(int type, int free)$/;"	f
count_total	./slub.c	/^static int count_total(struct page *page)$/;"	f	file:
count_vma_pages_range	./mmap.c	/^static unsigned long count_vma_pages_range(struct mm_struct *mm,$/;"	f	file:
cow_user_page	./memory.c	/^static inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)$/;"	f	file:
cpu	./slub.c	/^	int cpu;		\/* Was running on cpu *\/$/;"	m	struct:track	file:
cpu_cache_get	./slab.c	/^static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)$/;"	f	file:
cpu_callback	./vmscan.c	/^static int cpu_callback(struct notifier_block *nfb, unsigned long action,$/;"	f	file:
cpu_partial	./slub.c	/^SLAB_ATTR(cpu_partial);$/;"	v
cpu_partial_show	./slub.c	/^static ssize_t cpu_partial_show(struct kmem_cache *s, char *buf)$/;"	f	file:
cpu_partial_store	./slub.c	/^static ssize_t cpu_partial_store(struct kmem_cache *s, const char *buf,$/;"	f	file:
cpu_slabs	./slub.c	/^SLAB_ATTR_RO(cpu_slabs);$/;"	v
cpu_slabs_show	./slub.c	/^static ssize_t cpu_slabs_show(struct kmem_cache *s, char *buf)$/;"	f	file:
cpu_vm_stats_fold	./vmstat.c	/^void cpu_vm_stats_fold(int cpu)$/;"	f
cpucache_init	./slab.c	/^__initcall(cpucache_init);$/;"	v
cpucache_init	./slab.c	/^static int __init cpucache_init(void)$/;"	f	file:
cpucache_notifier	./slab.c	/^static struct notifier_block cpucache_notifier = {$/;"	v	typeref:struct:notifier_block	file:
cpuset_mems_nr	./hugetlb.c	/^static unsigned int cpuset_mems_nr(unsigned int *array)$/;"	f	file:
cpuup_callback	./slab.c	/^static int cpuup_callback(struct notifier_block *nfb,$/;"	f	file:
cpuup_canceled	./slab.c	/^static void cpuup_canceled(long cpu)$/;"	f	file:
cpuup_prepare	./slab.c	/^static int cpuup_prepare(long cpu)$/;"	f	file:
create	./mempolicy.c	/^	int (*create)(struct mempolicy *pol, const nodemask_t *nodes);$/;"	m	struct:mempolicy_operations	file:
create_boot_cache	./slab_common.c	/^void __init create_boot_cache(struct kmem_cache *s, const char *name, size_t size,$/;"	f
create_kmalloc_cache	./slab_common.c	/^struct kmem_cache *__init create_kmalloc_cache(const char *name, size_t size,$/;"	f
create_kmalloc_caches	./slab_common.c	/^void __init create_kmalloc_caches(unsigned long flags)$/;"	f
create_object	./kmemleak.c	/^static struct kmemleak_object *create_object(unsigned long ptr, size_t size,$/;"	f	file:
create_unique_id	./slub.c	/^static char *create_unique_id(struct kmem_cache *s)$/;"	f	file:
create_work	./memcontrol.c	/^struct create_work {$/;"	s	file:
css	./hugetlb_cgroup.c	/^	struct cgroup_subsys_state css;$/;"	m	struct:hugetlb_cgroup	typeref:struct:hugetlb_cgroup::cgroup_subsys_state	file:
css	./memcontrol.c	/^	struct cgroup_subsys_state css;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::cgroup_subsys_state	file:
ctor	./slub.c	/^SLAB_ATTR_RO(ctor);$/;"	v
ctor_show	./slub.c	/^static ssize_t ctor_show(struct kmem_cache *s, char *buf)$/;"	f	file:
current_threshold	./memcontrol.c	/^	int current_threshold;$/;"	m	struct:mem_cgroup_threshold_ary	file:
current_zonelist_order	./page_alloc.c	/^static int current_zonelist_order = ZONELIST_ORDER_DEFAULT;$/;"	v	file:
data	./percpu.c	/^	void			*data;		\/* chunk data *\/$/;"	m	struct:pcpu_chunk	file:
dbg_redzone1	./slab.c	/^static unsigned long long *dbg_redzone1(struct kmem_cache *cachep, void *objp)$/;"	f	file:
dbg_redzone1	./slab.c	383;"	d	file:
dbg_redzone2	./slab.c	/^static unsigned long long *dbg_redzone2(struct kmem_cache *cachep, void *objp)$/;"	f	file:
dbg_redzone2	./slab.c	384;"	d	file:
dbg_userword	./slab.c	/^static void **dbg_userword(struct kmem_cache *cachep, void *objp)$/;"	f	file:
dbg_userword	./slab.c	385;"	d	file:
deactivate_page	./swap.c	/^void deactivate_page(struct page *page)$/;"	f
deactivate_slab	./slub.c	/^static void deactivate_slab(struct kmem_cache *s, struct page *page,$/;"	f	file:
dead_count	./memcontrol.c	/^	atomic_t	dead_count;$/;"	m	struct:mem_cgroup	file:
debug_cow_attr	./huge_memory.c	/^static struct kobj_attribute debug_cow_attr =$/;"	v	typeref:struct:kobj_attribute	file:
debug_cow_show	./huge_memory.c	/^static ssize_t debug_cow_show(struct kobject *kobj,$/;"	f	file:
debug_cow_store	./huge_memory.c	/^static ssize_t debug_cow_store(struct kobject *kobj,$/;"	f	file:
debug_guardpage_minorder_setup	./page_alloc.c	/^static int __init debug_guardpage_minorder_setup(char *buf)$/;"	f	file:
debugobj_alc_key	./slab.c	/^static struct lock_class_key debugobj_alc_key;$/;"	v	typeref:struct:lock_class_key	file:
debugobj_l3_key	./slab.c	/^static struct lock_class_key debugobj_l3_key;$/;"	v	typeref:struct:lock_class_key	file:
dec_cluster_info_page	./swapfile.c	/^static void dec_cluster_info_page(struct swap_info_struct *p,$/;"	f	file:
dec_mm_counter_fast	./memory.c	160;"	d	file:
dec_mm_counter_fast	./memory.c	174;"	d	file:
dec_slabs_node	./slub.c	/^static inline void dec_slabs_node(struct kmem_cache *s, int node, int objects)$/;"	f	file:
dec_slabs_node	./slub.c	/^static inline void dec_slabs_node(struct kmem_cache *s, int node,$/;"	f	file:
dec_zone_page_state	./vmstat.c	/^EXPORT_SYMBOL(dec_zone_page_state);$/;"	v
dec_zone_page_state	./vmstat.c	/^void dec_zone_page_state(struct page *page, enum zone_stat_item item)$/;"	f
default_backing_dev_info	./backing-dev.c	/^EXPORT_SYMBOL_GPL(default_backing_dev_info);$/;"	v
default_backing_dev_info	./backing-dev.c	/^struct backing_dev_info default_backing_dev_info = {$/;"	v	typeref:struct:backing_dev_info
default_bdi_init	./backing-dev.c	/^static int __init default_bdi_init(void)$/;"	f	file:
default_bdi_init	./backing-dev.c	/^subsys_initcall(default_bdi_init);$/;"	v
default_hstate_idx	./hugetlb.c	/^unsigned int default_hstate_idx;$/;"	v
default_hstate_max_huge_pages	./hugetlb.c	/^static unsigned long __initdata default_hstate_max_huge_pages;$/;"	v	file:
default_hstate_size	./hugetlb.c	/^static unsigned long __initdata default_hstate_size;$/;"	v	file:
default_policy	./mempolicy.c	/^static struct mempolicy default_policy = {$/;"	v	typeref:struct:mempolicy	file:
default_zonelist_order	./page_alloc.c	/^static int default_zonelist_order(void)$/;"	f	file:
defrag_attr	./huge_memory.c	/^static struct kobj_attribute defrag_attr =$/;"	v	typeref:struct:kobj_attribute	file:
defrag_show	./huge_memory.c	/^static ssize_t defrag_show(struct kobject *kobj,$/;"	f	file:
defrag_store	./huge_memory.c	/^static ssize_t defrag_store(struct kobject *kobj,$/;"	f	file:
del_total	./swap_state.c	/^	unsigned long del_total;$/;"	m	struct:__anon1	file:
delete_from_lru_cache	./memory-failure.c	/^static int delete_from_lru_cache(struct page *p)$/;"	f	file:
delete_from_page_cache	./filemap.c	/^EXPORT_SYMBOL(delete_from_page_cache);$/;"	v
delete_from_page_cache	./filemap.c	/^void delete_from_page_cache(struct page *page)$/;"	f
delete_from_swap_cache	./swap_state.c	/^void delete_from_swap_cache(struct page *page)$/;"	f
delete_nommu_region	./nommu.c	/^static void delete_nommu_region(struct vm_region *region)$/;"	f	file:
delete_object_full	./kmemleak.c	/^static void delete_object_full(unsigned long ptr)$/;"	f	file:
delete_object_part	./kmemleak.c	/^static void delete_object_part(unsigned long ptr, size_t size)$/;"	f	file:
delete_vma	./nommu.c	/^static void delete_vma(struct mm_struct *mm, struct vm_area_struct *vma)$/;"	f	file:
delete_vma_from_mm	./nommu.c	/^static void delete_vma_from_mm(struct vm_area_struct *vma)$/;"	f	file:
dequeue_huge_page_node	./hugetlb.c	/^static struct page *dequeue_huge_page_node(struct hstate *h, int nid)$/;"	f	file:
dequeue_huge_page_vma	./hugetlb.c	/^static struct page *dequeue_huge_page_vma(struct hstate *h,$/;"	f	file:
dequeue_hwpoisoned_huge_page	./hugetlb.c	/^int dequeue_hwpoisoned_huge_page(struct page *hpage)$/;"	f
destroy_by_rcu	./slub.c	/^SLAB_ATTR_RO(destroy_by_rcu);$/;"	v
destroy_by_rcu_show	./slub.c	/^static ssize_t destroy_by_rcu_show(struct kmem_cache *s, char *buf)$/;"	f	file:
destroy_compound_page	./page_alloc.c	/^static int destroy_compound_page(struct page *page, unsigned long order)$/;"	f	file:
destroy_swap_extents	./swapfile.c	/^static void destroy_swap_extents(struct swap_info_struct *sis)$/;"	f	file:
detach_vmas_to_be_unmapped	./mmap.c	/^detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
determine_vm_flags	./nommu.c	/^static unsigned long determine_vm_flags(struct file *file,$/;"	f	file:
dev	./dmapool.c	/^	struct device *dev;$/;"	m	struct:dma_pool	typeref:struct:dma_pool::device	file:
dirty	./memory-failure.c	743;"	d	file:
dirty	./memory-failure.c	800;"	d	file:
dirty	./vmalloc.c	/^	unsigned long free, dirty;$/;"	m	struct:vmap_block	file:
dirty_background_bytes	./page-writeback.c	/^unsigned long dirty_background_bytes;$/;"	v
dirty_background_bytes_handler	./page-writeback.c	/^int dirty_background_bytes_handler(struct ctl_table *table, int write,$/;"	f
dirty_background_ratio	./page-writeback.c	/^int dirty_background_ratio = 10;$/;"	v
dirty_background_ratio_handler	./page-writeback.c	/^int dirty_background_ratio_handler(struct ctl_table *table, int write,$/;"	f
dirty_bytes_handler	./page-writeback.c	/^int dirty_bytes_handler(struct ctl_table *table, int write,$/;"	f
dirty_expire_interval	./page-writeback.c	/^unsigned int dirty_expire_interval = 30 * 100; \/* centiseconds *\/$/;"	v
dirty_freerun_ceiling	./page-writeback.c	/^static unsigned long dirty_freerun_ceiling(unsigned long thresh,$/;"	f	file:
dirty_poll_interval	./page-writeback.c	/^static unsigned long dirty_poll_interval(unsigned long dirty,$/;"	f	file:
dirty_ratio_handler	./page-writeback.c	/^int dirty_ratio_handler(struct ctl_table *table, int write,$/;"	f
dirty_writeback_centisecs_handler	./page-writeback.c	/^int dirty_writeback_centisecs_handler(ctl_table *table, int write,$/;"	f
dirty_writeback_interval	./page-writeback.c	/^EXPORT_SYMBOL_GPL(dirty_writeback_interval);$/;"	v
dirty_writeback_interval	./page-writeback.c	/^unsigned int dirty_writeback_interval = 5 * 100; \/* centiseconds *\/$/;"	v
disable_higher_order_debug	./slub.c	/^static int disable_higher_order_debug;$/;"	v	file:
disable_higher_order_debug	./slub.c	1276;"	d	file:
disable_randmaps	./memory.c	/^static int __init disable_randmaps(char *s)$/;"	f	file:
disarm_kmem_keys	./memcontrol.c	/^static void disarm_kmem_keys(struct mem_cgroup *memcg)$/;"	f	file:
disarm_sock_keys	./memcontrol.c	/^static void disarm_sock_keys(struct mem_cgroup *memcg)$/;"	f	file:
disarm_static_keys	./memcontrol.c	/^static void disarm_static_keys(struct mem_cgroup *memcg)$/;"	f	file:
discard_slab	./slub.c	/^static void discard_slab(struct kmem_cache *s, struct page *page)$/;"	f	file:
discard_swap	./swapfile.c	/^static int discard_swap(struct swap_info_struct *si)$/;"	f	file:
discard_swap_cluster	./swapfile.c	/^static void discard_swap_cluster(struct swap_info_struct *si,$/;"	f	file:
dissolve_free_huge_page	./hugetlb.c	/^static void dissolve_free_huge_page(struct page *page)$/;"	f	file:
dissolve_free_huge_pages	./hugetlb.c	/^void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)$/;"	f
dma	./dmapool.c	/^	dma_addr_t dma;$/;"	m	struct:dma_page	file:
dma_page	./dmapool.c	/^struct dma_page {		\/* cacheable header for 'allocation' bytes *\/$/;"	s	file:
dma_pool	./dmapool.c	/^struct dma_pool {		\/* the pool *\/$/;"	s	file:
dma_pool_alloc	./dmapool.c	/^EXPORT_SYMBOL(dma_pool_alloc);$/;"	v
dma_pool_alloc	./dmapool.c	/^void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,$/;"	f
dma_pool_create	./dmapool.c	/^EXPORT_SYMBOL(dma_pool_create);$/;"	v
dma_pool_create	./dmapool.c	/^struct dma_pool *dma_pool_create(const char *name, struct device *dev,$/;"	f
dma_pool_destroy	./dmapool.c	/^EXPORT_SYMBOL(dma_pool_destroy);$/;"	v
dma_pool_destroy	./dmapool.c	/^void dma_pool_destroy(struct dma_pool *pool)$/;"	f
dma_pool_free	./dmapool.c	/^EXPORT_SYMBOL(dma_pool_free);$/;"	v
dma_pool_free	./dmapool.c	/^void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t dma)$/;"	f
dma_reserve	./page_alloc.c	/^static unsigned long __meminitdata dma_reserve;$/;"	v	file:
dmam_pool_create	./dmapool.c	/^EXPORT_SYMBOL(dmam_pool_create);$/;"	v
dmam_pool_create	./dmapool.c	/^struct dma_pool *dmam_pool_create(const char *name, struct device *dev,$/;"	f
dmam_pool_destroy	./dmapool.c	/^EXPORT_SYMBOL(dmam_pool_destroy);$/;"	v
dmam_pool_destroy	./dmapool.c	/^void dmam_pool_destroy(struct dma_pool *pool)$/;"	f
dmam_pool_match	./dmapool.c	/^static int dmam_pool_match(struct device *dev, void *res, void *match_data)$/;"	f	file:
dmam_pool_release	./dmapool.c	/^static void dmam_pool_release(struct device *dev, void *res)$/;"	f	file:
do_anonymous_page	./memory.c	/^static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_async_mmap_readahead	./filemap.c	/^static void do_async_mmap_readahead(struct vm_area_struct *vma,$/;"	f	file:
do_brk	./mmap.c	/^static unsigned long do_brk(unsigned long addr, unsigned long len)$/;"	f	file:
do_ccupdate_local	./slab.c	/^static void do_ccupdate_local(void *info)$/;"	f	file:
do_cow_fault	./memory.c	/^static int do_cow_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_drain	./slab.c	/^static void do_drain(void *arg)$/;"	f	file:
do_fault_around	./memory.c	/^static void do_fault_around(struct vm_area_struct *vma, unsigned long address,$/;"	f	file:
do_generic_file_read	./filemap.c	/^static ssize_t do_generic_file_read(struct file *filp, loff_t *ppos,$/;"	f	file:
do_get_mempolicy	./mempolicy.c	/^static long do_get_mempolicy(int *policy, nodemask_t *nmask,$/;"	f	file:
do_huge_pmd_anonymous_page	./huge_memory.c	/^int do_huge_pmd_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
do_huge_pmd_numa_page	./huge_memory.c	/^int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
do_huge_pmd_wp_page	./huge_memory.c	/^int do_huge_pmd_wp_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
do_huge_pmd_wp_page_fallback	./huge_memory.c	/^static int do_huge_pmd_wp_page_fallback(struct mm_struct *mm,$/;"	f	file:
do_invalidatepage	./truncate.c	/^void do_invalidatepage(struct page *page, unsigned int offset,$/;"	f
do_kmem_cache_create	./slab_common.c	/^do_kmem_cache_create(char *name, size_t object_size, size_t size, size_t align,$/;"	f	file:
do_launder_page	./truncate.c	/^static int do_launder_page(struct address_space *mapping, struct page *page)$/;"	f	file:
do_linear_fault	./memory.c	/^static int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_mbind	./mempolicy.c	/^static long do_mbind(unsigned long start, unsigned long len,$/;"	f	file:
do_migrate_pages	./mempolicy.c	/^int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,$/;"	f
do_migrate_range	./memory_hotplug.c	/^do_migrate_range(unsigned long start_pfn, unsigned long end_pfn)$/;"	f	file:
do_mincore	./mincore.c	/^static long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)$/;"	f	file:
do_mlock	./mlock.c	/^static int do_mlock(unsigned long start, size_t len, int on)$/;"	f	file:
do_mlockall	./mlock.c	/^static int do_mlockall(int flags)$/;"	f	file:
do_mmap_pgoff	./mmap.c	/^unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,$/;"	f
do_mmap_pgoff	./nommu.c	/^unsigned long do_mmap_pgoff(struct file *file,$/;"	f
do_mmap_private	./nommu.c	/^static int do_mmap_private(struct vm_area_struct *vma,$/;"	f	file:
do_mmap_shared_file	./nommu.c	/^static int do_mmap_shared_file(struct vm_area_struct *vma)$/;"	f	file:
do_mmu_notifier_register	./mmu_notifier.c	/^static int do_mmu_notifier_register(struct mmu_notifier *mn,$/;"	f	file:
do_move_page_to_node_array	./migrate.c	/^static int do_move_page_to_node_array(struct mm_struct *mm,$/;"	f	file:
do_mremap	./nommu.c	/^static unsigned long do_mremap(unsigned long addr,$/;"	f	file:
do_munmap	./mmap.c	/^int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)$/;"	f
do_munmap	./nommu.c	/^EXPORT_SYMBOL(do_munmap);$/;"	v
do_munmap	./nommu.c	/^int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)$/;"	f
do_nonlinear_fault	./memory.c	/^static int do_nonlinear_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_numa_page	./memory.c	/^static int do_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_page_add_anon_rmap	./rmap.c	/^void do_page_add_anon_rmap(struct page *page,$/;"	f
do_page_mkwrite	./memory.c	/^static int do_page_mkwrite(struct vm_area_struct *vma, struct page *page,$/;"	f	file:
do_pages_move	./migrate.c	/^static int do_pages_move(struct mm_struct *mm, nodemask_t task_nodes,$/;"	f	file:
do_pages_stat	./migrate.c	/^static int do_pages_stat(struct mm_struct *mm, unsigned long nr_pages,$/;"	f	file:
do_pages_stat_array	./migrate.c	/^static void do_pages_stat_array(struct mm_struct *mm, unsigned long nr_pages,$/;"	f	file:
do_pos_area_fault	./pos.c	/^EXPORT_SYMBOL(do_pos_area_fault);$/;"	v
do_pos_area_fault	./pos.c	/^int do_pos_area_fault(struct mm_struct *mm, struct vm_area_struct *vma, $/;"	f
do_pos_section_fault	./pos.c	/^EXPORT_SYMBOL(do_pos_section_fault);$/;"	v
do_pos_section_fault	./pos.c	/^int do_pos_section_fault(struct mm_struct *mm, struct vm_area_struct *vma, $/;"	f
do_read_cache_page	./filemap.c	/^static struct page *do_read_cache_page(struct address_space *mapping,$/;"	f	file:
do_read_fault	./memory.c	/^static int do_read_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_readahead	./readahead.c	/^do_readahead(struct address_space *mapping, struct file *filp,$/;"	f	file:
do_set_mempolicy	./mempolicy.c	/^static long do_set_mempolicy(unsigned short mode, unsigned short flags,$/;"	f	file:
do_set_pte	./memory.c	/^void do_set_pte(struct vm_area_struct *vma, unsigned long address,$/;"	f
do_shared_fault	./memory.c	/^static int do_shared_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_swap_account	./memcontrol.c	87;"	d	file:
do_swap_page	./memory.c	/^static int do_swap_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
do_sync_mmap_readahead	./filemap.c	/^static void do_sync_mmap_readahead(struct vm_area_struct *vma,$/;"	f	file:
do_try_to_free_pages	./vmscan.c	/^static unsigned long do_try_to_free_pages(struct zonelist *zonelist,$/;"	f	file:
do_tune_cpucache	./slab.c	/^static int do_tune_cpucache(struct kmem_cache *cachep, int limit,$/;"	f	file:
do_writepages	./page-writeback.c	/^int do_writepages(struct address_space *mapping, struct writeback_control *wbc)$/;"	f
do_xip_mapping_read	./filemap_xip.c	/^do_xip_mapping_read(struct address_space *mapping,$/;"	f	file:
double_flag_show	./huge_memory.c	/^static ssize_t double_flag_show(struct kobject *kobj,$/;"	f	file:
double_flag_store	./huge_memory.c	/^static ssize_t double_flag_store(struct kobject *kobj,$/;"	f	file:
drain_alien_cache	./slab.c	/^static void drain_alien_cache(struct kmem_cache *cachep,$/;"	f	file:
drain_alien_cache	./slab.c	909;"	d	file:
drain_all_pages	./page_alloc.c	/^void drain_all_pages(void)$/;"	f
drain_all_stock	./memcontrol.c	/^static void drain_all_stock(struct mem_cgroup *root_memcg, bool sync)$/;"	f	file:
drain_all_stock_async	./memcontrol.c	/^static void drain_all_stock_async(struct mem_cgroup *root_memcg)$/;"	f	file:
drain_all_stock_sync	./memcontrol.c	/^static void drain_all_stock_sync(struct mem_cgroup *root_memcg)$/;"	f	file:
drain_array	./slab.c	/^static void drain_array(struct kmem_cache *cachep, struct kmem_cache_node *n,$/;"	f	file:
drain_cache_node_node	./slab.c	/^static int __meminit drain_cache_node_node(int node)$/;"	f	file:
drain_cpu_caches	./slab.c	/^static void drain_cpu_caches(struct kmem_cache *cachep)$/;"	f	file:
drain_freelist	./slab.c	/^static int drain_freelist(struct kmem_cache *cache,$/;"	f	file:
drain_local_pages	./page_alloc.c	/^void drain_local_pages(void *arg)$/;"	f
drain_local_stock	./memcontrol.c	/^static void drain_local_stock(struct work_struct *dummy)$/;"	f	file:
drain_mmlist	./swapfile.c	/^static void drain_mmlist(void)$/;"	f	file:
drain_pages	./page_alloc.c	/^static void drain_pages(unsigned int cpu)$/;"	f	file:
drain_stock	./memcontrol.c	/^static void drain_stock(struct memcg_stock_pcp *stock)$/;"	f	file:
drain_zone_pages	./page_alloc.c	/^void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp)$/;"	f
drain_zonestat	./vmstat.c	/^void drain_zonestat(struct zone *zone, struct per_cpu_pageset *pset)$/;"	f
dump_header	./oom_kill.c	/^static void dump_header(struct task_struct *p, gfp_t gfp_mask, int order,$/;"	f	file:
dump_line	./slab.c	/^static void dump_line(char *data, int offset, int limit)$/;"	f	file:
dump_object_info	./kmemleak.c	/^static void dump_object_info(struct kmemleak_object *object)$/;"	f	file:
dump_page	./page_alloc.c	/^EXPORT_SYMBOL(dump_page);$/;"	v
dump_page	./page_alloc.c	/^void dump_page(struct page *page, const char *reason)$/;"	f
dump_page_badflags	./page_alloc.c	/^void dump_page_badflags(struct page *page, const char *reason,$/;"	f
dump_page_flags	./page_alloc.c	/^static void dump_page_flags(unsigned long flags)$/;"	f	file:
dump_str_object_info	./kmemleak.c	/^static int dump_str_object_info(const char *str)$/;"	f	file:
dump_tasks	./oom_kill.c	/^static void dump_tasks(const struct mem_cgroup *memcg, const nodemask_t *nodemask)$/;"	f	file:
early_alloc	./kmemleak.c	/^static void early_alloc(struct early_log *log)$/;"	f	file:
early_alloc_percpu	./kmemleak.c	/^static void early_alloc_percpu(struct early_log *log)$/;"	f	file:
early_calculate_totalpages	./page_alloc.c	/^static unsigned long __init early_calculate_totalpages(void)$/;"	f	file:
early_ioremap	./early_ioremap.c	/^early_ioremap(resource_size_t phys_addr, unsigned long size)$/;"	f
early_ioremap_debug_setup	./early_ioremap.c	/^static int __init early_ioremap_debug_setup(char *str)$/;"	f	file:
early_ioremap_reset	./early_ioremap.c	/^void __init early_ioremap_reset(void)$/;"	f
early_ioremap_setup	./early_ioremap.c	/^void __init early_ioremap_setup(void)$/;"	f
early_ioremap_shutdown	./early_ioremap.c	/^void __init __weak early_ioremap_shutdown(void)$/;"	f
early_iounmap	./early_ioremap.c	/^void __init early_iounmap(void __iomem *addr, unsigned long size)$/;"	f
early_kmem_cache_node_alloc	./slub.c	/^static void early_kmem_cache_node_alloc(int node)$/;"	f	file:
early_log	./kmemleak.c	/^struct early_log {$/;"	s	file:
early_memblock	./memblock.c	/^static int __init early_memblock(char *p)$/;"	f	file:
early_memremap	./early_ioremap.c	/^early_memremap(resource_size_t phys_addr, unsigned long size)$/;"	f
early_memunmap	./early_ioremap.c	/^void __init early_memunmap(void *addr, unsigned long size)$/;"	f
early_pfn_in_nid	./page_alloc.c	/^bool __meminit early_pfn_in_nid(unsigned long pfn, int node)$/;"	f
early_pfn_to_nid	./page_alloc.c	/^int __meminit early_pfn_to_nid(unsigned long pfn)$/;"	f
efd	./vmpressure.c	/^	struct eventfd_ctx *efd;$/;"	m	struct:vmpressure_event	typeref:struct:vmpressure_event::eventfd_ctx	file:
enable_cpucache	./slab.c	/^static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)$/;"	f	file:
enable_swap_account	./memcontrol.c	/^static int __init enable_swap_account(char *s)$/;"	f	file:
enable_swap_cgroup	./memcontrol.c	/^static void __init enable_swap_cgroup(void)$/;"	f	file:
enable_swap_info	./swapfile.c	/^static void enable_swap_info(struct swap_info_struct *p, int prio,$/;"	f	file:
enabled_attr	./huge_memory.c	/^static struct kobj_attribute enabled_attr =$/;"	v	typeref:struct:kobj_attribute	file:
enabled_show	./huge_memory.c	/^static ssize_t enabled_show(struct kobject *kobj,$/;"	f	file:
enabled_store	./huge_memory.c	/^static ssize_t enabled_store(struct kobject *kobj,$/;"	f	file:
encode_handle	./zbud.c	/^static unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)$/;"	f	file:
end_page_writeback	./filemap.c	/^EXPORT_SYMBOL(end_page_writeback);$/;"	v
end_page_writeback	./filemap.c	/^void end_page_writeback(struct page *page)$/;"	f
end_swap_bio_read	./page_io.c	/^void end_swap_bio_read(struct bio *bio, int err)$/;"	f
end_swap_bio_write	./page_io.c	/^void end_swap_bio_write(struct bio *bio, int err)$/;"	f
enqueue_huge_page	./hugetlb.c	/^static void enqueue_huge_page(struct hstate *h, struct page *page)$/;"	f	file:
ensure_zone_is_initialized	./memory_hotplug.c	/^static int __ref ensure_zone_is_initialized(struct zone *zone,$/;"	f	file:
ent	./memcontrol.c	/^	swp_entry_t	ent;$/;"	m	union:mc_target	file:
entries	./memcontrol.c	/^	struct mem_cgroup_threshold entries[0];$/;"	m	struct:mem_cgroup_threshold_ary	typeref:struct:mem_cgroup_threshold_ary::mem_cgroup_threshold	file:
entries	./slab.c	/^	void *entries[BOOT_CPUCACHE_ENTRIES];$/;"	m	struct:arraycache_init	file:
entry	./slab.c	/^	void *entry[];	\/*$/;"	m	struct:array_cache	file:
error_states	./memory-failure.c	/^} error_states[] = {$/;"	v	typeref:struct:page_state	file:
event_list	./memcontrol.c	/^	struct list_head event_list;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::list_head	file:
event_list_lock	./memcontrol.c	/^	spinlock_t event_list_lock;$/;"	m	struct:mem_cgroup	file:
eventfd	./memcontrol.c	/^	struct eventfd_ctx *eventfd;$/;"	m	struct:mem_cgroup_event	typeref:struct:mem_cgroup_event::eventfd_ctx	file:
eventfd	./memcontrol.c	/^	struct eventfd_ctx *eventfd;$/;"	m	struct:mem_cgroup_eventfd_list	typeref:struct:mem_cgroup_eventfd_list::eventfd_ctx	file:
eventfd	./memcontrol.c	/^	struct eventfd_ctx *eventfd;$/;"	m	struct:mem_cgroup_threshold	typeref:struct:mem_cgroup_threshold::eventfd_ctx	file:
events	./memcontrol.c	/^	unsigned long events[MEM_CGROUP_EVENTS_NSTATS];$/;"	m	struct:mem_cgroup_stat_cpu	file:
exit_mmap	./mmap.c	/^void exit_mmap(struct mm_struct *mm)$/;"	f
exit_mmap	./nommu.c	/^void exit_mmap(struct mm_struct *mm)$/;"	f
exit_zbud	./zbud.c	/^module_exit(exit_zbud);$/;"	v
exit_zbud	./zbud.c	/^static void __exit exit_zbud(void)$/;"	f	file:
expand	./page_alloc.c	/^static inline void expand(struct zone *zone, struct page *page,$/;"	f	file:
expand_downwards	./mmap.c	/^int expand_downwards(struct vm_area_struct *vma,$/;"	f
expand_stack	./mmap.c	/^int expand_stack(struct vm_area_struct *vma, unsigned long address)$/;"	f
expand_stack	./nommu.c	/^int expand_stack(struct vm_area_struct *vma, unsigned long address)$/;"	f
expand_upwards	./mmap.c	/^int expand_upwards(struct vm_area_struct *vma, unsigned long address)$/;"	f
extfrag_debug_init	./vmstat.c	/^module_init(extfrag_debug_init);$/;"	v
extfrag_debug_init	./vmstat.c	/^static int __init extfrag_debug_init(void)$/;"	f	file:
extfrag_file_ops	./vmstat.c	/^static const struct file_operations extfrag_file_ops = {$/;"	v	typeref:struct:file_operations	file:
extfrag_op	./vmstat.c	/^static const struct seq_operations extfrag_op = {$/;"	v	typeref:struct:seq_operations	file:
extfrag_open	./vmstat.c	/^static int extfrag_open(struct inode *inode, struct file *file)$/;"	f	file:
extfrag_show	./vmstat.c	/^static int extfrag_show(struct seq_file *m, void *arg)$/;"	f	file:
extfrag_show_print	./vmstat.c	/^static void extfrag_show_print(struct seq_file *m,$/;"	f	file:
f	./vmalloc.c	/^static int f(pte_t *pte, pgtable_t table, unsigned long addr, void *data)$/;"	f	file:
fail_page_alloc	./page_alloc.c	/^} fail_page_alloc = {$/;"	v	typeref:struct:__anon2	file:
fail_page_alloc_debugfs	./page_alloc.c	/^late_initcall(fail_page_alloc_debugfs);$/;"	v
fail_page_alloc_debugfs	./page_alloc.c	/^static int __init fail_page_alloc_debugfs(void)$/;"	f	file:
failslab	./failslab.c	/^} failslab = {$/;"	v	typeref:struct:__anon12	file:
failslab	./slub.c	/^SLAB_ATTR(failslab);$/;"	v
failslab_debugfs_init	./failslab.c	/^late_initcall(failslab_debugfs_init);$/;"	v
failslab_debugfs_init	./failslab.c	/^static int __init failslab_debugfs_init(void)$/;"	f	file:
failslab_show	./slub.c	/^static ssize_t failslab_show(struct kmem_cache *s, char *buf)$/;"	f	file:
failslab_store	./slub.c	/^static ssize_t failslab_store(struct kmem_cache *s, const char *buf,$/;"	f	file:
fallback_alloc	./slab.c	/^static void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)$/;"	f	file:
fallback_migrate_page	./migrate.c	/^static int fallback_migrate_page(struct address_space *mapping,$/;"	f	file:
fallbacks	./page_alloc.c	/^static int fallbacks[MIGRATE_TYPES][4] = {$/;"	v	file:
fault_around_debugfs	./memory.c	/^late_initcall(fault_around_debugfs);$/;"	v
fault_around_debugfs	./memory.c	/^static int __init fault_around_debugfs(void)$/;"	f	file:
fault_around_mask	./memory.c	/^static inline unsigned long fault_around_mask(void)$/;"	f	file:
fault_around_order	./memory.c	/^static unsigned int fault_around_order = FAULT_AROUND_ORDER;$/;"	v	file:
fault_around_order_get	./memory.c	/^static int fault_around_order_get(void *data, u64 *val)$/;"	f	file:
fault_around_order_set	./memory.c	/^static int fault_around_order_set(void *data, u64 val)$/;"	f	file:
fault_around_pages	./memory.c	/^static inline unsigned long fault_around_pages(void)$/;"	f	file:
fault_mutex_hash	./hugetlb.c	/^static u32 fault_mutex_hash(struct hstate *h, struct mm_struct *mm,$/;"	f	file:
fd	./mmap.c	/^	unsigned long fd;$/;"	m	struct:mmap_arg_struct	file:
fd	./nommu.c	/^	unsigned long fd;$/;"	m	struct:mmap_arg_struct	file:
file_ra_state_init	./readahead.c	/^EXPORT_SYMBOL_GPL(file_ra_state_init);$/;"	v
file_ra_state_init	./readahead.c	/^file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping)$/;"	f
file_region	./hugetlb.c	/^struct file_region {$/;"	s	file:
filemap_check_errors	./filemap.c	/^static int filemap_check_errors(struct address_space *mapping)$/;"	f	file:
filemap_fault	./filemap.c	/^EXPORT_SYMBOL(filemap_fault);$/;"	v
filemap_fault	./filemap.c	/^int filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f
filemap_fault	./nommu.c	/^EXPORT_SYMBOL(filemap_fault);$/;"	v
filemap_fault	./nommu.c	/^int filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f
filemap_fdatawait	./filemap.c	/^EXPORT_SYMBOL(filemap_fdatawait);$/;"	v
filemap_fdatawait	./filemap.c	/^int filemap_fdatawait(struct address_space *mapping)$/;"	f
filemap_fdatawait_range	./filemap.c	/^EXPORT_SYMBOL(filemap_fdatawait_range);$/;"	v
filemap_fdatawait_range	./filemap.c	/^int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,$/;"	f
filemap_fdatawrite	./filemap.c	/^EXPORT_SYMBOL(filemap_fdatawrite);$/;"	v
filemap_fdatawrite	./filemap.c	/^int filemap_fdatawrite(struct address_space *mapping)$/;"	f
filemap_fdatawrite_range	./filemap.c	/^EXPORT_SYMBOL(filemap_fdatawrite_range);$/;"	v
filemap_fdatawrite_range	./filemap.c	/^int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,$/;"	f
filemap_flush	./filemap.c	/^EXPORT_SYMBOL(filemap_flush);$/;"	v
filemap_flush	./filemap.c	/^int filemap_flush(struct address_space *mapping)$/;"	f
filemap_map_pages	./filemap.c	/^EXPORT_SYMBOL(filemap_map_pages);$/;"	v
filemap_map_pages	./filemap.c	/^void filemap_map_pages(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f
filemap_map_pages	./nommu.c	/^EXPORT_SYMBOL(filemap_map_pages);$/;"	v
filemap_map_pages	./nommu.c	/^void filemap_map_pages(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f
filemap_page_mkwrite	./filemap.c	/^EXPORT_SYMBOL(filemap_page_mkwrite);$/;"	v
filemap_page_mkwrite	./filemap.c	/^int filemap_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f
filemap_write_and_wait	./filemap.c	/^EXPORT_SYMBOL(filemap_write_and_wait);$/;"	v
filemap_write_and_wait	./filemap.c	/^int filemap_write_and_wait(struct address_space *mapping)$/;"	f
filemap_write_and_wait_range	./filemap.c	/^EXPORT_SYMBOL(filemap_write_and_wait_range);$/;"	v
filemap_write_and_wait_range	./filemap.c	/^int filemap_write_and_wait_range(struct address_space *mapping,$/;"	f
fill_contig_page_info	./vmstat.c	/^static void fill_contig_page_info(struct zone *zone,$/;"	f	file:
find_and_get_object	./kmemleak.c	/^static struct kmemleak_object *find_and_get_object(unsigned long ptr, int alias)$/;"	f	file:
find_biggest_section_pfn	./memory_hotplug.c	/^static int find_biggest_section_pfn(int nid, struct zone *zone,$/;"	f	file:
find_extend_vma	./mmap.c	/^find_extend_vma(struct mm_struct * mm, unsigned long addr)$/;"	f
find_extend_vma	./mmap.c	/^find_extend_vma(struct mm_struct *mm, unsigned long addr)$/;"	f
find_extend_vma	./nommu.c	/^struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)$/;"	f
find_get_entries	./filemap.c	/^unsigned find_get_entries(struct address_space *mapping,$/;"	f
find_get_entry	./filemap.c	/^EXPORT_SYMBOL(find_get_entry);$/;"	v
find_get_entry	./filemap.c	/^struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)$/;"	f
find_get_page	./filemap.c	/^EXPORT_SYMBOL(find_get_page);$/;"	v
find_get_page	./filemap.c	/^struct page *find_get_page(struct address_space *mapping, pgoff_t offset)$/;"	f
find_get_pages	./filemap.c	/^unsigned find_get_pages(struct address_space *mapping, pgoff_t start,$/;"	f
find_get_pages_contig	./filemap.c	/^EXPORT_SYMBOL(find_get_pages_contig);$/;"	v
find_get_pages_contig	./filemap.c	/^unsigned find_get_pages_contig(struct address_space *mapping, pgoff_t index,$/;"	f
find_get_pages_tag	./filemap.c	/^EXPORT_SYMBOL(find_get_pages_tag);$/;"	v
find_get_pages_tag	./filemap.c	/^unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,$/;"	f
find_get_zspage	./zsmalloc.c	/^static struct page *find_get_zspage(struct size_class *class)$/;"	f	file:
find_lock_entry	./filemap.c	/^EXPORT_SYMBOL(find_lock_entry);$/;"	v
find_lock_entry	./filemap.c	/^struct page *find_lock_entry(struct address_space *mapping, pgoff_t offset)$/;"	f
find_lock_page	./filemap.c	/^EXPORT_SYMBOL(find_lock_page);$/;"	v
find_lock_page	./filemap.c	/^struct page *find_lock_page(struct address_space *mapping, pgoff_t offset)$/;"	f
find_lock_task_mm	./oom_kill.c	/^struct task_struct *find_lock_task_mm(struct task_struct *p)$/;"	f
find_mergeable	./slub.c	/^static struct kmem_cache *find_mergeable(size_t size, size_t align,$/;"	f	file:
find_mergeable_anon_vma	./mmap.c	/^struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)$/;"	f
find_mergeable_vma	./ksm.c	/^static struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,$/;"	f	file:
find_min_pfn_for_node	./page_alloc.c	/^static unsigned long __init find_min_pfn_for_node(int nid)$/;"	f	file:
find_min_pfn_with_active_regions	./page_alloc.c	/^unsigned long __init find_min_pfn_with_active_regions(void)$/;"	f
find_next_best_node	./page_alloc.c	/^static int find_next_best_node(int node, nodemask_t *used_node_mask)$/;"	f	file:
find_next_to_unuse	./swapfile.c	/^static unsigned int find_next_to_unuse(struct swap_info_struct *si,$/;"	f	file:
find_or_create_page	./filemap.c	/^EXPORT_SYMBOL(find_or_create_page);$/;"	v
find_or_create_page	./filemap.c	/^struct page *find_or_create_page(struct address_space *mapping,$/;"	f
find_smallest_section_pfn	./memory_hotplug.c	/^static int find_smallest_section_pfn(int nid, struct zone *zone,$/;"	f	file:
find_success	./swap_state.c	/^	unsigned long find_success;$/;"	m	struct:__anon1	file:
find_total	./swap_state.c	/^	unsigned long find_total;$/;"	m	struct:__anon1	file:
find_usable_zone_for_movable	./page_alloc.c	/^static void __init find_usable_zone_for_movable(void)$/;"	f	file:
find_vm_area	./vmalloc.c	/^struct vm_struct *find_vm_area(const void *addr)$/;"	f
find_vma	./mmap.c	/^EXPORT_SYMBOL(find_vma);$/;"	v
find_vma	./mmap.c	/^struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)$/;"	f
find_vma	./nommu.c	/^EXPORT_SYMBOL(find_vma);$/;"	v
find_vma	./nommu.c	/^struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)$/;"	f
find_vma_exact	./nommu.c	/^static struct vm_area_struct *find_vma_exact(struct mm_struct *mm,$/;"	f	file:
find_vma_links	./mmap.c	/^static int find_vma_links(struct mm_struct *mm, unsigned long addr,$/;"	f	file:
find_vma_prev	./mmap.c	/^find_vma_prev(struct mm_struct *mm, unsigned long addr,$/;"	f
find_vmap_area	./vmalloc.c	/^static struct vmap_area *find_vmap_area(unsigned long addr)$/;"	f	file:
find_zone_movable_pfns_for_nodes	./page_alloc.c	/^static void __init find_zone_movable_pfns_for_nodes(void)$/;"	f	file:
finished_update_free	./internal.h	/^	bool finished_update_free;	\/* True when the zone cached pfns are$/;"	m	struct:compact_control
finished_update_migrate	./internal.h	/^	bool finished_update_migrate;$/;"	m	struct:compact_control
first_chunks	./zbud.c	/^	unsigned int first_chunks;$/;"	m	struct:zbud_header	file:
first_free	./percpu.c	/^	int			first_free;	\/* no free below this *\/$/;"	m	struct:pcpu_chunk	file:
first_online_pgdat	./mmzone.c	/^struct pglist_data *first_online_pgdat(void)$/;"	f
fix_fullness_group	./zsmalloc.c	/^static enum fullness_group fix_fullness_group(struct zs_pool *pool,$/;"	f	file:
fix_zone_id	./memory_hotplug.c	/^static void fix_zone_id(struct zone *zone, unsigned long start_pfn,$/;"	f	file:
fixup_user_fault	./memory.c	/^int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,$/;"	f
flags	./kmemleak.c	/^	unsigned long flags;		\/* object status flags *\/$/;"	m	struct:kmemleak_object	file:
flags	./memcontrol.c	/^	unsigned long flags;$/;"	m	struct:memcg_stock_pcp	file:
flags	./memory-failure.c	/^	int flags;$/;"	m	struct:memory_failure_entry	file:
flags	./mmap.c	/^	unsigned long flags;$/;"	m	struct:mmap_arg_struct	file:
flags	./nommu.c	/^	unsigned long flags;$/;"	m	struct:mmap_arg_struct	file:
flags	./zsmalloc.c	/^	gfp_t flags;	\/* allocation flags used when growing pool *\/$/;"	m	struct:zs_pool	file:
flush_all	./slub.c	/^static void flush_all(struct kmem_cache *s)$/;"	f	file:
flush_all_zero_pkmaps	./highmem.c	/^static void flush_all_zero_pkmaps(void)$/;"	f	file:
flush_cpu_slab	./slub.c	/^static void flush_cpu_slab(void *d)$/;"	f	file:
flush_slab	./slub.c	/^static inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)$/;"	f	file:
fold_diff	./vmstat.c	/^static inline void fold_diff(int *diff)$/;"	f	file:
follow_huge_pmd	./hugetlb.c	/^follow_huge_pmd(struct mm_struct *mm, unsigned long address,$/;"	f
follow_huge_pud	./hugetlb.c	/^follow_huge_pud(struct mm_struct *mm, unsigned long address,$/;"	f
follow_hugetlb_page	./hugetlb.c	/^long follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
follow_page_mask	./memory.c	/^struct page *follow_page_mask(struct vm_area_struct *vma,$/;"	f
follow_page_mask	./nommu.c	/^struct page *follow_page_mask(struct vm_area_struct *vma,$/;"	f
follow_pfn	./memory.c	/^EXPORT_SYMBOL(follow_pfn);$/;"	v
follow_pfn	./memory.c	/^int follow_pfn(struct vm_area_struct *vma, unsigned long address,$/;"	f
follow_pfn	./nommu.c	/^EXPORT_SYMBOL(follow_pfn);$/;"	v
follow_pfn	./nommu.c	/^int follow_pfn(struct vm_area_struct *vma, unsigned long address,$/;"	f
follow_phys	./memory.c	/^int follow_phys(struct vm_area_struct *vma,$/;"	f
follow_pte	./memory.c	/^static inline int follow_pte(struct mm_struct *mm, unsigned long address,$/;"	f	file:
follow_trans_huge_pmd	./huge_memory.c	/^struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,$/;"	f
footer	./kmemleak-test.c	/^	long footer[25];$/;"	m	struct:test_node	file:
for_each_mem_cgroup	./memcontrol.c	1308;"	d	file:
for_each_mem_cgroup_tree	./memcontrol.c	1303;"	d	file:
for_each_node_mask_to_alloc	./hugetlb.c	851;"	d	file:
for_each_node_mask_to_free	./hugetlb.c	857;"	d	file:
for_each_object	./slub.c	287;"	d	file:
for_each_unbuddied_list	./zbud.c	130;"	d	file:
force_page_cache_readahead	./readahead.c	/^int force_page_cache_readahead(struct address_space *mapping, struct file *filp,$/;"	f
force_shm_swapin_readahead	./madvise.c	/^static void force_shm_swapin_readahead(struct vm_area_struct *vma,$/;"	f	file:
force_swapin_readahead	./madvise.c	/^static void force_swapin_readahead(struct vm_area_struct *vma,$/;"	f	file:
frag_next	./vmstat.c	/^static void *frag_next(struct seq_file *m, void *arg, loff_t *pos)$/;"	f	file:
frag_show	./vmstat.c	/^static int frag_show(struct seq_file *m, void *arg)$/;"	f	file:
frag_show_print	./vmstat.c	/^static void frag_show_print(struct seq_file *m, pg_data_t *pgdat,$/;"	f	file:
frag_start	./vmstat.c	/^static void *frag_start(struct seq_file *m, loff_t *pos)$/;"	f	file:
frag_stop	./vmstat.c	/^static void frag_stop(struct seq_file *m, void *arg)$/;"	f	file:
fragmentation_file_operations	./vmstat.c	/^static const struct file_operations fragmentation_file_operations = {$/;"	v	typeref:struct:file_operations	file:
fragmentation_index	./vmstat.c	/^int fragmentation_index(struct zone *zone, unsigned int order)$/;"	f
fragmentation_op	./vmstat.c	/^static const struct seq_operations fragmentation_op = {$/;"	v	typeref:struct:seq_operations	file:
fragmentation_open	./vmstat.c	/^static int fragmentation_open(struct inode *inode, struct file *file)$/;"	f	file:
free	./vmalloc.c	/^	struct list_head free;$/;"	m	struct:vmap_block_queue	typeref:struct:vmap_block_queue::list_head	file:
free	./vmalloc.c	/^	unsigned long free, dirty;$/;"	m	struct:vmap_block	file:
free_alien_cache	./slab.c	/^static inline void free_alien_cache(struct array_cache **ac_ptr)$/;"	f	file:
free_alien_cache	./slab.c	/^static void free_alien_cache(struct array_cache **ac_ptr)$/;"	f	file:
free_all_bootmem	./bootmem.c	/^unsigned long __init free_all_bootmem(void)$/;"	f
free_all_bootmem	./nobootmem.c	/^unsigned long __init free_all_bootmem(void)$/;"	f
free_all_bootmem_core	./bootmem.c	/^static unsigned long __init free_all_bootmem_core(bootmem_data_t *bdata)$/;"	f	file:
free_area_init	./page_alloc.c	/^void __init free_area_init(unsigned long *zones_size)$/;"	f
free_area_init_core	./page_alloc.c	/^static void __paginginit free_area_init_core(struct pglist_data *pgdat,$/;"	f	file:
free_area_init_node	./page_alloc.c	/^void __paginginit free_area_init_node(int nid, unsigned long *zones_size,$/;"	f
free_area_init_nodes	./page_alloc.c	/^void __init free_area_init_nodes(unsigned long *max_zone_pfn)$/;"	f
free_block	./slab.c	/^static void free_block(struct kmem_cache *cachep, void **objpp, int nr_objects,$/;"	f	file:
free_blocks_suitable	./vmstat.c	/^	unsigned long free_blocks_suitable;$/;"	m	struct:contig_page_info	file:
free_blocks_total	./vmstat.c	/^	unsigned long free_blocks_total;$/;"	m	struct:contig_page_info	file:
free_bootmem	./bootmem.c	/^void __init free_bootmem(unsigned long physaddr, unsigned long size)$/;"	f
free_bootmem	./nobootmem.c	/^void __init free_bootmem(unsigned long addr, unsigned long size)$/;"	f
free_bootmem_late	./bootmem.c	/^void __init free_bootmem_late(unsigned long physaddr, unsigned long size)$/;"	f
free_bootmem_late	./nobootmem.c	/^void __init free_bootmem_late(unsigned long addr, unsigned long size)$/;"	f
free_bootmem_node	./bootmem.c	/^void __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,$/;"	f
free_bootmem_node	./nobootmem.c	/^void __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,$/;"	f
free_bootmem_with_active_regions	./page_alloc.c	/^void __init free_bootmem_with_active_regions(int nid, unsigned long max_low_pfn)$/;"	f
free_calls	./slub.c	/^SLAB_ATTR_RO(free_calls);$/;"	v
free_calls_show	./slub.c	/^static ssize_t free_calls_show(struct kmem_cache *s, char *buf)$/;"	f	file:
free_compound_page	./page_alloc.c	/^static void free_compound_page(struct page *page)$/;"	f	file:
free_contig_range	./page_alloc.c	/^void free_contig_range(unsigned long pfn, unsigned nr_pages)$/;"	f
free_debug_processing	./slub.c	/^static inline struct kmem_cache_node *free_debug_processing($/;"	f	file:
free_debug_processing	./slub.c	/^static noinline struct kmem_cache_node *free_debug_processing($/;"	f	file:
free_highmem_page	./page_alloc.c	/^void free_highmem_page(struct page *page)$/;"	f
free_hot_cold_page	./page_alloc.c	/^void free_hot_cold_page(struct page *page, int cold)$/;"	f
free_hot_cold_page_list	./page_alloc.c	/^void free_hot_cold_page_list(struct list_head *list, int cold)$/;"	f
free_huge_page	./hugetlb.c	/^static void free_huge_page(struct page *page)$/;"	f	file:
free_hugepages	./hugetlb.c	/^HSTATE_ATTR_RO(free_hugepages);$/;"	v
free_hugepages_show	./hugetlb.c	/^static ssize_t free_hugepages_show(struct kobject *kobj,$/;"	f	file:
free_kmem_cache_nodes	./slub.c	/^static void free_kmem_cache_nodes(struct kmem_cache *s)$/;"	f	file:
free_limit	./slab.h	/^	unsigned int free_limit;$/;"	m	struct:kmem_cache_node
free_list	./vmalloc.c	/^	struct list_head free_list;$/;"	m	struct:vmap_block	typeref:struct:vmap_block::list_head	file:
free_loc_track	./slub.c	/^static void free_loc_track(struct loc_track *t)$/;"	f	file:
free_low_memory_core_early	./nobootmem.c	/^static unsigned long __init free_low_memory_core_early(void)$/;"	f	file:
free_map_bootmem	./sparse.c	/^static void free_map_bootmem(struct page *memmap)$/;"	f	file:
free_mem_cgroup_per_zone_info	./memcontrol.c	/^static void free_mem_cgroup_per_zone_info(struct mem_cgroup *memcg, int node)$/;"	f	file:
free_memcg_kmem_pages	./page_alloc.c	/^void free_memcg_kmem_pages(unsigned long addr, unsigned int order)$/;"	f
free_mm_slot	./huge_memory.c	/^static inline void free_mm_slot(struct mm_slot *mm_slot)$/;"	f	file:
free_mm_slot	./ksm.c	/^static inline void free_mm_slot(struct mm_slot *mm_slot)$/;"	f	file:
free_object_rcu	./kmemleak.c	/^static void free_object_rcu(struct rcu_head *rcu)$/;"	f	file:
free_objects	./slab.h	/^	unsigned long free_objects;$/;"	m	struct:kmem_cache_node
free_one_page	./page_alloc.c	/^static void free_one_page(struct zone *zone, struct page *page, int order,$/;"	f	file:
free_page_and_swap_cache	./swap_state.c	/^void free_page_and_swap_cache(struct page *page)$/;"	f
free_page_cgroup	./page_cgroup.c	/^static void free_page_cgroup(void *addr)$/;"	f	file:
free_page_series	./nommu.c	/^static void free_page_series(unsigned long from, unsigned long to)$/;"	f	file:
free_pages	./page_alloc.c	/^EXPORT_SYMBOL(free_pages);$/;"	v
free_pages	./page_alloc.c	/^void free_pages(unsigned long addr, unsigned int order)$/;"	f
free_pages	./vmstat.c	/^	unsigned long free_pages;$/;"	m	struct:contig_page_info	file:
free_pages_and_swap_cache	./swap_state.c	/^void free_pages_and_swap_cache(struct page **pages, int nr)$/;"	f
free_pages_check	./page_alloc.c	/^static inline int free_pages_check(struct page *page)$/;"	f	file:
free_pages_exact	./page_alloc.c	/^EXPORT_SYMBOL(free_pages_exact);$/;"	v
free_pages_exact	./page_alloc.c	/^void free_pages_exact(void *virt, size_t size)$/;"	f
free_pages_prepare	./page_alloc.c	/^static bool free_pages_prepare(struct page *page, unsigned int order)$/;"	f	file:
free_partial	./slub.c	/^static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)$/;"	f	file:
free_pcppages_bulk	./page_alloc.c	/^static void free_pcppages_bulk(struct zone *zone, int count,$/;"	f	file:
free_percpu	./percpu.c	/^EXPORT_SYMBOL_GPL(free_percpu);$/;"	v
free_percpu	./percpu.c	/^void free_percpu(void __percpu *ptr)$/;"	f
free_pfn	./internal.h	/^	unsigned long free_pfn;		\/* isolate_freepages search base *\/$/;"	m	struct:compact_control
free_pgd_range	./memory.c	/^void free_pgd_range(struct mmu_gather *tlb,$/;"	f
free_pgtables	./memory.c	/^void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,$/;"	f
free_pmd_range	./memory.c	/^static inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,$/;"	f	file:
free_pool_huge_page	./hugetlb.c	/^static int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,$/;"	f	file:
free_pte_range	./memory.c	/^static void free_pte_range(struct mmu_gather *tlb, pmd_t *pmd,$/;"	f	file:
free_pud_range	./memory.c	/^static inline void free_pud_range(struct mmu_gather *tlb, pgd_t *pgd,$/;"	f	file:
free_reserved_area	./page_alloc.c	/^EXPORT_SYMBOL(free_reserved_area);$/;"	v
free_reserved_area	./page_alloc.c	/^unsigned long free_reserved_area(void *start, void *end, int poison, char *s)$/;"	f
free_rmap_item	./ksm.c	/^static inline void free_rmap_item(struct rmap_item *rmap_item)$/;"	f	file:
free_section_usemap	./sparse.c	/^static void free_section_usemap(struct page *memmap, unsigned long *usemap)$/;"	f	file:
free_size	./percpu.c	/^	int			free_size;	\/* free bytes in the chunk *\/$/;"	m	struct:pcpu_chunk	file:
free_slab	./slub.c	/^static void free_slab(struct kmem_cache *s, struct page *page)$/;"	f	file:
free_stable_node	./ksm.c	/^static inline void free_stable_node(struct stable_node *stable_node)$/;"	f	file:
free_swap_and_cache	./swapfile.c	/^int free_swap_and_cache(swp_entry_t entry)$/;"	f
free_swap_cache	./swap_state.c	/^static inline void free_swap_cache(struct page *page)$/;"	f	file:
free_swap_count_continuations	./swapfile.c	/^static void free_swap_count_continuations(struct swap_info_struct *si)$/;"	f	file:
free_touched	./slab.h	/^	int free_touched;		\/* updated without locking *\/$/;"	m	struct:kmem_cache_node
free_unmap_vmap_area	./vmalloc.c	/^static void free_unmap_vmap_area(struct vmap_area *va)$/;"	f	file:
free_unmap_vmap_area_addr	./vmalloc.c	/^static void free_unmap_vmap_area_addr(unsigned long addr)$/;"	f	file:
free_unmap_vmap_area_noflush	./vmalloc.c	/^static void free_unmap_vmap_area_noflush(struct vmap_area *va)$/;"	f	file:
free_vm_area	./nommu.c	/^EXPORT_SYMBOL_GPL(free_vm_area);$/;"	v
free_vm_area	./nommu.c	/^void free_vm_area(struct vm_struct *area)$/;"	f
free_vm_area	./vmalloc.c	/^EXPORT_SYMBOL_GPL(free_vm_area);$/;"	v
free_vm_area	./vmalloc.c	/^void free_vm_area(struct vm_struct *area)$/;"	f
free_vmap_area	./vmalloc.c	/^static void free_vmap_area(struct vmap_area *va)$/;"	f	file:
free_vmap_area_noflush	./vmalloc.c	/^static void free_vmap_area_noflush(struct vmap_area *va)$/;"	f	file:
free_vmap_block	./vmalloc.c	/^static void free_vmap_block(struct vmap_block *vb)$/;"	f	file:
free_vmap_cache	./vmalloc.c	/^static struct rb_node *free_vmap_cache;$/;"	v	typeref:struct:rb_node	file:
free_work	./vmalloc.c	/^static void free_work(struct work_struct *w)$/;"	f	file:
free_zbud_page	./zbud.c	/^static void free_zbud_page(struct zbud_header *zhdr)$/;"	f	file:
free_zspage	./zsmalloc.c	/^static void free_zspage(struct page *first_page)$/;"	f	file:
freelist_idx_t	./slab.c	/^typedef unsigned char freelist_idx_t;$/;"	t	file:
freelist_idx_t	./slab.c	/^typedef unsigned short freelist_idx_t;$/;"	t	file:
freepages	./internal.h	/^	struct list_head freepages;	\/* List of free pages to migrate to *\/$/;"	m	struct:compact_control	typeref:struct:compact_control::list_head
from	./hugetlb.c	/^	long from;$/;"	m	struct:file_region	file:
from	./memcontrol.c	/^	struct mem_cgroup *from;$/;"	m	struct:move_charge_struct	typeref:struct:move_charge_struct::mem_cgroup	file:
frontswap_curr_pages	./frontswap.c	/^EXPORT_SYMBOL(frontswap_curr_pages);$/;"	v
frontswap_curr_pages	./frontswap.c	/^unsigned long frontswap_curr_pages(void)$/;"	f
frontswap_failed_stores	./frontswap.c	/^static u64 frontswap_failed_stores;$/;"	v	file:
frontswap_invalidates	./frontswap.c	/^static u64 frontswap_invalidates;$/;"	v	file:
frontswap_loads	./frontswap.c	/^static u64 frontswap_loads;$/;"	v	file:
frontswap_register_ops	./frontswap.c	/^EXPORT_SYMBOL(frontswap_register_ops);$/;"	v
frontswap_register_ops	./frontswap.c	/^struct frontswap_ops *frontswap_register_ops(struct frontswap_ops *ops)$/;"	f
frontswap_shrink	./frontswap.c	/^EXPORT_SYMBOL(frontswap_shrink);$/;"	v
frontswap_shrink	./frontswap.c	/^void frontswap_shrink(unsigned long target_pages)$/;"	f
frontswap_succ_stores	./frontswap.c	/^static u64 frontswap_succ_stores;$/;"	v	file:
frontswap_tmem_exclusive_gets	./frontswap.c	/^EXPORT_SYMBOL(frontswap_tmem_exclusive_gets);$/;"	v
frontswap_tmem_exclusive_gets	./frontswap.c	/^void frontswap_tmem_exclusive_gets(bool enable)$/;"	f
frontswap_writethrough	./frontswap.c	/^EXPORT_SYMBOL(frontswap_writethrough);$/;"	v
frontswap_writethrough	./frontswap.c	/^void frontswap_writethrough(bool enable)$/;"	f
fs_poolid_map	./cleancache.c	/^static int fs_poolid_map[MAX_INITIALIZABLE_FS];$/;"	v	file:
full	./slab.h	/^	struct list_head full;$/;"	m	struct:kmem_cache_node	typeref:struct:kmem_cache_node::list_head
full_scans	./ksm.c	/^KSM_ATTR_RO(full_scans);$/;"	v
full_scans_attr	./huge_memory.c	/^static struct kobj_attribute full_scans_attr =$/;"	v	typeref:struct:kobj_attribute	file:
full_scans_show	./huge_memory.c	/^static ssize_t full_scans_show(struct kobject *kobj,$/;"	f	file:
full_scans_show	./ksm.c	/^static ssize_t full_scans_show(struct kobject *kobj,$/;"	f	file:
fullness_group	./zsmalloc.c	/^enum fullness_group {$/;"	g	file:
fullness_list	./zsmalloc.c	/^	struct page *fullness_list[_ZS_NR_FULLNESS_GROUPS];$/;"	m	struct:size_class	typeref:struct:size_class::page	file:
fullness_threshold_frac	./zsmalloc.c	/^static const int fullness_threshold_frac = 4;$/;"	v	file:
gate_vma	./memory.c	/^static struct vm_area_struct gate_vma;$/;"	v	typeref:struct:vm_area_struct	file:
gate_vma_init	./memory.c	/^__initcall(gate_vma_init);$/;"	v
gate_vma_init	./memory.c	/^static int __init gate_vma_init(void)$/;"	f	file:
gather_bootmem_prealloc	./hugetlb.c	/^static void __init gather_bootmem_prealloc(void)$/;"	f	file:
gather_surplus_pages	./hugetlb.c	/^static int gather_surplus_pages(struct hstate *h, int delta)$/;"	f	file:
generation	./memcontrol.c	/^	unsigned int generation;$/;"	m	struct:mem_cgroup_reclaim_iter	file:
generic_access_phys	./memory.c	/^EXPORT_SYMBOL_GPL(generic_access_phys);$/;"	v
generic_access_phys	./memory.c	/^int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,$/;"	f
generic_error_remove_page	./truncate.c	/^EXPORT_SYMBOL(generic_error_remove_page);$/;"	v
generic_error_remove_page	./truncate.c	/^int generic_error_remove_page(struct address_space *mapping, struct page *page)$/;"	f
generic_file_aio_read	./filemap.c	/^EXPORT_SYMBOL(generic_file_aio_read);$/;"	v
generic_file_aio_read	./filemap.c	/^generic_file_aio_read(struct kiocb *iocb, const struct iovec *iov,$/;"	f
generic_file_aio_write	./filemap.c	/^EXPORT_SYMBOL(generic_file_aio_write);$/;"	v
generic_file_aio_write	./filemap.c	/^ssize_t generic_file_aio_write(struct kiocb *iocb, const struct iovec *iov,$/;"	f
generic_file_direct_write	./filemap.c	/^EXPORT_SYMBOL(generic_file_direct_write);$/;"	v
generic_file_direct_write	./filemap.c	/^generic_file_direct_write(struct kiocb *iocb, const struct iovec *iov,$/;"	f
generic_file_mmap	./filemap.c	/^EXPORT_SYMBOL(generic_file_mmap);$/;"	v
generic_file_mmap	./filemap.c	/^int generic_file_mmap(struct file * file, struct vm_area_struct * vma)$/;"	f
generic_file_readonly_mmap	./filemap.c	/^EXPORT_SYMBOL(generic_file_readonly_mmap);$/;"	v
generic_file_readonly_mmap	./filemap.c	/^int generic_file_readonly_mmap(struct file * file, struct vm_area_struct * vma)$/;"	f
generic_file_readonly_mmap	./filemap.c	/^int generic_file_readonly_mmap(struct file *file, struct vm_area_struct *vma)$/;"	f
generic_file_remap_pages	./fremap.c	/^EXPORT_SYMBOL(generic_file_remap_pages);$/;"	v
generic_file_remap_pages	./fremap.c	/^int generic_file_remap_pages(struct vm_area_struct *vma, unsigned long addr,$/;"	f
generic_file_remap_pages	./nommu.c	/^EXPORT_SYMBOL(generic_file_remap_pages);$/;"	v
generic_file_remap_pages	./nommu.c	/^int generic_file_remap_pages(struct vm_area_struct *vma, unsigned long addr,$/;"	f
generic_file_vm_ops	./filemap.c	/^const struct vm_operations_struct generic_file_vm_ops = {$/;"	v	typeref:struct:vm_operations_struct
generic_file_vm_ops	./nommu.c	/^const struct vm_operations_struct generic_file_vm_ops = {$/;"	v	typeref:struct:vm_operations_struct
generic_online_page	./memory_hotplug.c	/^static void generic_online_page(struct page *page)$/;"	f	file:
generic_perform_write	./filemap.c	/^EXPORT_SYMBOL(generic_perform_write);$/;"	v
generic_perform_write	./filemap.c	/^ssize_t generic_perform_write(struct file *file,$/;"	f
generic_segment_checks	./filemap.c	/^EXPORT_SYMBOL(generic_segment_checks);$/;"	v
generic_segment_checks	./filemap.c	/^int generic_segment_checks(const struct iovec *iov,$/;"	f
generic_swapfile_activate	./page_io.c	/^int generic_swapfile_activate(struct swap_info_struct *sis,$/;"	f
generic_write_checks	./filemap.c	/^EXPORT_SYMBOL(generic_write_checks);$/;"	v
generic_write_checks	./filemap.c	/^inline int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk)$/;"	f
generic_writepages	./page-writeback.c	/^EXPORT_SYMBOL(generic_writepages);$/;"	v
generic_writepages	./page-writeback.c	/^int generic_writepages(struct address_space *mapping,$/;"	f
get_allocated_memblock_memory_regions_info	./memblock.c	/^phys_addr_t __init_memblock get_allocated_memblock_memory_regions_info($/;"	f
get_allocated_memblock_reserved_regions_info	./memblock.c	/^phys_addr_t __init_memblock get_allocated_memblock_reserved_regions_info($/;"	f
get_any_page	./memory-failure.c	/^static int get_any_page(struct page *page, unsigned long pfn, int flags)$/;"	f	file:
get_any_partial	./slub.c	/^static void *get_any_partial(struct kmem_cache *s, gfp_t flags,$/;"	f	file:
get_cmdline	./util.c	/^int get_cmdline(struct task_struct *task, char *buffer, int buflen)$/;"	f
get_dump_page	./memory.c	/^struct page *get_dump_page(unsigned long addr)$/;"	f
get_first_page	./zsmalloc.c	/^static struct page *get_first_page(struct page *page)$/;"	f	file:
get_free_obj	./slab.c	/^static inline freelist_idx_t get_free_obj(struct page *page, unsigned int idx)$/;"	f	file:
get_freelist	./slub.c	/^static inline void *get_freelist(struct kmem_cache *s, struct page *page)$/;"	f	file:
get_freepointer	./slub.c	/^static inline void *get_freepointer(struct kmem_cache *s, void *object)$/;"	f	file:
get_freepointer_safe	./slub.c	/^static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)$/;"	f	file:
get_fullness_group	./zsmalloc.c	/^static enum fullness_group get_fullness_group(struct page *page)$/;"	f	file:
get_gate_vma	./memory.c	/^struct vm_area_struct *get_gate_vma(struct mm_struct *mm)$/;"	f
get_huge_zero_page	./huge_memory.c	/^static struct page *get_huge_zero_page(void)$/;"	f	file:
get_init_ra_size	./readahead.c	/^static unsigned long get_init_ra_size(unsigned long size, unsigned long max)$/;"	f	file:
get_kernel_page	./swap.c	/^EXPORT_SYMBOL_GPL(get_kernel_page);$/;"	v
get_kernel_page	./swap.c	/^int get_kernel_page(unsigned long start, int write, struct page **pages)$/;"	f
get_kernel_pages	./swap.c	/^EXPORT_SYMBOL_GPL(get_kernel_pages);$/;"	v
get_kernel_pages	./swap.c	/^int get_kernel_pages(const struct kvec *kiov, int nr_segs, int write,$/;"	f
get_kpfn_nid	./ksm.c	/^static inline int get_kpfn_nid(unsigned long kpfn)$/;"	f	file:
get_ksm_page	./ksm.c	/^static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)$/;"	f	file:
get_lru_size	./vmscan.c	/^static unsigned long get_lru_size(struct lruvec *lruvec, enum lru_list lru)$/;"	f	file:
get_map	./slub.c	/^static void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)$/;"	f	file:
get_mctgt_type	./memcontrol.c	/^static enum mc_target_type get_mctgt_type(struct vm_area_struct *vma,$/;"	f	file:
get_mctgt_type_thp	./memcontrol.c	/^static enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,$/;"	f	file:
get_mctgt_type_thp	./memcontrol.c	/^static inline enum mc_target_type get_mctgt_type_thp(struct vm_area_struct *vma,$/;"	f	file:
get_mem_cgroup_from_mm	./memcontrol.c	/^static struct mem_cgroup *get_mem_cgroup_from_mm(struct mm_struct *mm)$/;"	f	file:
get_mergeable_page	./ksm.c	/^static struct page *get_mergeable_page(struct rmap_item *rmap_item)$/;"	f	file:
get_mm_slot	./huge_memory.c	/^static struct mm_slot *get_mm_slot(struct mm_struct *mm)$/;"	f	file:
get_mm_slot	./ksm.c	/^static struct mm_slot *get_mm_slot(struct mm_struct *mm)$/;"	f	file:
get_next_page	./zsmalloc.c	/^static struct page *get_next_page(struct page *page)$/;"	f	file:
get_next_ra_size	./readahead.c	/^static unsigned long get_next_ra_size(struct file_ra_state *ra,$/;"	f	file:
get_next_rmap_item	./ksm.c	/^static struct rmap_item *get_next_rmap_item(struct mm_slot *mm_slot,$/;"	f	file:
get_node	./slub.c	/^static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)$/;"	f	file:
get_nodes	./mempolicy.c	/^static int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,$/;"	f	file:
get_object	./kmemleak.c	/^static int get_object(struct kmemleak_object *object)$/;"	f	file:
get_old_pmd	./mremap.c	/^static pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)$/;"	f	file:
get_page_bootmem	./memory_hotplug.c	/^void get_page_bootmem(unsigned long info,  struct page *page,$/;"	f
get_page_foll	./internal.h	/^static inline void get_page_foll(struct page *page)$/;"	f
get_page_from_freelist	./page_alloc.c	/^get_page_from_freelist(gfp_t gfp_mask, nodemask_t *nodemask, unsigned int order,$/;"	f	file:
get_pageblock_bitmap	./page_alloc.c	/^static inline unsigned long *get_pageblock_bitmap(struct zone *zone,$/;"	f	file:
get_pageblock_flags_group	./page_alloc.c	/^unsigned long get_pageblock_flags_group(struct page *page,$/;"	f
get_pages_per_zspage	./zsmalloc.c	/^static int get_pages_per_zspage(int class_size)$/;"	f	file:
get_partial	./slub.c	/^static void *get_partial(struct kmem_cache *s, gfp_t flags, int node,$/;"	f	file:
get_partial_node	./slub.c	/^static void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,$/;"	f	file:
get_pfn_range_for_nid	./page_alloc.c	/^void __meminit get_pfn_range_for_nid(unsigned int nid,$/;"	f
get_policy_nodemask	./mempolicy.c	/^static void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)$/;"	f	file:
get_poolid_from_fake	./cleancache.c	/^static int get_poolid_from_fake(int fake_pool_id)$/;"	f	file:
get_scan_count	./vmscan.c	/^static void get_scan_count(struct lruvec *lruvec, struct scan_control *sc,$/;"	f	file:
get_size_class_index	./zsmalloc.c	/^static int get_size_class_index(int size)$/;"	f	file:
get_slabinfo	./slab.c	/^void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)$/;"	f
get_slabinfo	./slub.c	/^void get_slabinfo(struct kmem_cache *s, struct slabinfo *sinfo)$/;"	f
get_swap_bio	./page_io.c	/^static struct bio *get_swap_bio(gfp_t gfp_flags,$/;"	f	file:
get_swap_page	./swapfile.c	/^swp_entry_t get_swap_page(void)$/;"	f
get_swap_page_of_type	./swapfile.c	/^swp_entry_t get_swap_page_of_type(int type)$/;"	f
get_task_policy	./mempolicy.c	/^static struct mempolicy *get_task_policy(struct task_struct *p)$/;"	f	file:
get_track	./slub.c	/^static struct track *get_track(struct kmem_cache *s, void *object,$/;"	f	file:
get_unmapped_area	./mmap.c	/^EXPORT_SYMBOL(get_unmapped_area);$/;"	v
get_unmapped_area	./mmap.c	/^get_unmapped_area(struct file *file, unsigned long addr, unsigned long len,$/;"	f
get_user_pages	./memory.c	/^EXPORT_SYMBOL(get_user_pages);$/;"	v
get_user_pages	./memory.c	/^long get_user_pages(struct task_struct *tsk, struct mm_struct *mm,$/;"	f
get_user_pages	./nommu.c	/^EXPORT_SYMBOL(get_user_pages);$/;"	v
get_user_pages	./nommu.c	/^long get_user_pages(struct task_struct *tsk, struct mm_struct *mm,$/;"	f
get_user_pages_fast	./util.c	/^EXPORT_SYMBOL_GPL(get_user_pages_fast);$/;"	v
get_user_pages_fast	./util.c	/^int __weak get_user_pages_fast(unsigned long start,$/;"	f
get_valid_node_allowed	./hugetlb.c	/^static int get_valid_node_allowed(int nid, nodemask_t *nodes_allowed)$/;"	f	file:
get_vm_area	./vmalloc.c	/^struct vm_struct *get_vm_area(unsigned long size, unsigned long flags)$/;"	f
get_vm_area_caller	./vmalloc.c	/^struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,$/;"	f
get_vma_policy	./mempolicy.c	/^struct mempolicy *get_vma_policy(struct task_struct *task,$/;"	f
get_vma_private_data	./hugetlb.c	/^static unsigned long get_vma_private_data(struct vm_area_struct *vma)$/;"	f	file:
get_vmalloc_info	./vmalloc.c	/^void get_vmalloc_info(struct vmalloc_info *vmi)$/;"	f
get_zeroed_page	./page_alloc.c	/^EXPORT_SYMBOL(get_zeroed_page);$/;"	v
get_zeroed_page	./page_alloc.c	/^unsigned long get_zeroed_page(gfp_t gfp_mask)$/;"	f
get_zspage_mapping	./zsmalloc.c	/^static void get_zspage_mapping(struct page *page, unsigned int *class_idx,$/;"	f	file:
gfp_kmemleak_mask	./kmemleak.c	117;"	d	file:
gfp_mask	./vmscan.c	/^	gfp_t gfp_mask;$/;"	m	struct:scan_control	file:
gfp_pfmemalloc_allowed	./page_alloc.c	/^bool gfp_pfmemalloc_allowed(gfp_t gfp_mask)$/;"	f
gfp_to_alloc_flags	./page_alloc.c	/^gfp_to_alloc_flags(gfp_t gfp_mask)$/;"	f	file:
global_dirty_limit	./page-writeback.c	/^unsigned long global_dirty_limit;$/;"	v
global_dirty_limits	./page-writeback.c	/^void global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)$/;"	f
global_dirtyable_memory	./page-writeback.c	/^static unsigned long global_dirtyable_memory(void)$/;"	f	file:
global_reclaim	./vmscan.c	/^static bool global_reclaim(struct scan_control *sc)$/;"	f	file:
global_update_bandwidth	./page-writeback.c	/^static void global_update_bandwidth(unsigned long thresh,$/;"	f	file:
grab_cache_page_nowait	./filemap.c	/^EXPORT_SYMBOL(grab_cache_page_nowait);$/;"	v
grab_cache_page_nowait	./filemap.c	/^grab_cache_page_nowait(struct address_space *mapping, pgoff_t index)$/;"	f
grab_cache_page_write_begin	./filemap.c	/^EXPORT_SYMBOL(grab_cache_page_write_begin);$/;"	v
grab_cache_page_write_begin	./filemap.c	/^struct page *grab_cache_page_write_begin(struct address_space *mapping,$/;"	f
gray_list	./kmemleak.c	/^	struct list_head gray_list;$/;"	m	struct:kmemleak_object	typeref:struct:kmemleak_object::list_head	file:
grow_pgdat_span	./memory_hotplug.c	/^static void grow_pgdat_span(struct pglist_data *pgdat, unsigned long start_pfn,$/;"	f	file:
grow_zone_span	./memory_hotplug.c	/^static void grow_zone_span(struct zone *zone, unsigned long start_pfn,$/;"	f	file:
handle	./zswap.c	/^	unsigned long handle;$/;"	m	struct:zswap_entry	file:
handle_mm_fault	./memory.c	/^int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
handle_pte_fault	./memory.c	/^static int handle_pte_fault(struct mm_struct *mm,$/;"	f	file:
handle_slab	./slab.c	/^static void handle_slab(unsigned long *n, struct kmem_cache *c,$/;"	f	file:
handle_to_zbud_header	./zbud.c	/^static struct zbud_header *handle_to_zbud_header(unsigned long handle)$/;"	f	file:
handle_write_error	./vmscan.c	/^static void handle_write_error(struct address_space *mapping,$/;"	f	file:
hard_dirty_limit	./page-writeback.c	/^static unsigned long hard_dirty_limit(unsigned long thresh)$/;"	f	file:
has_cpu_slab	./slub.c	/^static bool has_cpu_slab(int cpu, void *info)$/;"	f	file:
has_intersects_mems_allowed	./oom_kill.c	/^static bool has_intersects_mems_allowed(struct task_struct *start,$/;"	f	file:
has_intersects_mems_allowed	./oom_kill.c	/^static bool has_intersects_mems_allowed(struct task_struct *tsk,$/;"	f	file:
has_unmovable_pages	./page_alloc.c	/^bool has_unmovable_pages(struct zone *zone, struct page *page, int count,$/;"	f
hash	./huge_memory.c	/^	struct hlist_node hash;$/;"	m	struct:mm_slot	typeref:struct:mm_slot::hlist_node	file:
hashdist	./page_alloc.c	/^int hashdist = HASHDIST_DEFAULT;$/;"	v
head	./ksm.c	/^			struct list_head *head;$/;"	m	struct:stable_node::__anon5::__anon6	typeref:struct:stable_node::__anon5::__anon6::list_head	file:
head	./ksm.c	/^			struct stable_node *head;$/;"	m	struct:rmap_item::__anon8::__anon9	typeref:struct:rmap_item::__anon8::__anon9::stable_node	file:
head	./memory-failure.c	750;"	d	file:
head	./memory-failure.c	807;"	d	file:
head	./slob.c	/^	struct rcu_head head;$/;"	m	struct:slob_rcu	typeref:struct:slob_rcu::rcu_head	file:
header	./kmemleak-test.c	/^	long header[25];$/;"	m	struct:test_node	file:
heap_stack_gap	./nommu.c	/^int heap_stack_gap = 0;$/;"	v
hex_dump_object	./kmemleak.c	/^static void hex_dump_object(struct seq_file *seq,$/;"	f	file:
hibernation_mode	./vmscan.c	/^	unsigned long hibernation_mode;$/;"	m	struct:scan_control	file:
high_memory	./memory.c	/^EXPORT_SYMBOL(high_memory);$/;"	v
high_memory	./memory.c	/^void * high_memory;$/;"	v
high_memory	./nommu.c	/^void *high_memory;$/;"	v
highest_memmap_pfn	./nommu.c	/^unsigned long highest_memmap_pfn;$/;"	v
highest_priority_index	./swapfile.c	/^static atomic_t highest_priority_index = ATOMIC_INIT(-1);$/;"	v	file:
highmem_dirtyable_memory	./page-writeback.c	/^static unsigned long highmem_dirtyable_memory(unsigned long total)$/;"	f	file:
hlist	./ksm.c	/^			struct hlist_node hlist;$/;"	m	struct:rmap_item::__anon8::__anon9	typeref:struct:rmap_item::__anon8::__anon9::hlist_node	file:
hlist	./ksm.c	/^	struct hlist_head hlist;$/;"	m	struct:stable_node	typeref:struct:stable_node::hlist_head	file:
hotadd_new_pgdat	./memory_hotplug.c	/^static pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)$/;"	f	file:
hstate_attr_group	./hugetlb.c	/^static struct attribute_group hstate_attr_group = {$/;"	v	typeref:struct:attribute_group	file:
hstate_attrs	./hugetlb.c	/^static struct attribute *hstate_attrs[] = {$/;"	v	typeref:struct:attribute	file:
hstate_kobjs	./hugetlb.c	/^	struct kobject		*hstate_kobjs[HUGE_MAX_HSTATE];$/;"	m	struct:node_hstate	typeref:struct:node_hstate::kobject	file:
hstate_kobjs	./hugetlb.c	/^static struct kobject *hstate_kobjs[HUGE_MAX_HSTATE];$/;"	v	typeref:struct:kobject	file:
hstate_next_node_to_alloc	./hugetlb.c	/^static int hstate_next_node_to_alloc(struct hstate *h,$/;"	f	file:
hstate_next_node_to_free	./hugetlb.c	/^static int hstate_next_node_to_free(struct hstate *h, nodemask_t *nodes_allowed)$/;"	f	file:
hstates	./hugetlb.c	/^struct hstate hstates[HUGE_MAX_HSTATE];$/;"	v	typeref:struct:hstate
htlb_alloc_mask	./hugetlb.c	/^static inline gfp_t htlb_alloc_mask(struct hstate *h)$/;"	f	file:
huge_pmd_set_accessed	./huge_memory.c	/^void huge_pmd_set_accessed(struct mm_struct *mm,$/;"	f
huge_pmd_share	./hugetlb.c	/^pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)$/;"	f
huge_pmd_unshare	./hugetlb.c	/^int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)$/;"	f
huge_pte_alloc	./hugetlb.c	/^pte_t *huge_pte_alloc(struct mm_struct *mm,$/;"	f
huge_pte_offset	./hugetlb.c	/^pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)$/;"	f
huge_zero_page_shrinker	./huge_memory.c	/^static struct shrinker huge_zero_page_shrinker = {$/;"	v	typeref:struct:shrinker	file:
huge_zero_refcount	./huge_memory.c	/^static atomic_t huge_zero_refcount;$/;"	v	file:
huge_zonelist	./mempolicy.c	/^struct zonelist *huge_zonelist(struct vm_area_struct *vma, unsigned long addr,$/;"	f
hugepage	./hugetlb_cgroup.c	/^	struct res_counter hugepage[HUGE_MAX_HSTATE];$/;"	m	struct:hugetlb_cgroup	typeref:struct:hugetlb_cgroup::res_counter	file:
hugepage_add_anon_rmap	./rmap.c	/^void hugepage_add_anon_rmap(struct page *page,$/;"	f
hugepage_add_new_anon_rmap	./rmap.c	/^void hugepage_add_new_anon_rmap(struct page *page,$/;"	f
hugepage_attr	./huge_memory.c	/^static struct attribute *hugepage_attr[] = {$/;"	v	typeref:struct:attribute	file:
hugepage_attr_group	./huge_memory.c	/^static struct attribute_group hugepage_attr_group = {$/;"	v	typeref:struct:attribute_group	file:
hugepage_exit_sysfs	./huge_memory.c	/^static inline void hugepage_exit_sysfs(struct kobject *hugepage_kobj)$/;"	f	file:
hugepage_exit_sysfs	./huge_memory.c	/^static void __init hugepage_exit_sysfs(struct kobject *hugepage_kobj)$/;"	f	file:
hugepage_init	./huge_memory.c	/^static int __init hugepage_init(void)$/;"	f	file:
hugepage_init	./huge_memory.c	/^subsys_initcall(hugepage_init);$/;"	v
hugepage_init_sysfs	./huge_memory.c	/^static inline int hugepage_init_sysfs(struct kobject **hugepage_kobj)$/;"	f	file:
hugepage_init_sysfs	./huge_memory.c	/^static int __init hugepage_init_sysfs(struct kobject **hugepage_kobj)$/;"	f	file:
hugepage_madvise	./huge_memory.c	/^int hugepage_madvise(struct vm_area_struct *vma,$/;"	f
hugepage_new_subpool	./hugetlb.c	/^struct hugepage_subpool *hugepage_new_subpool(long nr_blocks)$/;"	f
hugepage_put_subpool	./hugetlb.c	/^void hugepage_put_subpool(struct hugepage_subpool *spool)$/;"	f
hugepage_subpool_get_pages	./hugetlb.c	/^static int hugepage_subpool_get_pages(struct hugepage_subpool *spool,$/;"	f	file:
hugepage_subpool_put_pages	./hugetlb.c	/^static void hugepage_subpool_put_pages(struct hugepage_subpool *spool,$/;"	f	file:
hugepage_vma_check	./huge_memory.c	/^static bool hugepage_vma_check(struct vm_area_struct *vma)$/;"	f	file:
hugepages_kobj	./hugetlb.c	/^	struct kobject		*hugepages_kobj;$/;"	m	struct:node_hstate	typeref:struct:node_hstate::kobject	file:
hugepages_kobj	./hugetlb.c	/^static struct kobject *hugepages_kobj;$/;"	v	typeref:struct:kobject	file:
hugepages_treat_as_movable	./hugetlb.c	/^unsigned long hugepages_treat_as_movable;$/;"	v
hugetlb_acct_memory	./hugetlb.c	/^static int hugetlb_acct_memory(struct hstate *h, long delta)$/;"	f	file:
hugetlb_add_hstate	./hugetlb.c	/^void __init hugetlb_add_hstate(unsigned order)$/;"	f
hugetlb_cgroup	./hugetlb_cgroup.c	/^struct hugetlb_cgroup {$/;"	s	file:
hugetlb_cgroup_charge_cgroup	./hugetlb_cgroup.c	/^int hugetlb_cgroup_charge_cgroup(int idx, unsigned long nr_pages,$/;"	f
hugetlb_cgroup_commit_charge	./hugetlb_cgroup.c	/^void hugetlb_cgroup_commit_charge(int idx, unsigned long nr_pages,$/;"	f
hugetlb_cgroup_css_alloc	./hugetlb_cgroup.c	/^hugetlb_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)$/;"	f	file:
hugetlb_cgroup_css_free	./hugetlb_cgroup.c	/^static void hugetlb_cgroup_css_free(struct cgroup_subsys_state *css)$/;"	f	file:
hugetlb_cgroup_css_offline	./hugetlb_cgroup.c	/^static void hugetlb_cgroup_css_offline(struct cgroup_subsys_state *css)$/;"	f	file:
hugetlb_cgroup_file_init	./hugetlb_cgroup.c	/^void __init hugetlb_cgroup_file_init(void)$/;"	f
hugetlb_cgroup_from_css	./hugetlb_cgroup.c	/^struct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)$/;"	f	file:
hugetlb_cgroup_from_task	./hugetlb_cgroup.c	/^struct hugetlb_cgroup *hugetlb_cgroup_from_task(struct task_struct *task)$/;"	f	file:
hugetlb_cgroup_have_usage	./hugetlb_cgroup.c	/^static inline bool hugetlb_cgroup_have_usage(struct hugetlb_cgroup *h_cg)$/;"	f	file:
hugetlb_cgroup_is_root	./hugetlb_cgroup.c	/^static inline bool hugetlb_cgroup_is_root(struct hugetlb_cgroup *h_cg)$/;"	f	file:
hugetlb_cgroup_migrate	./hugetlb_cgroup.c	/^void hugetlb_cgroup_migrate(struct page *oldhpage, struct page *newhpage)$/;"	f
hugetlb_cgroup_move_parent	./hugetlb_cgroup.c	/^static void hugetlb_cgroup_move_parent(int idx, struct hugetlb_cgroup *h_cg,$/;"	f	file:
hugetlb_cgroup_read_u64	./hugetlb_cgroup.c	/^static u64 hugetlb_cgroup_read_u64(struct cgroup_subsys_state *css,$/;"	f	file:
hugetlb_cgroup_reset	./hugetlb_cgroup.c	/^static int hugetlb_cgroup_reset(struct cgroup_subsys_state *css,$/;"	f	file:
hugetlb_cgroup_uncharge_cgroup	./hugetlb_cgroup.c	/^void hugetlb_cgroup_uncharge_cgroup(int idx, unsigned long nr_pages,$/;"	f
hugetlb_cgroup_uncharge_page	./hugetlb_cgroup.c	/^void hugetlb_cgroup_uncharge_page(int idx, unsigned long nr_pages,$/;"	f
hugetlb_cgroup_write	./hugetlb_cgroup.c	/^static int hugetlb_cgroup_write(struct cgroup_subsys_state *css,$/;"	f	file:
hugetlb_cgrp_subsys	./hugetlb_cgroup.c	/^struct cgroup_subsys hugetlb_cgrp_subsys = {$/;"	v	typeref:struct:cgroup_subsys
hugetlb_change_protection	./hugetlb.c	/^unsigned long hugetlb_change_protection(struct vm_area_struct *vma,$/;"	f
hugetlb_cow	./hugetlb.c	/^static int hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
hugetlb_default_setup	./hugetlb.c	/^static int __init hugetlb_default_setup(char *s)$/;"	f	file:
hugetlb_entry_end	./pagewalk.c	/^static unsigned long hugetlb_entry_end(struct hstate *h, unsigned long addr,$/;"	f	file:
hugetlb_exit	./hugetlb.c	/^module_exit(hugetlb_exit);$/;"	v
hugetlb_exit	./hugetlb.c	/^static void __exit hugetlb_exit(void)$/;"	f	file:
hugetlb_fault	./hugetlb.c	/^int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
hugetlb_hstate_alloc_pages	./hugetlb.c	/^static void __init hugetlb_hstate_alloc_pages(struct hstate *h)$/;"	f	file:
hugetlb_infinity	./hugetlb.c	/^const unsigned long hugetlb_zero = 0, hugetlb_infinity = ~0UL;$/;"	v
hugetlb_init	./hugetlb.c	/^module_init(hugetlb_init);$/;"	v
hugetlb_init	./hugetlb.c	/^static int __init hugetlb_init(void)$/;"	f	file:
hugetlb_init_hstates	./hugetlb.c	/^static void __init hugetlb_init_hstates(void)$/;"	f	file:
hugetlb_lock	./hugetlb.c	/^DEFINE_SPINLOCK(hugetlb_lock);$/;"	v
hugetlb_mempolicy_sysctl_handler	./hugetlb.c	/^int hugetlb_mempolicy_sysctl_handler(struct ctl_table *table, int write,$/;"	f
hugetlb_no_page	./hugetlb.c	/^static int hugetlb_no_page(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
hugetlb_nrpages_setup	./hugetlb.c	/^static int __init hugetlb_nrpages_setup(char *s)$/;"	f	file:
hugetlb_overcommit_handler	./hugetlb.c	/^int hugetlb_overcommit_handler(struct ctl_table *table, int write,$/;"	f
hugetlb_register_all_nodes	./hugetlb.c	/^static void hugetlb_register_all_nodes(void) { }$/;"	f	file:
hugetlb_register_all_nodes	./hugetlb.c	/^static void hugetlb_register_all_nodes(void)$/;"	f	file:
hugetlb_register_node	./hugetlb.c	/^static void hugetlb_register_node(struct node *node)$/;"	f	file:
hugetlb_report_meminfo	./hugetlb.c	/^void hugetlb_report_meminfo(struct seq_file *m)$/;"	f
hugetlb_report_node_meminfo	./hugetlb.c	/^int hugetlb_report_node_meminfo(int nid, char *buf)$/;"	f
hugetlb_reserve_pages	./hugetlb.c	/^int hugetlb_reserve_pages(struct inode *inode,$/;"	f
hugetlb_show_meminfo	./hugetlb.c	/^void hugetlb_show_meminfo(void)$/;"	f
hugetlb_sysctl_handler	./hugetlb.c	/^int hugetlb_sysctl_handler(struct ctl_table *table, int write,$/;"	f
hugetlb_sysctl_handler_common	./hugetlb.c	/^static int hugetlb_sysctl_handler_common(bool obey_mempolicy,$/;"	f	file:
hugetlb_sysfs_add_hstate	./hugetlb.c	/^static int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,$/;"	f	file:
hugetlb_sysfs_init	./hugetlb.c	/^static void __init hugetlb_sysfs_init(void)$/;"	f	file:
hugetlb_total_pages	./hugetlb.c	/^unsigned long hugetlb_total_pages(void)$/;"	f
hugetlb_unregister_all_nodes	./hugetlb.c	/^static void hugetlb_unregister_all_nodes(void) { }$/;"	f	file:
hugetlb_unregister_all_nodes	./hugetlb.c	/^static void hugetlb_unregister_all_nodes(void)$/;"	f	file:
hugetlb_unregister_node	./hugetlb.c	/^static void hugetlb_unregister_node(struct node *node)$/;"	f	file:
hugetlb_unreserve_pages	./hugetlb.c	/^void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)$/;"	f
hugetlb_vm_op_close	./hugetlb.c	/^static void hugetlb_vm_op_close(struct vm_area_struct *vma)$/;"	f	file:
hugetlb_vm_op_fault	./hugetlb.c	/^static int hugetlb_vm_op_fault(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f	file:
hugetlb_vm_op_open	./hugetlb.c	/^static void hugetlb_vm_op_open(struct vm_area_struct *vma)$/;"	f	file:
hugetlb_vm_ops	./hugetlb.c	/^const struct vm_operations_struct hugetlb_vm_ops = {$/;"	v	typeref:struct:vm_operations_struct
hugetlb_zero	./hugetlb.c	/^const unsigned long hugetlb_zero = 0, hugetlb_infinity = ~0UL;$/;"	v
hugetlbfs_pagecache_page	./hugetlb.c	/^static struct page *hugetlbfs_pagecache_page(struct hstate *h,$/;"	f	file:
hugetlbfs_pagecache_present	./hugetlb.c	/^static bool hugetlbfs_pagecache_present(struct hstate *h,$/;"	f	file:
hwcache_align	./slub.c	/^SLAB_ATTR_RO(hwcache_align);$/;"	v
hwcache_align_show	./slub.c	/^static ssize_t hwcache_align_show(struct kmem_cache *s, char *buf)$/;"	f	file:
hwpoison_dir	./hwpoison-inject.c	/^static struct dentry *hwpoison_dir;$/;"	v	typeref:struct:dentry	file:
hwpoison_filter	./memory-failure.c	/^EXPORT_SYMBOL_GPL(hwpoison_filter);$/;"	v
hwpoison_filter	./memory-failure.c	/^int hwpoison_filter(struct page *p)$/;"	f
hwpoison_filter_dev	./memory-failure.c	/^static int hwpoison_filter_dev(struct page *p)$/;"	f	file:
hwpoison_filter_dev_major	./memory-failure.c	/^EXPORT_SYMBOL_GPL(hwpoison_filter_dev_major);$/;"	v
hwpoison_filter_dev_major	./memory-failure.c	/^u32 hwpoison_filter_dev_major = ~0U;$/;"	v
hwpoison_filter_dev_minor	./memory-failure.c	/^EXPORT_SYMBOL_GPL(hwpoison_filter_dev_minor);$/;"	v
hwpoison_filter_dev_minor	./memory-failure.c	/^u32 hwpoison_filter_dev_minor = ~0U;$/;"	v
hwpoison_filter_enable	./memory-failure.c	/^EXPORT_SYMBOL_GPL(hwpoison_filter_enable);$/;"	v
hwpoison_filter_enable	./memory-failure.c	/^u32 hwpoison_filter_enable = 0;$/;"	v
hwpoison_filter_flags	./memory-failure.c	/^static int hwpoison_filter_flags(struct page *p)$/;"	f	file:
hwpoison_filter_flags_mask	./memory-failure.c	/^EXPORT_SYMBOL_GPL(hwpoison_filter_flags_mask);$/;"	v
hwpoison_filter_flags_mask	./memory-failure.c	/^u64 hwpoison_filter_flags_mask;$/;"	v
hwpoison_filter_flags_value	./memory-failure.c	/^EXPORT_SYMBOL_GPL(hwpoison_filter_flags_value);$/;"	v
hwpoison_filter_flags_value	./memory-failure.c	/^u64 hwpoison_filter_flags_value;$/;"	v
hwpoison_filter_memcg	./memory-failure.c	/^EXPORT_SYMBOL_GPL(hwpoison_filter_memcg);$/;"	v
hwpoison_filter_memcg	./memory-failure.c	/^u64 hwpoison_filter_memcg;$/;"	v
hwpoison_filter_task	./memory-failure.c	/^static int hwpoison_filter_task(struct page *p) { return 0; }$/;"	f	file:
hwpoison_filter_task	./memory-failure.c	/^static int hwpoison_filter_task(struct page *p)$/;"	f	file:
hwpoison_inject	./hwpoison-inject.c	/^static int hwpoison_inject(void *data, u64 val)$/;"	f	file:
hwpoison_unpoison	./hwpoison-inject.c	/^static int hwpoison_unpoison(void *data, u64 val)$/;"	f	file:
hwpoison_user_mappings	./memory-failure.c	/^static int hwpoison_user_mappings(struct page *p, unsigned long pfn,$/;"	f	file:
id	./page_cgroup.c	/^	unsigned short		id;$/;"	m	struct:swap_cgroup	file:
ignore_gfp_highmem	./page_alloc.c	/^	u32 ignore_gfp_highmem;$/;"	m	struct:__anon2	file:
ignore_gfp_wait	./failslab.c	/^	u32 ignore_gfp_wait;$/;"	m	struct:__anon12	file:
ignore_gfp_wait	./page_alloc.c	/^	u32 ignore_gfp_wait;$/;"	m	struct:__anon2	file:
ignore_skip_hint	./internal.h	/^	bool ignore_skip_hint;		\/* Scan blocks even if marked skip *\/$/;"	m	struct:compact_control
immigrate_flags	./memcontrol.c	/^	unsigned long immigrate_flags;$/;"	m	struct:move_charge_struct	file:
immutable	./percpu.c	/^	bool			immutable;	\/* no [de]population allowed *\/$/;"	m	struct:pcpu_chunk	file:
in_gate_area_no_mm	./memory.c	/^int in_gate_area_no_mm(unsigned long addr)$/;"	f
in_gate_area_no_mm	./nommu.c	/^int in_gate_area_no_mm(unsigned long addr)$/;"	f
in_reclaim_compaction	./vmscan.c	/^static bool in_reclaim_compaction(struct scan_control *sc)$/;"	f	file:
in_use	./dmapool.c	/^	unsigned int in_use;$/;"	m	struct:dma_page	file:
inactive_anon_is_low	./vmscan.c	/^static inline int inactive_anon_is_low(struct lruvec *lruvec)$/;"	f	file:
inactive_anon_is_low	./vmscan.c	/^static int inactive_anon_is_low(struct lruvec *lruvec)$/;"	f	file:
inactive_anon_is_low_global	./vmscan.c	/^static int inactive_anon_is_low_global(struct zone *zone)$/;"	f	file:
inactive_file_is_low	./vmscan.c	/^static int inactive_file_is_low(struct lruvec *lruvec)$/;"	f	file:
inactive_list_is_low	./vmscan.c	/^static int inactive_list_is_low(struct lruvec *lruvec, enum lru_list lru)$/;"	f	file:
inc_cluster_info_page	./swapfile.c	/^static void inc_cluster_info_page(struct swap_info_struct *p,$/;"	f	file:
inc_frontswap_failed_stores	./frontswap.c	/^static inline void inc_frontswap_failed_stores(void) { }$/;"	f	file:
inc_frontswap_failed_stores	./frontswap.c	/^static inline void inc_frontswap_failed_stores(void) {$/;"	f	file:
inc_frontswap_invalidates	./frontswap.c	/^static inline void inc_frontswap_invalidates(void) { }$/;"	f	file:
inc_frontswap_invalidates	./frontswap.c	/^static inline void inc_frontswap_invalidates(void) {$/;"	f	file:
inc_frontswap_loads	./frontswap.c	/^static inline void inc_frontswap_loads(void) { }$/;"	f	file:
inc_frontswap_loads	./frontswap.c	/^static inline void inc_frontswap_loads(void) {$/;"	f	file:
inc_frontswap_succ_stores	./frontswap.c	/^static inline void inc_frontswap_succ_stores(void) { }$/;"	f	file:
inc_frontswap_succ_stores	./frontswap.c	/^static inline void inc_frontswap_succ_stores(void) {$/;"	f	file:
inc_mm_counter_fast	./memory.c	159;"	d	file:
inc_mm_counter_fast	./memory.c	173;"	d	file:
inc_slabs_node	./slub.c	/^static inline void inc_slabs_node(struct kmem_cache *s, int node, int objects)$/;"	f	file:
inc_slabs_node	./slub.c	/^static inline void inc_slabs_node(struct kmem_cache *s, int node,$/;"	f	file:
inc_zone_page_state	./vmstat.c	/^EXPORT_SYMBOL(inc_zone_page_state);$/;"	v
inc_zone_page_state	./vmstat.c	/^void inc_zone_page_state(struct page *page, enum zone_stat_item item)$/;"	f
inc_zone_state	./vmstat.c	/^void inc_zone_state(struct zone *zone, enum zone_stat_item item)$/;"	f
index	./zsmalloc.c	/^	unsigned int index;$/;"	m	struct:size_class	file:
index_to_obj	./slab.c	/^static inline void *index_to_obj(struct kmem_cache *cache, struct page *page,$/;"	f	file:
init_admin_reserve	./mmap.c	/^static int init_admin_reserve(void)$/;"	f	file:
init_admin_reserve	./mmap.c	/^subsys_initcall(init_admin_reserve);$/;"	v
init_admin_reserve	./nommu.c	/^static int __meminit init_admin_reserve(void)$/;"	f	file:
init_bootmem	./bootmem.c	/^unsigned long __init init_bootmem(unsigned long start, unsigned long pages)$/;"	f
init_bootmem_core	./bootmem.c	/^static unsigned long __init init_bootmem_core(bootmem_data_t *bdata,$/;"	f	file:
init_bootmem_node	./bootmem.c	/^unsigned long __init init_bootmem_node(pg_data_t *pgdat, unsigned long freepfn,$/;"	f
init_cache_node_node	./slab.c	/^static int init_cache_node_node(int node)$/;"	f	file:
init_cleancache	./cleancache.c	/^static int __init init_cleancache(void)$/;"	f	file:
init_cma_reserved_pageblock	./page_alloc.c	/^void __init init_cma_reserved_pageblock(struct page *page)$/;"	f
init_currently_empty_zone	./page_alloc.c	/^int __meminit init_currently_empty_zone(struct zone *zone,$/;"	f
init_emergency_isa_pool	./bounce.c	/^int init_emergency_isa_pool(void)$/;"	f
init_emergency_pool	./bounce.c	/^__initcall(init_emergency_pool);$/;"	v
init_emergency_pool	./bounce.c	/^static __init int init_emergency_pool(void)$/;"	f	file:
init_frontswap	./frontswap.c	/^module_init(init_frontswap);$/;"	v
init_frontswap	./frontswap.c	/^static int __init init_frontswap(void)$/;"	f	file:
init_kmem_cache_cpus	./slub.c	/^static void init_kmem_cache_cpus(struct kmem_cache *s)$/;"	f	file:
init_kmem_cache_node	./slab.c	/^static struct kmem_cache_node __initdata init_kmem_cache_node[NUM_INIT_LISTS];$/;"	v	typeref:struct:__initdata	file:
init_kmem_cache_node	./slub.c	/^init_kmem_cache_node(struct kmem_cache_node *n)$/;"	f	file:
init_kmem_cache_nodes	./slub.c	/^static int init_kmem_cache_nodes(struct kmem_cache *s)$/;"	f	file:
init_list	./slab.c	/^static void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *list,$/;"	f	file:
init_lock_keys	./slab.c	/^static inline void init_lock_keys(void)$/;"	f	file:
init_mm	./init-mm.c	/^struct mm_struct init_mm = {$/;"	v	typeref:struct:mm_struct
init_node_lock_keys	./slab.c	/^static void init_node_lock_keys(int q)$/;"	f	file:
init_nodemask_of_mempolicy	./mempolicy.c	/^bool init_nodemask_of_mempolicy(nodemask_t *mask)$/;"	f
init_object	./slub.c	/^static void init_object(struct kmem_cache *s, void *object, u8 val)$/;"	f	file:
init_per_zone_wmark_min	./page_alloc.c	/^int __meminit init_per_zone_wmark_min(void)$/;"	f
init_reap_node	./slab.c	/^static void init_reap_node(int cpu)$/;"	f	file:
init_reap_node	./slab.c	715;"	d	file:
init_reserve_notifier	./mmap.c	/^static int __meminit init_reserve_notifier(void)$/;"	f	file:
init_reserve_notifier	./mmap.c	/^subsys_initcall(init_reserve_notifier);$/;"	v
init_rss_vec	./memory.c	/^static inline void init_rss_vec(int *rss)$/;"	f	file:
init_section_page_cgroup	./page_cgroup.c	/^static int __meminit init_section_page_cgroup(unsigned long pfn, int nid)$/;"	f	file:
init_tid	./slub.c	/^static inline unsigned int init_tid(int cpu)$/;"	f	file:
init_tracking	./slub.c	/^static void init_tracking(struct kmem_cache *s, void *object)$/;"	f	file:
init_user_reserve	./mmap.c	/^static int init_user_reserve(void)$/;"	f	file:
init_user_reserve	./mmap.c	/^subsys_initcall(init_user_reserve);$/;"	v
init_user_reserve	./nommu.c	/^static int __meminit init_user_reserve(void)$/;"	f	file:
init_zbud	./zbud.c	/^module_init(init_zbud);$/;"	v
init_zbud	./zbud.c	/^static int __init init_zbud(void)$/;"	f	file:
init_zbud_page	./zbud.c	/^static struct zbud_header *init_zbud_page(struct page *page)$/;"	f	file:
init_zero_pfn	./memory.c	/^core_initcall(init_zero_pfn);$/;"	v
init_zero_pfn	./memory.c	/^static int __init init_zero_pfn(void)$/;"	f	file:
init_zone_allows_reclaim	./page_alloc.c	/^static inline void init_zone_allows_reclaim(int nid)$/;"	f	file:
init_zone_allows_reclaim	./page_alloc.c	/^static void __paginginit init_zone_allows_reclaim(int nid)$/;"	f	file:
init_zspage	./zsmalloc.c	/^static void init_zspage(struct page *first_page, struct size_class *class)$/;"	f	file:
init_zswap	./zswap.c	/^late_initcall(init_zswap);$/;"	v
init_zswap	./zswap.c	/^static int __init init_zswap(void)$/;"	f	file:
initarray_generic	./slab.c	/^static struct arraycache_init initarray_generic =$/;"	v	typeref:struct:arraycache_init	file:
inode_resv_map	./hugetlb.c	/^static inline struct resv_map *inode_resv_map(struct inode *inode)$/;"	f	file:
insert_page	./memory.c	/^static int insert_page(struct vm_area_struct *vma, unsigned long addr,$/;"	f	file:
insert_pfn	./memory.c	/^static int insert_pfn(struct vm_area_struct *vma, unsigned long addr,$/;"	f	file:
insert_to_mm_slots_hash	./huge_memory.c	/^static void insert_to_mm_slots_hash(struct mm_struct *mm,$/;"	f	file:
insert_to_mm_slots_hash	./ksm.c	/^static void insert_to_mm_slots_hash(struct mm_struct *mm,$/;"	f	file:
insert_vm_struct	./mmap.c	/^int insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)$/;"	f
insert_zspage	./zsmalloc.c	/^static void insert_zspage(struct page *page, struct size_class *class,$/;"	f	file:
install_file_pte	./fremap.c	/^static int install_file_pte(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
install_special_mapping	./mmap.c	/^int install_special_mapping(struct mm_struct *mm,$/;"	f
interleave_nid	./mempolicy.c	/^static inline unsigned interleave_nid(struct mempolicy *pol,$/;"	f	file:
interleave_nodes	./mempolicy.c	/^static unsigned interleave_nodes(struct mempolicy *policy)$/;"	f	file:
invalid_migration_vma	./rmap.c	/^static bool invalid_migration_vma(struct vm_area_struct *vma, void *arg)$/;"	f	file:
invalid_mkclean_vma	./rmap.c	/^static bool invalid_mkclean_vma(struct vm_area_struct *vma, void *arg)$/;"	f	file:
invalid_page_referenced_vma	./rmap.c	/^static bool invalid_page_referenced_vma(struct vm_area_struct *vma, void *arg)$/;"	f	file:
invalidate_complete_page	./truncate.c	/^invalidate_complete_page(struct address_space *mapping, struct page *page)$/;"	f	file:
invalidate_complete_page2	./truncate.c	/^invalidate_complete_page2(struct address_space *mapping, struct page *page)$/;"	f	file:
invalidate_inode_page	./truncate.c	/^int invalidate_inode_page(struct page *page)$/;"	f
invalidate_inode_pages2	./truncate.c	/^EXPORT_SYMBOL_GPL(invalidate_inode_pages2);$/;"	v
invalidate_inode_pages2	./truncate.c	/^int invalidate_inode_pages2(struct address_space *mapping)$/;"	f
invalidate_inode_pages2_range	./truncate.c	/^EXPORT_SYMBOL_GPL(invalidate_inode_pages2_range);$/;"	v
invalidate_inode_pages2_range	./truncate.c	/^int invalidate_inode_pages2_range(struct address_space *mapping,$/;"	f
invalidate_mapping_pages	./truncate.c	/^EXPORT_SYMBOL(invalidate_mapping_pages);$/;"	v
invalidate_mapping_pages	./truncate.c	/^unsigned long invalidate_mapping_pages(struct address_space *mapping,$/;"	f
iov_iter_advance	./iov_iter.c	/^EXPORT_SYMBOL(iov_iter_advance);$/;"	v
iov_iter_advance	./iov_iter.c	/^void iov_iter_advance(struct iov_iter *i, size_t bytes)$/;"	f
iov_iter_copy_from_user	./iov_iter.c	/^EXPORT_SYMBOL(iov_iter_copy_from_user);$/;"	v
iov_iter_copy_from_user	./iov_iter.c	/^size_t iov_iter_copy_from_user(struct page *page,$/;"	f
iov_iter_copy_from_user_atomic	./iov_iter.c	/^EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);$/;"	v
iov_iter_copy_from_user_atomic	./iov_iter.c	/^size_t iov_iter_copy_from_user_atomic(struct page *page,$/;"	f
iov_iter_fault_in_readable	./iov_iter.c	/^EXPORT_SYMBOL(iov_iter_fault_in_readable);$/;"	v
iov_iter_fault_in_readable	./iov_iter.c	/^int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes)$/;"	f
iov_iter_single_seg_count	./iov_iter.c	/^EXPORT_SYMBOL(iov_iter_single_seg_count);$/;"	v
iov_iter_single_seg_count	./iov_iter.c	/^size_t iov_iter_single_seg_count(const struct iov_iter *i)$/;"	f
is_cow_mapping	./memory.c	/^static inline bool is_cow_mapping(vm_flags_t flags)$/;"	f	file:
is_first_page	./zsmalloc.c	/^static int is_first_page(struct page *page)$/;"	f	file:
is_free_buddy_page	./page_alloc.c	/^bool is_free_buddy_page(struct page *page)$/;"	f
is_huge_zero_page	./huge_memory.c	/^static inline bool is_huge_zero_page(struct page *page)$/;"	f	file:
is_huge_zero_pmd	./huge_memory.c	/^static inline bool is_huge_zero_pmd(pmd_t pmd)$/;"	f	file:
is_hugepage_active	./hugetlb.c	/^bool is_hugepage_active(struct page *page)$/;"	f
is_hugepage_on_freelist	./hugetlb.c	/^static int is_hugepage_on_freelist(struct page *hpage)$/;"	f	file:
is_hugetlb_entry_hwpoisoned	./hugetlb.c	/^static int is_hugetlb_entry_hwpoisoned(pte_t pte)$/;"	f	file:
is_hugetlb_entry_migration	./hugetlb.c	/^static int is_hugetlb_entry_migration(pte_t pte)$/;"	f	file:
is_kernel_percpu_address	./percpu.c	/^bool is_kernel_percpu_address(unsigned long addr)$/;"	f
is_last_page	./zsmalloc.c	/^static int is_last_page(struct page *page)$/;"	f	file:
is_mem_section_removable	./memory_hotplug.c	/^int is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)$/;"	f
is_mergeable_anon_vma	./mmap.c	/^static inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,$/;"	f	file:
is_mergeable_vma	./mmap.c	/^static inline int is_mergeable_vma(struct vm_area_struct *vma,$/;"	f	file:
is_obj_pfmemalloc	./slab.c	/^static inline bool is_obj_pfmemalloc(void *objp)$/;"	f	file:
is_page_busy	./dmapool.c	/^static inline int is_page_busy(struct dma_page *page)$/;"	f	file:
is_page_cache_freeable	./vmscan.c	/^static inline int is_page_cache_freeable(struct page *page)$/;"	f	file:
is_pageblock_removable_nolock	./page_alloc.c	/^bool is_pageblock_removable_nolock(struct page *page)$/;"	f
is_root_cache	./slab.h	/^static inline bool is_root_cache(struct kmem_cache *s)$/;"	f
is_slab_pfmemalloc	./slab.c	/^static inline bool is_slab_pfmemalloc(struct page *page)$/;"	f	file:
is_valid_nodemask	./mempolicy.c	/^static int is_valid_nodemask(const nodemask_t *nodemask)$/;"	f	file:
is_vma_resv_set	./hugetlb.c	/^static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)$/;"	f	file:
is_vma_temporary_stack	./rmap.c	/^bool is_vma_temporary_stack(struct vm_area_struct *vma)$/;"	f
is_vmalloc_or_module_addr	./vmalloc.c	/^int is_vmalloc_or_module_addr(const void *x)$/;"	f
isa_page_pool	./bounce.c	/^static mempool_t *page_pool, *isa_page_pool;$/;"	v	file:
isolate_freepages	./compaction.c	/^static void isolate_freepages(struct zone *zone,$/;"	f	file:
isolate_freepages_block	./compaction.c	/^static unsigned long isolate_freepages_block(struct compact_control *cc,$/;"	f	file:
isolate_freepages_range	./compaction.c	/^isolate_freepages_range(struct compact_control *cc,$/;"	f
isolate_huge_page	./hugetlb.c	/^bool isolate_huge_page(struct page *page, struct list_head *list)$/;"	f
isolate_lru_page	./vmscan.c	/^int isolate_lru_page(struct page *page)$/;"	f
isolate_lru_pages	./vmscan.c	/^static unsigned long isolate_lru_pages(unsigned long nr_to_scan,$/;"	f	file:
isolate_migrate_t	./compaction.c	/^} isolate_migrate_t;$/;"	t	typeref:enum:__anon10	file:
isolate_migratepages	./compaction.c	/^static isolate_migrate_t isolate_migratepages(struct zone *zone,$/;"	f	file:
isolate_migratepages_range	./compaction.c	/^isolate_migratepages_range(struct zone *zone, struct compact_control *cc,$/;"	f
isolation_suitable	./compaction.c	/^static inline bool isolation_suitable(struct compact_control *cc,$/;"	f	file:
jiffies	./kmemleak.c	/^	unsigned long jiffies;		\/* creation timestamp *\/$/;"	m	struct:kmemleak_object	file:
jiffies_last_scan	./kmemleak.c	/^static unsigned long jiffies_last_scan;$/;"	v	file:
jiffies_min_age	./kmemleak.c	/^static unsigned long jiffies_min_age;$/;"	v	file:
jiffies_scan_wait	./kmemleak.c	/^static signed long jiffies_scan_wait;$/;"	v	file:
just_wait	./ksm.c	/^static int just_wait(void *word)$/;"	f	file:
kdebug	./nommu.c	54;"	d	file:
kenter	./nommu.c	50;"	d	file:
kernel_map_pages	./debug-pagealloc.c	/^void kernel_map_pages(struct page *page, int numpages, int enable)$/;"	f
kfree	./slab.c	/^EXPORT_SYMBOL(kfree);$/;"	v
kfree	./slab.c	/^void kfree(const void *objp)$/;"	f
kfree	./slob.c	/^EXPORT_SYMBOL(kfree);$/;"	v
kfree	./slob.c	/^void kfree(const void *block)$/;"	f
kfree	./slub.c	/^EXPORT_SYMBOL(kfree);$/;"	v
kfree	./slub.c	/^void kfree(const void *x)$/;"	f
kfree	./util.c	/^EXPORT_TRACEPOINT_SYMBOL(kfree);$/;"	v
kfree_debugcheck	./slab.c	/^static void kfree_debugcheck(const void *objp)$/;"	f	file:
kfree_debugcheck	./slab.c	2853;"	d	file:
kfree_hook	./slub.c	/^static inline void kfree_hook(const void *x)$/;"	f	file:
khugepaged	./huge_memory.c	/^static int khugepaged(void *none)$/;"	f	file:
khugepaged_alloc_hugepage	./huge_memory.c	/^static struct page *khugepaged_alloc_hugepage(bool *wait)$/;"	f	file:
khugepaged_alloc_page	./huge_memory.c	/^*khugepaged_alloc_page(struct page **hpage, struct mm_struct *mm,$/;"	f	file:
khugepaged_alloc_sleep	./huge_memory.c	/^static void khugepaged_alloc_sleep(void)$/;"	f	file:
khugepaged_attr	./huge_memory.c	/^static struct attribute *khugepaged_attr[] = {$/;"	v	typeref:struct:attribute	file:
khugepaged_attr_group	./huge_memory.c	/^static struct attribute_group khugepaged_attr_group = {$/;"	v	typeref:struct:attribute_group	file:
khugepaged_defrag_attr	./huge_memory.c	/^static struct kobj_attribute khugepaged_defrag_attr =$/;"	v	typeref:struct:kobj_attribute	file:
khugepaged_defrag_show	./huge_memory.c	/^static ssize_t khugepaged_defrag_show(struct kobject *kobj,$/;"	f	file:
khugepaged_defrag_store	./huge_memory.c	/^static ssize_t khugepaged_defrag_store(struct kobject *kobj,$/;"	f	file:
khugepaged_do_scan	./huge_memory.c	/^static void khugepaged_do_scan(void)$/;"	f	file:
khugepaged_enter_vma_merge	./huge_memory.c	/^int khugepaged_enter_vma_merge(struct vm_area_struct *vma)$/;"	f
khugepaged_find_target_node	./huge_memory.c	/^static int khugepaged_find_target_node(void)$/;"	f	file:
khugepaged_full_scans	./huge_memory.c	/^static unsigned int khugepaged_full_scans;$/;"	v	file:
khugepaged_has_work	./huge_memory.c	/^static int khugepaged_has_work(void)$/;"	f	file:
khugepaged_max_ptes_none_attr	./huge_memory.c	/^static struct kobj_attribute khugepaged_max_ptes_none_attr =$/;"	v	typeref:struct:kobj_attribute	file:
khugepaged_max_ptes_none_show	./huge_memory.c	/^static ssize_t khugepaged_max_ptes_none_show(struct kobject *kobj,$/;"	f	file:
khugepaged_max_ptes_none_store	./huge_memory.c	/^static ssize_t khugepaged_max_ptes_none_store(struct kobject *kobj,$/;"	f	file:
khugepaged_node_load	./huge_memory.c	/^static int khugepaged_node_load[MAX_NUMNODES];$/;"	v	file:
khugepaged_pages_collapsed	./huge_memory.c	/^static unsigned int khugepaged_pages_collapsed;$/;"	v	file:
khugepaged_prealloc_page	./huge_memory.c	/^static bool khugepaged_prealloc_page(struct page **hpage, bool *wait)$/;"	f	file:
khugepaged_scan	./huge_memory.c	/^static struct khugepaged_scan khugepaged_scan = {$/;"	v	typeref:struct:khugepaged_scan	file:
khugepaged_scan	./huge_memory.c	/^struct khugepaged_scan {$/;"	s	file:
khugepaged_scan_pmd	./huge_memory.c	/^static int khugepaged_scan_pmd(struct mm_struct *mm,$/;"	f	file:
khugepaged_slab_init	./huge_memory.c	/^static int __init khugepaged_slab_init(void)$/;"	f	file:
khugepaged_test_exit	./huge_memory.c	/^static inline int khugepaged_test_exit(struct mm_struct *mm)$/;"	f	file:
khugepaged_wait_event	./huge_memory.c	/^static int khugepaged_wait_event(void)$/;"	f	file:
khugepaged_wait_work	./huge_memory.c	/^static void khugepaged_wait_work(void)$/;"	f	file:
kill_proc	./memory-failure.c	/^static int kill_proc(struct task_struct *t, unsigned long addr, int trapno,$/;"	f	file:
kill_procs	./memory-failure.c	/^static void kill_procs(struct list_head *to_kill, int forcekill, int trapno,$/;"	f	file:
kleave	./nommu.c	52;"	d	file:
kmalloc	./util.c	/^EXPORT_TRACEPOINT_SYMBOL(kmalloc);$/;"	v
kmalloc_caches	./slab_common.c	/^EXPORT_SYMBOL(kmalloc_caches);$/;"	v
kmalloc_caches	./slab_common.c	/^struct kmem_cache *kmalloc_caches[KMALLOC_SHIFT_HIGH + 1];$/;"	v	typeref:struct:kmem_cache
kmalloc_dma_caches	./slab_common.c	/^EXPORT_SYMBOL(kmalloc_dma_caches);$/;"	v
kmalloc_dma_caches	./slab_common.c	/^struct kmem_cache *kmalloc_dma_caches[KMALLOC_SHIFT_HIGH + 1];$/;"	v	typeref:struct:kmem_cache
kmalloc_large_node	./slub.c	/^static void *kmalloc_large_node(size_t size, gfp_t flags, int node)$/;"	f	file:
kmalloc_large_node_hook	./slub.c	/^static inline void kmalloc_large_node_hook(void *ptr, size_t size, gfp_t flags)$/;"	f	file:
kmalloc_node	./util.c	/^EXPORT_TRACEPOINT_SYMBOL(kmalloc_node);$/;"	v
kmalloc_order_trace	./slab_common.c	/^EXPORT_SYMBOL(kmalloc_order_trace);$/;"	v
kmalloc_order_trace	./slab_common.c	/^void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order)$/;"	f
kmalloc_section_memmap	./sparse.c	/^static inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid)$/;"	f	file:
kmalloc_slab	./slab_common.c	/^struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)$/;"	f
kmap_flush_unused	./highmem.c	/^void kmap_flush_unused(void)$/;"	f
kmap_high	./highmem.c	/^EXPORT_SYMBOL(kmap_high);$/;"	v
kmap_high	./highmem.c	/^void *kmap_high(struct page *page)$/;"	f
kmap_high_get	./highmem.c	/^void *kmap_high_get(struct page *page)$/;"	f
kmap_to_page	./highmem.c	/^EXPORT_SYMBOL(kmap_to_page);$/;"	v
kmap_to_page	./highmem.c	/^struct page *kmap_to_page(void *vaddr)$/;"	f
kmem	./memcontrol.c	/^	struct res_counter kmem;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::res_counter	file:
kmem_account_flags	./memcontrol.c	/^	unsigned long kmem_account_flags; \/* See KMEM_ACCOUNTED_*, below *\/$/;"	m	struct:mem_cgroup	file:
kmem_cache	./slab_common.c	/^struct kmem_cache *kmem_cache;$/;"	v	typeref:struct:kmem_cache
kmem_cache_alloc	./slab.c	/^EXPORT_SYMBOL(kmem_cache_alloc);$/;"	v
kmem_cache_alloc	./slab.c	/^void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)$/;"	f
kmem_cache_alloc	./slob.c	/^EXPORT_SYMBOL(kmem_cache_alloc);$/;"	v
kmem_cache_alloc	./slob.c	/^void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)$/;"	f
kmem_cache_alloc	./slub.c	/^EXPORT_SYMBOL(kmem_cache_alloc);$/;"	v
kmem_cache_alloc	./slub.c	/^void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)$/;"	f
kmem_cache_alloc	./util.c	/^EXPORT_TRACEPOINT_SYMBOL(kmem_cache_alloc);$/;"	v
kmem_cache_alloc_node	./slab.c	/^EXPORT_SYMBOL(kmem_cache_alloc_node);$/;"	v
kmem_cache_alloc_node	./slab.c	/^void *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid)$/;"	f
kmem_cache_alloc_node	./slob.c	/^EXPORT_SYMBOL(kmem_cache_alloc_node);$/;"	v
kmem_cache_alloc_node	./slob.c	/^void *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t gfp, int node)$/;"	f
kmem_cache_alloc_node	./slub.c	/^EXPORT_SYMBOL(kmem_cache_alloc_node);$/;"	v
kmem_cache_alloc_node	./slub.c	/^void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)$/;"	f
kmem_cache_alloc_node	./util.c	/^EXPORT_TRACEPOINT_SYMBOL(kmem_cache_alloc_node);$/;"	v
kmem_cache_alloc_node_trace	./slab.c	/^EXPORT_SYMBOL(kmem_cache_alloc_node_trace);$/;"	v
kmem_cache_alloc_node_trace	./slab.c	/^void *kmem_cache_alloc_node_trace(struct kmem_cache *cachep,$/;"	f
kmem_cache_alloc_node_trace	./slub.c	/^EXPORT_SYMBOL(kmem_cache_alloc_node_trace);$/;"	v
kmem_cache_alloc_node_trace	./slub.c	/^void *kmem_cache_alloc_node_trace(struct kmem_cache *s,$/;"	f
kmem_cache_alloc_trace	./slab.c	/^EXPORT_SYMBOL(kmem_cache_alloc_trace);$/;"	v
kmem_cache_alloc_trace	./slab.c	/^kmem_cache_alloc_trace(struct kmem_cache *cachep, gfp_t flags, size_t size)$/;"	f
kmem_cache_alloc_trace	./slub.c	/^EXPORT_SYMBOL(kmem_cache_alloc_trace);$/;"	v
kmem_cache_alloc_trace	./slub.c	/^void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)$/;"	f
kmem_cache_boot	./slab.c	/^static struct kmem_cache kmem_cache_boot = {$/;"	v	typeref:struct:kmem_cache	file:
kmem_cache_boot	./slob.c	/^struct kmem_cache kmem_cache_boot = {$/;"	v	typeref:struct:kmem_cache
kmem_cache_close	./slub.c	/^static inline int kmem_cache_close(struct kmem_cache *s)$/;"	f	file:
kmem_cache_create	./slab_common.c	/^EXPORT_SYMBOL(kmem_cache_create);$/;"	v
kmem_cache_create	./slab_common.c	/^kmem_cache_create(const char *name, size_t size, size_t align,$/;"	f
kmem_cache_create_memcg	./slab_common.c	/^void kmem_cache_create_memcg(struct mem_cgroup *memcg, struct kmem_cache *root_cache)$/;"	f
kmem_cache_debug	./slub.c	/^static inline int kmem_cache_debug(struct kmem_cache *s)$/;"	f	file:
kmem_cache_destroy	./slab_common.c	/^EXPORT_SYMBOL(kmem_cache_destroy);$/;"	v
kmem_cache_destroy	./slab_common.c	/^void kmem_cache_destroy(struct kmem_cache *s)$/;"	f
kmem_cache_destroy_memcg_children	./slab_common.c	/^static int kmem_cache_destroy_memcg_children(struct kmem_cache *s)$/;"	f	file:
kmem_cache_destroy_work_func	./memcontrol.c	/^static void kmem_cache_destroy_work_func(struct work_struct *w)$/;"	f	file:
kmem_cache_flags	./slub.c	/^static inline unsigned long kmem_cache_flags(unsigned long object_size,$/;"	f	file:
kmem_cache_flags	./slub.c	/^static unsigned long kmem_cache_flags(unsigned long object_size,$/;"	f	file:
kmem_cache_free	./slab.c	/^EXPORT_SYMBOL(kmem_cache_free);$/;"	v
kmem_cache_free	./slab.c	/^void kmem_cache_free(struct kmem_cache *cachep, void *objp)$/;"	f
kmem_cache_free	./slob.c	/^EXPORT_SYMBOL(kmem_cache_free);$/;"	v
kmem_cache_free	./slob.c	/^void kmem_cache_free(struct kmem_cache *c, void *b)$/;"	f
kmem_cache_free	./slub.c	/^EXPORT_SYMBOL(kmem_cache_free);$/;"	v
kmem_cache_free	./slub.c	/^void kmem_cache_free(struct kmem_cache *s, void *x)$/;"	f
kmem_cache_free	./util.c	/^EXPORT_TRACEPOINT_SYMBOL(kmem_cache_free);$/;"	v
kmem_cache_has_cpu_partial	./slub.c	/^static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)$/;"	f	file:
kmem_cache_init	./slab.c	/^void __init kmem_cache_init(void)$/;"	f
kmem_cache_init	./slob.c	/^void __init kmem_cache_init(void)$/;"	f
kmem_cache_init	./slub.c	/^void __init kmem_cache_init(void)$/;"	f
kmem_cache_init_late	./slab.c	/^void __init kmem_cache_init_late(void)$/;"	f
kmem_cache_init_late	./slob.c	/^void __init kmem_cache_init_late(void)$/;"	f
kmem_cache_init_late	./slub.c	/^void __init kmem_cache_init_late(void)$/;"	f
kmem_cache_node	./slab.h	/^struct kmem_cache_node {$/;"	s
kmem_cache_node	./slub.c	/^static struct kmem_cache *kmem_cache_node;$/;"	v	typeref:struct:kmem_cache	file:
kmem_cache_node_init	./slab.c	/^static void kmem_cache_node_init(struct kmem_cache_node *parent)$/;"	f	file:
kmem_cache_open	./slub.c	/^static int kmem_cache_open(struct kmem_cache *s, unsigned long flags)$/;"	f	file:
kmem_cache_release	./slub.c	/^static void kmem_cache_release(struct kobject *k)$/;"	f	file:
kmem_cache_sanity_check	./slab_common.c	/^static inline int kmem_cache_sanity_check(const char *name, size_t size)$/;"	f	file:
kmem_cache_sanity_check	./slab_common.c	/^static int kmem_cache_sanity_check(const char *name, size_t size)$/;"	f	file:
kmem_cache_shrink	./slab.c	/^EXPORT_SYMBOL(kmem_cache_shrink);$/;"	v
kmem_cache_shrink	./slab.c	/^int kmem_cache_shrink(struct kmem_cache *cachep)$/;"	f
kmem_cache_shrink	./slob.c	/^EXPORT_SYMBOL(kmem_cache_shrink);$/;"	v
kmem_cache_shrink	./slob.c	/^int kmem_cache_shrink(struct kmem_cache *d)$/;"	f
kmem_cache_shrink	./slub.c	/^EXPORT_SYMBOL(kmem_cache_shrink);$/;"	v
kmem_cache_shrink	./slub.c	/^int kmem_cache_shrink(struct kmem_cache *s)$/;"	f
kmem_cgroup_css_offline	./memcontrol.c	/^static void kmem_cgroup_css_offline(struct mem_cgroup *memcg)$/;"	f	file:
kmem_flagcheck	./slab.c	/^static void kmem_flagcheck(struct kmem_cache *cachep, gfp_t flags)$/;"	f	file:
kmem_freepages	./slab.c	/^static void kmem_freepages(struct kmem_cache *cachep, struct page *page)$/;"	f	file:
kmem_getpages	./slab.c	/^static struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,$/;"	f	file:
kmem_rcu_free	./slab.c	/^static void kmem_rcu_free(struct rcu_head *head)$/;"	f	file:
kmem_rcu_free	./slob.c	/^static void kmem_rcu_free(struct rcu_head *head)$/;"	f	file:
kmemcg_id	./memcontrol.c	/^	int kmemcg_id;$/;"	m	struct:mem_cgroup	file:
kmemcheck_alloc_shadow	./kmemcheck.c	/^void kmemcheck_alloc_shadow(struct page *page, int order, gfp_t flags, int node)$/;"	f
kmemcheck_free_shadow	./kmemcheck.c	/^void kmemcheck_free_shadow(struct page *page, int order)$/;"	f
kmemcheck_pagealloc_alloc	./kmemcheck.c	/^void kmemcheck_pagealloc_alloc(struct page *page, unsigned int order,$/;"	f
kmemcheck_slab_alloc	./kmemcheck.c	/^void kmemcheck_slab_alloc(struct kmem_cache *s, gfp_t gfpflags, void *object,$/;"	f
kmemcheck_slab_free	./kmemcheck.c	/^void kmemcheck_slab_free(struct kmem_cache *s, void *object, size_t size)$/;"	f
kmemdup	./util.c	/^EXPORT_SYMBOL(kmemdup);$/;"	v
kmemdup	./util.c	/^void *kmemdup(const void *src, size_t len, gfp_t gfp)$/;"	f
kmemleak_alloc	./kmemleak.c	/^EXPORT_SYMBOL_GPL(kmemleak_alloc);$/;"	v
kmemleak_alloc	./kmemleak.c	/^void __ref kmemleak_alloc(const void *ptr, size_t size, int min_count,$/;"	f
kmemleak_alloc_percpu	./kmemleak.c	/^EXPORT_SYMBOL_GPL(kmemleak_alloc_percpu);$/;"	v
kmemleak_alloc_percpu	./kmemleak.c	/^void __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size)$/;"	f
kmemleak_boot_config	./kmemleak.c	/^static int kmemleak_boot_config(char *str)$/;"	f	file:
kmemleak_clear	./kmemleak.c	/^static void kmemleak_clear(void)$/;"	f	file:
kmemleak_disable	./kmemleak.c	/^static void kmemleak_disable(void)$/;"	f	file:
kmemleak_do_cleanup	./kmemleak.c	/^static void kmemleak_do_cleanup(struct work_struct *work)$/;"	f	file:
kmemleak_early_log	./kmemleak.c	/^static int kmemleak_early_log = 1;$/;"	v	file:
kmemleak_enabled	./kmemleak.c	/^static int kmemleak_enabled;$/;"	v	file:
kmemleak_error	./kmemleak.c	/^static int kmemleak_error;$/;"	v	file:
kmemleak_fops	./kmemleak.c	/^static const struct file_operations kmemleak_fops = {$/;"	v	typeref:struct:file_operations	file:
kmemleak_found_leaks	./kmemleak.c	/^static bool kmemleak_found_leaks;$/;"	v	file:
kmemleak_free	./kmemleak.c	/^EXPORT_SYMBOL_GPL(kmemleak_free);$/;"	v
kmemleak_free	./kmemleak.c	/^void __ref kmemleak_free(const void *ptr)$/;"	f
kmemleak_free_part	./kmemleak.c	/^EXPORT_SYMBOL_GPL(kmemleak_free_part);$/;"	v
kmemleak_free_part	./kmemleak.c	/^void __ref kmemleak_free_part(const void *ptr, size_t size)$/;"	f
kmemleak_free_percpu	./kmemleak.c	/^EXPORT_SYMBOL_GPL(kmemleak_free_percpu);$/;"	v
kmemleak_free_percpu	./kmemleak.c	/^void __ref kmemleak_free_percpu(const void __percpu *ptr)$/;"	f
kmemleak_ignore	./kmemleak.c	/^EXPORT_SYMBOL(kmemleak_ignore);$/;"	v
kmemleak_ignore	./kmemleak.c	/^void __ref kmemleak_ignore(const void *ptr)$/;"	f
kmemleak_init	./kmemleak.c	/^void __init kmemleak_init(void)$/;"	f
kmemleak_initialized	./kmemleak.c	/^static int kmemleak_initialized;$/;"	v	file:
kmemleak_late_init	./kmemleak.c	/^late_initcall(kmemleak_late_init);$/;"	v
kmemleak_late_init	./kmemleak.c	/^static int __init kmemleak_late_init(void)$/;"	f	file:
kmemleak_no_scan	./kmemleak.c	/^EXPORT_SYMBOL(kmemleak_no_scan);$/;"	v
kmemleak_no_scan	./kmemleak.c	/^void __ref kmemleak_no_scan(const void *ptr)$/;"	f
kmemleak_not_leak	./kmemleak.c	/^EXPORT_SYMBOL(kmemleak_not_leak);$/;"	v
kmemleak_not_leak	./kmemleak.c	/^void __ref kmemleak_not_leak(const void *ptr)$/;"	f
kmemleak_object	./kmemleak.c	/^struct kmemleak_object {$/;"	s	file:
kmemleak_open	./kmemleak.c	/^static int kmemleak_open(struct inode *inode, struct file *file)$/;"	f	file:
kmemleak_scan	./kmemleak.c	/^static void kmemleak_scan(void)$/;"	f	file:
kmemleak_scan_area	./kmemleak.c	/^EXPORT_SYMBOL(kmemleak_scan_area);$/;"	v
kmemleak_scan_area	./kmemleak.c	/^struct kmemleak_scan_area {$/;"	s	file:
kmemleak_scan_area	./kmemleak.c	/^void __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)$/;"	f
kmemleak_scan_thread	./kmemleak.c	/^static int kmemleak_scan_thread(void *arg)$/;"	f	file:
kmemleak_seq_next	./kmemleak.c	/^static void *kmemleak_seq_next(struct seq_file *seq, void *v, loff_t *pos)$/;"	f	file:
kmemleak_seq_ops	./kmemleak.c	/^static const struct seq_operations kmemleak_seq_ops = {$/;"	v	typeref:struct:seq_operations	file:
kmemleak_seq_show	./kmemleak.c	/^static int kmemleak_seq_show(struct seq_file *seq, void *v)$/;"	f	file:
kmemleak_seq_start	./kmemleak.c	/^static void *kmemleak_seq_start(struct seq_file *seq, loff_t *pos)$/;"	f	file:
kmemleak_seq_stop	./kmemleak.c	/^static void kmemleak_seq_stop(struct seq_file *seq, void *v)$/;"	f	file:
kmemleak_skip_disable	./kmemleak.c	/^static int kmemleak_skip_disable;$/;"	v	file:
kmemleak_stack_scan	./kmemleak.c	/^static int kmemleak_stack_scan = 1;$/;"	v	file:
kmemleak_stop	./kmemleak.c	279;"	d	file:
kmemleak_test_exit	./kmemleak-test.c	/^module_exit(kmemleak_test_exit);$/;"	v
kmemleak_test_exit	./kmemleak-test.c	/^static void __exit kmemleak_test_exit(void)$/;"	f	file:
kmemleak_test_init	./kmemleak-test.c	/^module_init(kmemleak_test_init);$/;"	v
kmemleak_test_init	./kmemleak-test.c	/^static int __init kmemleak_test_init(void)$/;"	f	file:
kmemleak_warn	./kmemleak.c	268;"	d	file:
kmemleak_warning	./kmemleak.c	/^static int kmemleak_warning;$/;"	v	file:
kmemleak_write	./kmemleak.c	/^static ssize_t kmemleak_write(struct file *file, const char __user *user_buf,$/;"	f	file:
kobj_to_hstate	./hugetlb.c	/^static struct hstate *kobj_to_hstate(struct kobject *kobj, int *nidp)$/;"	f	file:
kobj_to_node_hstate	./hugetlb.c	/^static struct hstate *kobj_to_node_hstate(struct kobject *kobj, int *nidp)$/;"	f	file:
kobjsize	./nommu.c	/^unsigned int kobjsize(const void *objp)$/;"	f
kpfn	./ksm.c	/^	unsigned long kpfn;$/;"	m	struct:stable_node	file:
krealloc	./util.c	/^EXPORT_SYMBOL(krealloc);$/;"	v
krealloc	./util.c	/^void *krealloc(const void *p, size_t new_size, gfp_t flags)$/;"	f
ksize	./slab.c	/^EXPORT_SYMBOL(ksize);$/;"	v
ksize	./slab.c	/^size_t ksize(const void *objp)$/;"	f
ksize	./slob.c	/^EXPORT_SYMBOL(ksize);$/;"	v
ksize	./slob.c	/^size_t ksize(const void *block)$/;"	f
ksize	./slub.c	/^EXPORT_SYMBOL(ksize);$/;"	v
ksize	./slub.c	/^size_t ksize(const void *object)$/;"	f
ksm_attr_group	./ksm.c	/^static struct attribute_group ksm_attr_group = {$/;"	v	typeref:struct:attribute_group	file:
ksm_attrs	./ksm.c	/^static struct attribute *ksm_attrs[] = {$/;"	v	typeref:struct:attribute	file:
ksm_check_stable_tree	./ksm.c	/^static void ksm_check_stable_tree(unsigned long start_pfn,$/;"	f	file:
ksm_do_scan	./ksm.c	/^static void ksm_do_scan(unsigned int scan_npages)$/;"	f	file:
ksm_init	./ksm.c	/^static int __init ksm_init(void)$/;"	f	file:
ksm_init	./ksm.c	/^subsys_initcall(ksm_init);$/;"	v
ksm_madvise	./ksm.c	/^int ksm_madvise(struct vm_area_struct *vma, unsigned long start,$/;"	f
ksm_memory_callback	./ksm.c	/^static int ksm_memory_callback(struct notifier_block *self,$/;"	f	file:
ksm_merge_across_nodes	./ksm.c	/^static unsigned int ksm_merge_across_nodes = 1;$/;"	v	file:
ksm_merge_across_nodes	./ksm.c	231;"	d	file:
ksm_might_need_to_copy	./ksm.c	/^struct page *ksm_might_need_to_copy(struct page *page,$/;"	f
ksm_migrate_page	./ksm.c	/^void ksm_migrate_page(struct page *newpage, struct page *oldpage)$/;"	f
ksm_mm_head	./ksm.c	/^static struct mm_slot ksm_mm_head = {$/;"	v	typeref:struct:mm_slot	file:
ksm_nr_node_ids	./ksm.c	/^static int ksm_nr_node_ids = 1;$/;"	v	file:
ksm_nr_node_ids	./ksm.c	232;"	d	file:
ksm_pages_shared	./ksm.c	/^static unsigned long ksm_pages_shared;$/;"	v	file:
ksm_pages_sharing	./ksm.c	/^static unsigned long ksm_pages_sharing;$/;"	v	file:
ksm_pages_unshared	./ksm.c	/^static unsigned long ksm_pages_unshared;$/;"	v	file:
ksm_rmap_items	./ksm.c	/^static unsigned long ksm_rmap_items;$/;"	v	file:
ksm_run	./ksm.c	/^static unsigned long ksm_run = KSM_RUN_STOP;$/;"	v	file:
ksm_scan	./ksm.c	/^static struct ksm_scan ksm_scan = {$/;"	v	typeref:struct:ksm_scan	file:
ksm_scan	./ksm.c	/^struct ksm_scan {$/;"	s	file:
ksm_scan_thread	./ksm.c	/^static int ksm_scan_thread(void *nothing)$/;"	f	file:
ksm_slab_free	./ksm.c	/^static void __init ksm_slab_free(void)$/;"	f	file:
ksm_slab_init	./ksm.c	/^static int __init ksm_slab_init(void)$/;"	f	file:
ksm_test_exit	./ksm.c	/^static inline bool ksm_test_exit(struct mm_struct *mm)$/;"	f	file:
ksm_thread_pages_to_scan	./ksm.c	/^static unsigned int ksm_thread_pages_to_scan = 100;$/;"	v	file:
ksm_thread_sleep_millisecs	./ksm.c	/^static unsigned int ksm_thread_sleep_millisecs = 20;$/;"	v	file:
ksmd_should_run	./ksm.c	/^static int ksmd_should_run(void)$/;"	f	file:
kstrdup	./util.c	/^EXPORT_SYMBOL(kstrdup);$/;"	v
kstrdup	./util.c	/^char *kstrdup(const char *s, gfp_t gfp)$/;"	f
kstrndup	./util.c	/^EXPORT_SYMBOL(kstrndup);$/;"	v
kstrndup	./util.c	/^char *kstrndup(const char *s, size_t max, gfp_t gfp)$/;"	f
kswapd	./vmscan.c	/^static int kswapd(void *p)$/;"	f	file:
kswapd_init	./vmscan.c	/^static int __init kswapd_init(void)$/;"	f	file:
kswapd_run	./vmscan.c	/^int kswapd_run(int nid)$/;"	f
kswapd_shrink_zone	./vmscan.c	/^static bool kswapd_shrink_zone(struct zone *zone,$/;"	f	file:
kswapd_stop	./vmscan.c	/^void kswapd_stop(int nid)$/;"	f
kswapd_try_to_sleep	./vmscan.c	/^static void kswapd_try_to_sleep(pg_data_t *pgdat, int order, int classzone_idx)$/;"	f	file:
kunmap_high	./highmem.c	/^EXPORT_SYMBOL(kunmap_high);$/;"	v
kunmap_high	./highmem.c	/^void kunmap_high(struct page *page)$/;"	f
kvfree	./util.c	/^EXPORT_SYMBOL(kvfree);$/;"	v
kvfree	./util.c	/^void kvfree(const void *addr)$/;"	f
kzfree	./util.c	/^EXPORT_SYMBOL(kzfree);$/;"	v
kzfree	./util.c	/^void kzfree(const void *p)$/;"	f
laptop_io_completion	./page-writeback.c	/^void laptop_io_completion(struct backing_dev_info *info)$/;"	f
laptop_mode	./page-writeback.c	/^EXPORT_SYMBOL(laptop_mode);$/;"	v
laptop_mode	./page-writeback.c	/^int laptop_mode;$/;"	v
laptop_mode_timer_fn	./page-writeback.c	/^void laptop_mode_timer_fn(unsigned long data)$/;"	f
laptop_sync_completion	./page-writeback.c	/^void laptop_sync_completion(void)$/;"	f
last_chunks	./zbud.c	/^	unsigned int last_chunks;$/;"	m	struct:zbud_header	file:
last_dead_count	./memcontrol.c	/^	int last_dead_count;$/;"	m	struct:mem_cgroup_reclaim_iter	file:
last_pkmap_nr	./highmem.c	/^static unsigned int last_pkmap_nr;$/;"	v	file:
last_scanned_node	./memcontrol.c	/^	int last_scanned_node;$/;"	m	struct:mem_cgroup	file:
last_visited	./memcontrol.c	/^	struct mem_cgroup *last_visited;$/;"	m	struct:mem_cgroup_reclaim_iter	typeref:struct:mem_cgroup_reclaim_iter::mem_cgroup	file:
lazy_max_pages	./vmalloc.c	/^static unsigned long lazy_max_pages(void)$/;"	f	file:
leaks_show	./slab.c	/^static int leaks_show(struct seq_file *m, void *p)$/;"	f	file:
leaks_start	./slab.c	/^static void *leaks_start(struct seq_file *m, loff_t *pos)$/;"	f	file:
least_priority	./swapfile.c	/^static int least_priority;$/;"	v	file:
len	./mmap.c	/^	unsigned long len;$/;"	m	struct:mmap_arg_struct	file:
len	./nommu.c	/^	unsigned long len;$/;"	m	struct:mmap_arg_struct	file:
length	./page_cgroup.c	/^	unsigned long length;$/;"	m	struct:swap_cgroup_ctrl	file:
length	./zswap.c	/^	unsigned int length;$/;"	m	struct:zswap_entry	file:
level	./vmpressure.c	/^	enum vmpressure_levels level;$/;"	m	struct:vmpressure_event	typeref:enum:vmpressure_event::vmpressure_levels	file:
lh	./highmem.c	/^	struct list_head lh;			\/* List of page_address_maps *\/$/;"	m	struct:page_address_slot	typeref:struct:page_address_slot::list_head	file:
limit	./slab.c	/^	unsigned int limit;$/;"	m	struct:array_cache	file:
limit	./slab.h	/^	unsigned int limit;$/;"	m	struct:slabinfo
linear_hugepage_index	./hugetlb.c	/^pgoff_t linear_hugepage_index(struct vm_area_struct *vma,$/;"	f
link	./hugetlb.c	/^	struct list_head link;$/;"	m	struct:file_region	typeref:struct:file_region::list_head	file:
link	./ksm.c	/^	struct hlist_node link;$/;"	m	struct:mm_slot	typeref:struct:mm_slot::hlist_node	file:
link_bootmem	./bootmem.c	/^static void __init link_bootmem(bootmem_data_t *bdata)$/;"	f	file:
link_free	./zsmalloc.c	/^struct link_free {$/;"	s	file:
list	./highmem.c	/^	struct list_head list;$/;"	m	struct:page_address_map	typeref:struct:page_address_map::list_head	file:
list	./kmemleak-test.c	/^	struct list_head list;$/;"	m	struct:test_node	typeref:struct:test_node::list_head	file:
list	./ksm.c	/^			struct list_head list;$/;"	m	struct:stable_node::__anon5::__anon6	typeref:struct:stable_node::__anon5::__anon6::list_head	file:
list	./memcontrol.c	/^	struct list_head list;$/;"	m	struct:mem_cgroup_event	typeref:struct:mem_cgroup_event::list_head	file:
list	./memcontrol.c	/^	struct list_head list;$/;"	m	struct:mem_cgroup_eventfd_list	typeref:struct:mem_cgroup_eventfd_list::list_head	file:
list	./percpu.c	/^	struct list_head	list;		\/* linked to pcpu_slot lists *\/$/;"	m	struct:pcpu_chunk	typeref:struct:pcpu_chunk::list_head	file:
list	./vmalloc.c	/^	struct llist_head list;$/;"	m	struct:vfree_deferred	typeref:struct:vfree_deferred::llist_head	file:
list_locations	./slub.c	/^static int list_locations(struct kmem_cache *s, char *buf,$/;"	f	file:
list_lock	./slab.h	/^	spinlock_t list_lock;$/;"	m	struct:kmem_cache_node
list_lru_add	./list_lru.c	/^EXPORT_SYMBOL_GPL(list_lru_add);$/;"	v
list_lru_add	./list_lru.c	/^bool list_lru_add(struct list_lru *lru, struct list_head *item)$/;"	f
list_lru_count_node	./list_lru.c	/^EXPORT_SYMBOL_GPL(list_lru_count_node);$/;"	v
list_lru_count_node	./list_lru.c	/^list_lru_count_node(struct list_lru *lru, int nid)$/;"	f
list_lru_del	./list_lru.c	/^EXPORT_SYMBOL_GPL(list_lru_del);$/;"	v
list_lru_del	./list_lru.c	/^bool list_lru_del(struct list_lru *lru, struct list_head *item)$/;"	f
list_lru_destroy	./list_lru.c	/^EXPORT_SYMBOL_GPL(list_lru_destroy);$/;"	v
list_lru_destroy	./list_lru.c	/^void list_lru_destroy(struct list_lru *lru)$/;"	f
list_lru_init_key	./list_lru.c	/^EXPORT_SYMBOL_GPL(list_lru_init_key);$/;"	v
list_lru_init_key	./list_lru.c	/^int list_lru_init_key(struct list_lru *lru, struct lock_class_key *key)$/;"	f
list_lru_walk_node	./list_lru.c	/^EXPORT_SYMBOL_GPL(list_lru_walk_node);$/;"	v
list_lru_walk_node	./list_lru.c	/^list_lru_walk_node(struct list_lru *lru, int nid, list_lru_walk_cb isolate,$/;"	f
list_slab_objects	./slub.c	/^static void list_slab_objects(struct kmem_cache *s, struct page *page,$/;"	f	file:
list_tail_entry	./zbud.c	363;"	d	file:
list_to_page	./readahead.c	35;"	d	file:
loc	./slub.c	/^	struct location *loc;$/;"	m	struct:loc_track	typeref:struct:loc_track::location	file:
loc_track	./slub.c	/^struct loc_track {$/;"	s	file:
local_memory_node	./page_alloc.c	/^int local_memory_node(int node)$/;"	f
location	./slub.c	/^struct location {$/;"	s	file:
lock	./dmapool.c	/^	spinlock_t lock;$/;"	m	struct:dma_pool	file:
lock	./highmem.c	/^	spinlock_t lock;			\/* Protect this bucket's list *\/$/;"	m	struct:page_address_slot	file:
lock	./kmemleak.c	/^	spinlock_t lock;$/;"	m	struct:kmemleak_object	file:
lock	./memcontrol.c	/^	spinlock_t	  lock; \/* for from, to *\/$/;"	m	struct:move_charge_struct	file:
lock	./memcontrol.c	/^	spinlock_t lock;$/;"	m	struct:mem_cgroup_tree_per_zone	file:
lock	./memory-failure.c	/^	spinlock_t lock;$/;"	m	struct:memory_failure_cpu	file:
lock	./page_cgroup.c	/^	spinlock_t	lock;$/;"	m	struct:swap_cgroup_ctrl	file:
lock	./slab.c	/^	spinlock_t lock;$/;"	m	struct:array_cache	file:
lock	./vmalloc.c	/^	spinlock_t lock;$/;"	m	struct:vmap_block	file:
lock	./vmalloc.c	/^	spinlock_t lock;$/;"	m	struct:vmap_block_queue	file:
lock	./zbud.c	/^	spinlock_t lock;$/;"	m	struct:zbud_pool	file:
lock	./zsmalloc.c	/^	spinlock_t lock;$/;"	m	struct:size_class	file:
lock	./zswap.c	/^	spinlock_t lock;$/;"	m	struct:zswap_tree	file:
lock_anon_vma_root	./rmap.c	/^static inline struct anon_vma *lock_anon_vma_root(struct anon_vma *root, struct anon_vma *anon_vma)$/;"	f	file:
lock_kmap	./highmem.c	84;"	d	file:
lock_kmap	./highmem.c	89;"	d	file:
lock_kmap_any	./highmem.c	86;"	d	file:
lock_kmap_any	./highmem.c	91;"	d	file:
lock_memory_hotplug	./memory_hotplug.c	/^void lock_memory_hotplug(void)$/;"	f
lock_pte_protection	./mprotect.c	/^static pte_t *lock_pte_protection(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f	file:
log_early	./kmemleak.c	/^static void __init log_early(int op_type, const void *ptr, size_t size,$/;"	f	file:
lookup_node	./mempolicy.c	/^static int lookup_node(struct mm_struct *mm, unsigned long addr)$/;"	f	file:
lookup_object	./kmemleak.c	/^static struct kmemleak_object *lookup_object(unsigned long ptr, int alias)$/;"	f	file:
lookup_page_cgroup	./page_cgroup.c	/^struct page_cgroup *lookup_page_cgroup(struct page *page)$/;"	f
lookup_page_cgroup_used	./memcontrol.c	/^static struct page_cgroup *lookup_page_cgroup_used(struct page *page)$/;"	f	file:
lookup_swap_cache	./swap_state.c	/^struct page * lookup_swap_cache(swp_entry_t entry)$/;"	f
lookup_swap_cgroup	./page_cgroup.c	/^static struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,$/;"	f	file:
lookup_swap_cgroup_id	./page_cgroup.c	/^unsigned short lookup_swap_cgroup_id(swp_entry_t ent)$/;"	f
lowmem_reserve_ratio_sysctl_handler	./page_alloc.c	/^int lowmem_reserve_ratio_sysctl_handler(ctl_table *table, int write,$/;"	f
lru	./memory-failure.c	748;"	d	file:
lru	./memory-failure.c	805;"	d	file:
lru	./zbud.c	/^	struct list_head lru;$/;"	m	struct:zbud_header	typeref:struct:zbud_header::list_head	file:
lru	./zbud.c	/^	struct list_head lru;$/;"	m	struct:zbud_pool	typeref:struct:zbud_pool::list_head	file:
lru_add_drain	./swap.c	/^void lru_add_drain(void)$/;"	f
lru_add_drain_all	./swap.c	/^void lru_add_drain_all(void)$/;"	f
lru_add_drain_cpu	./swap.c	/^void lru_add_drain_cpu(int cpu)$/;"	f
lru_add_drain_per_cpu	./swap.c	/^static void lru_add_drain_per_cpu(struct work_struct *dummy)$/;"	f	file:
lru_add_page_tail	./swap.c	/^void lru_add_page_tail(struct page *page, struct page *page_tail,$/;"	f
lru_cache_add	./swap.c	/^void lru_cache_add(struct page *page)$/;"	f
lru_deactivate_fn	./swap.c	/^static void lru_deactivate_fn(struct page *page, struct lruvec *lruvec,$/;"	f	file:
lru_size	./memcontrol.c	/^	unsigned long		lru_size[NR_LRU_LISTS];$/;"	m	struct:mem_cgroup_per_zone	file:
lru_to_page	./vmscan.c	99;"	d	file:
lruvec	./memcontrol.c	/^	struct lruvec		lruvec;$/;"	m	struct:mem_cgroup_per_zone	typeref:struct:mem_cgroup_per_zone::lruvec	file:
lruvec_init	./mmzone.c	/^void lruvec_init(struct lruvec *lruvec)$/;"	f
madvise_behavior	./madvise.c	/^static long madvise_behavior(struct vm_area_struct *vma,$/;"	f	file:
madvise_behavior_valid	./madvise.c	/^madvise_behavior_valid(int behavior)$/;"	f	file:
madvise_dontneed	./madvise.c	/^static long madvise_dontneed(struct vm_area_struct *vma,$/;"	f	file:
madvise_hwpoison	./madvise.c	/^static int madvise_hwpoison(int bhv, unsigned long start, unsigned long end)$/;"	f	file:
madvise_need_mmap_write	./madvise.c	/^static int madvise_need_mmap_write(int behavior)$/;"	f	file:
madvise_remove	./madvise.c	/^static long madvise_remove(struct vm_area_struct *vma,$/;"	f	file:
madvise_vma	./madvise.c	/^madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,$/;"	f	file:
madvise_willneed	./madvise.c	/^static long madvise_willneed(struct vm_area_struct *vma,$/;"	f	file:
make_alloc_exact	./page_alloc.c	/^static void *make_alloc_exact(unsigned long addr, unsigned order, size_t size)$/;"	f	file:
make_black_object	./kmemleak.c	/^static void make_black_object(unsigned long ptr)$/;"	f	file:
make_gray_object	./kmemleak.c	/^static void make_gray_object(unsigned long ptr)$/;"	f	file:
make_huge_pte	./hugetlb.c	/^static pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,$/;"	f	file:
map	./page_cgroup.c	/^	struct page **map;$/;"	m	struct:swap_cgroup_ctrl	typeref:struct:swap_cgroup_ctrl::page	file:
map	./percpu.c	/^	int			*map;		\/* allocation map *\/$/;"	m	struct:pcpu_chunk	file:
map_alloc	./percpu.c	/^	int			map_alloc;	\/* # of map entries allocated *\/$/;"	m	struct:pcpu_chunk	file:
map_kernel_range_noflush	./vmalloc.c	/^int map_kernel_range_noflush(unsigned long addr, unsigned long size,$/;"	f
map_new_virtual	./highmem.c	/^static inline unsigned long map_new_virtual(struct page *page)$/;"	f	file:
map_pages	./compaction.c	/^static void map_pages(struct list_head *list)$/;"	f	file:
map_swap_entry	./swapfile.c	/^static sector_t map_swap_entry(swp_entry_t entry, struct block_device **bdev)$/;"	f	file:
map_swap_page	./swapfile.c	/^sector_t map_swap_page(struct page *page, struct block_device **bdev)$/;"	f
map_used	./percpu.c	/^	int			map_used;	\/* # of map entries used before the sentry *\/$/;"	m	struct:pcpu_chunk	file:
map_vm_area	./vmalloc.c	/^EXPORT_SYMBOL_GPL(map_vm_area);$/;"	v
map_vm_area	./vmalloc.c	/^int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page ***pages)$/;"	f
mapcount	./rmap.c	/^	int mapcount;$/;"	m	struct:page_referenced_arg	file:
mapping_area	./zsmalloc.c	/^struct mapping_area {$/;"	s	file:
mapping_tagged	./page-writeback.c	/^EXPORT_SYMBOL(mapping_tagged);$/;"	v
mapping_tagged	./page-writeback.c	/^int mapping_tagged(struct address_space *mapping, int tag)$/;"	f
mark_bootmem	./bootmem.c	/^static int __init mark_bootmem(unsigned long start, unsigned long end,$/;"	f	file:
mark_bootmem_node	./bootmem.c	/^static int __init mark_bootmem_node(bootmem_data_t *bdata,$/;"	f	file:
mark_free_pages	./page_alloc.c	/^void mark_free_pages(struct zone *zone)$/;"	f
mark_page_accessed	./swap.c	/^EXPORT_SYMBOL(mark_page_accessed);$/;"	v
mark_page_accessed	./swap.c	/^void mark_page_accessed(struct page *page)$/;"	f
mask	./memory-failure.c	/^	unsigned long mask;$/;"	m	struct:page_state	file:
max	./slub.c	/^	unsigned long max;$/;"	m	struct:loc_track	file:
max_addr	./kmemleak.c	/^static unsigned long max_addr;$/;"	v	file:
max_low_pfn	./bootmem.c	/^unsigned long max_low_pfn;$/;"	v
max_low_pfn	./nobootmem.c	/^unsigned long max_low_pfn;$/;"	v
max_mapnr	./memory.c	/^EXPORT_SYMBOL(max_mapnr);$/;"	v
max_mapnr	./memory.c	/^unsigned long max_mapnr;$/;"	v
max_mapnr	./nommu.c	/^unsigned long max_mapnr;$/;"	v
max_pages	./quicklist.c	/^static unsigned long max_pages(unsigned long min_pages)$/;"	f	file:
max_pfn	./bootmem.c	/^unsigned long max_pfn;$/;"	v
max_pfn	./nobootmem.c	/^unsigned long max_pfn;$/;"	v
max_pid	./slub.c	/^	long max_pid;$/;"	m	struct:location	file:
max_ratio_store	./backing-dev.c	/^static ssize_t max_ratio_store(struct device *dev,$/;"	f	file:
max_sane_readahead	./readahead.c	/^unsigned long max_sane_readahead(unsigned long nr)$/;"	f
max_swapfiles_check	./swapfile.c	/^late_initcall(max_swapfiles_check);$/;"	v
max_swapfiles_check	./swapfile.c	/^static int __init max_swapfiles_check(void)$/;"	f	file:
max_time	./slub.c	/^	long max_time;$/;"	m	struct:location	file:
may_expand_vm	./mmap.c	/^int may_expand_vm(struct mm_struct *mm, unsigned long npages)$/;"	f
may_swap	./vmscan.c	/^	int may_swap;$/;"	m	struct:scan_control	file:
may_unmap	./vmscan.c	/^	int may_unmap;$/;"	m	struct:scan_control	file:
may_write_to_queue	./vmscan.c	/^static int may_write_to_queue(struct backing_dev_info *bdi,$/;"	f	file:
may_writepage	./vmscan.c	/^	int may_writepage;$/;"	m	struct:scan_control	file:
maybe_pmd_mkwrite	./huge_memory.c	/^pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)$/;"	f
maybe_same_pte	./swapfile.c	/^static inline int maybe_same_pte(pte_t pte, pte_t swp_pte)$/;"	f	file:
mbind_range	./mempolicy.c	/^static int mbind_range(struct mm_struct *mm, unsigned long start,$/;"	f	file:
mc	./memcontrol.c	/^} mc = {$/;"	v	typeref:struct:move_charge_struct	file:
mc_handle_file_pte	./memcontrol.c	/^static struct page *mc_handle_file_pte(struct vm_area_struct *vma,$/;"	f	file:
mc_handle_present_pte	./memcontrol.c	/^static struct page *mc_handle_present_pte(struct vm_area_struct *vma,$/;"	f	file:
mc_handle_swap_pte	./memcontrol.c	/^static struct page *mc_handle_swap_pte(struct vm_area_struct *vma,$/;"	f	file:
mc_target	./memcontrol.c	/^union mc_target {$/;"	u	file:
mc_target_type	./memcontrol.c	/^enum mc_target_type {$/;"	g	file:
me_huge_page	./memory-failure.c	/^static int me_huge_page(struct page *p, unsigned long pfn)$/;"	f	file:
me_kernel	./memory-failure.c	/^static int me_kernel(struct page *p, unsigned long pfn)$/;"	f	file:
me_pagecache_clean	./memory-failure.c	/^static int me_pagecache_clean(struct page *p, unsigned long pfn)$/;"	f	file:
me_pagecache_dirty	./memory-failure.c	/^static int me_pagecache_dirty(struct page *p, unsigned long pfn)$/;"	f	file:
me_swapcache_clean	./memory-failure.c	/^static int me_swapcache_clean(struct page *p, unsigned long pfn)$/;"	f	file:
me_swapcache_dirty	./memory-failure.c	/^static int me_swapcache_dirty(struct page *p, unsigned long pfn)$/;"	f	file:
me_unknown	./memory-failure.c	/^static int me_unknown(struct page *p, unsigned long pfn)$/;"	f	file:
mem_cgroup	./memcontrol.c	/^struct mem_cgroup {$/;"	s	file:
mem_cgroup_alloc	./memcontrol.c	/^static struct mem_cgroup *mem_cgroup_alloc(void)$/;"	f	file:
mem_cgroup_bad_page_check	./memcontrol.c	/^bool mem_cgroup_bad_page_check(struct page *page)$/;"	f
mem_cgroup_bind	./memcontrol.c	/^static void mem_cgroup_bind(struct cgroup_subsys_state *root_css)$/;"	f	file:
mem_cgroup_can_attach	./memcontrol.c	/^static int mem_cgroup_can_attach(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_cancel_attach	./memcontrol.c	/^static void mem_cgroup_cancel_attach(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_cancel_charge_swapin	./memcontrol.c	/^void mem_cgroup_cancel_charge_swapin(struct mem_cgroup *memcg)$/;"	f
mem_cgroup_charge_anon	./memcontrol.c	/^int mem_cgroup_charge_anon(struct page *page,$/;"	f
mem_cgroup_charge_file	./memcontrol.c	/^int mem_cgroup_charge_file(struct page *page, struct mm_struct *mm,$/;"	f
mem_cgroup_charge_statistics	./memcontrol.c	/^static void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_clear_mc	./memcontrol.c	/^static void mem_cgroup_clear_mc(void)$/;"	f	file:
mem_cgroup_commit_charge_swapin	./memcontrol.c	/^void mem_cgroup_commit_charge_swapin(struct page *page,$/;"	f
mem_cgroup_count_children	./memcontrol.c	/^static int mem_cgroup_count_children(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_count_precharge	./memcontrol.c	/^static unsigned long mem_cgroup_count_precharge(struct mm_struct *mm)$/;"	f	file:
mem_cgroup_count_precharge_pte_range	./memcontrol.c	/^static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,$/;"	f	file:
mem_cgroup_css	./memcontrol.c	/^struct cgroup_subsys_state *mem_cgroup_css(struct mem_cgroup *memcg)$/;"	f
mem_cgroup_css_alloc	./memcontrol.c	/^mem_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)$/;"	f	file:
mem_cgroup_css_free	./memcontrol.c	/^static void mem_cgroup_css_free(struct cgroup_subsys_state *css)$/;"	f	file:
mem_cgroup_css_offline	./memcontrol.c	/^static void mem_cgroup_css_offline(struct cgroup_subsys_state *css)$/;"	f	file:
mem_cgroup_css_online	./memcontrol.c	/^mem_cgroup_css_online(struct cgroup_subsys_state *css)$/;"	f	file:
mem_cgroup_destroy_all_caches	./memcontrol.c	/^static inline void mem_cgroup_destroy_all_caches(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_destroy_all_caches	./memcontrol.c	/^static void mem_cgroup_destroy_all_caches(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_destroy_cache	./memcontrol.c	/^void mem_cgroup_destroy_cache(struct kmem_cache *cachep)$/;"	f
mem_cgroup_do_charge	./memcontrol.c	/^static int mem_cgroup_do_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,$/;"	f	file:
mem_cgroup_do_precharge	./memcontrol.c	/^static int mem_cgroup_do_precharge(unsigned long count)$/;"	f	file:
mem_cgroup_do_uncharge	./memcontrol.c	/^static void mem_cgroup_do_uncharge(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_drain_pcp_counter	./memcontrol.c	/^static void mem_cgroup_drain_pcp_counter(struct mem_cgroup *memcg, int cpu)$/;"	f	file:
mem_cgroup_end_migration	./memcontrol.c	/^void mem_cgroup_end_migration(struct mem_cgroup *memcg,$/;"	f
mem_cgroup_end_move	./memcontrol.c	/^static void mem_cgroup_end_move(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_event	./memcontrol.c	/^struct mem_cgroup_event {$/;"	s	file:
mem_cgroup_event_ratelimit	./memcontrol.c	/^static bool mem_cgroup_event_ratelimit(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_eventfd_list	./memcontrol.c	/^struct mem_cgroup_eventfd_list {$/;"	s	file:
mem_cgroup_events_index	./memcontrol.c	/^enum mem_cgroup_events_index {$/;"	g	file:
mem_cgroup_events_names	./memcontrol.c	/^static const char * const mem_cgroup_events_names[] = {$/;"	v	file:
mem_cgroup_events_target	./memcontrol.c	/^enum mem_cgroup_events_target {$/;"	g	file:
mem_cgroup_files	./memcontrol.c	/^static struct cftype mem_cgroup_files[] = {$/;"	v	typeref:struct:cftype	file:
mem_cgroup_force_empty	./memcontrol.c	/^static int mem_cgroup_force_empty(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_force_empty_list	./memcontrol.c	/^static void mem_cgroup_force_empty_list(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_force_empty_write	./memcontrol.c	/^static int mem_cgroup_force_empty_write(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_from_css	./memcontrol.c	/^struct mem_cgroup *mem_cgroup_from_css(struct cgroup_subsys_state *s)$/;"	f
mem_cgroup_from_id	./memcontrol.c	/^static inline struct mem_cgroup *mem_cgroup_from_id(unsigned short id)$/;"	f	file:
mem_cgroup_from_res_counter	./memcontrol.c	1531;"	d	file:
mem_cgroup_from_task	./memcontrol.c	/^struct mem_cgroup *mem_cgroup_from_task(struct task_struct *p)$/;"	f
mem_cgroup_get_limit	./memcontrol.c	/^static u64 mem_cgroup_get_limit(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_get_lru_size	./memcontrol.c	/^mem_cgroup_get_lru_size(struct lruvec *lruvec, enum lru_list lru)$/;"	f
mem_cgroup_hierarchy_read	./memcontrol.c	/^static u64 mem_cgroup_hierarchy_read(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_hierarchy_write	./memcontrol.c	/^static int mem_cgroup_hierarchy_write(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_id	./memcontrol.c	/^static inline unsigned short mem_cgroup_id(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_inactive_anon_is_low	./memcontrol.c	/^int mem_cgroup_inactive_anon_is_low(struct lruvec *lruvec)$/;"	f
mem_cgroup_init	./memcontrol.c	/^static int __init mem_cgroup_init(void)$/;"	f	file:
mem_cgroup_init	./memcontrol.c	/^subsys_initcall(mem_cgroup_init);$/;"	v
mem_cgroup_invalidate_reclaim_iterators	./memcontrol.c	/^static void mem_cgroup_invalidate_reclaim_iterators(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_is_root	./memcontrol.c	/^static inline bool mem_cgroup_is_root(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_iter	./memcontrol.c	/^struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,$/;"	f
mem_cgroup_iter_break	./memcontrol.c	/^void mem_cgroup_iter_break(struct mem_cgroup *root,$/;"	f
mem_cgroup_iter_invalidate	./memcontrol.c	/^static void mem_cgroup_iter_invalidate(struct mem_cgroup *root)$/;"	f	file:
mem_cgroup_iter_load	./memcontrol.c	/^mem_cgroup_iter_load(struct mem_cgroup_reclaim_iter *iter,$/;"	f	file:
mem_cgroup_iter_update	./memcontrol.c	/^static void mem_cgroup_iter_update(struct mem_cgroup_reclaim_iter *iter,$/;"	f	file:
mem_cgroup_largest_soft_limit_node	./memcontrol.c	/^mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)$/;"	f	file:
mem_cgroup_lookup	./memcontrol.c	/^static struct mem_cgroup *mem_cgroup_lookup(unsigned short id)$/;"	f	file:
mem_cgroup_lru_names	./memcontrol.c	/^static const char * const mem_cgroup_lru_names[] = {$/;"	v	file:
mem_cgroup_lru_names_not_uptodate	./memcontrol.c	/^static inline void mem_cgroup_lru_names_not_uptodate(void)$/;"	f	file:
mem_cgroup_margin	./memcontrol.c	/^static unsigned long mem_cgroup_margin(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_mark_under_oom	./memcontrol.c	/^static void mem_cgroup_mark_under_oom(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_may_update_nodemask	./memcontrol.c	/^static void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_move_account	./memcontrol.c	/^static int mem_cgroup_move_account(struct page *page,$/;"	f	file:
mem_cgroup_move_charge	./memcontrol.c	/^static void mem_cgroup_move_charge(struct mm_struct *mm)$/;"	f	file:
mem_cgroup_move_charge_pte_range	./memcontrol.c	/^static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,$/;"	f	file:
mem_cgroup_move_charge_read	./memcontrol.c	/^static u64 mem_cgroup_move_charge_read(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_move_charge_write	./memcontrol.c	/^static int mem_cgroup_move_charge_write(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_move_parent	./memcontrol.c	/^static int mem_cgroup_move_parent(struct page *page,$/;"	f	file:
mem_cgroup_move_swap_account	./memcontrol.c	/^static inline int mem_cgroup_move_swap_account(swp_entry_t entry,$/;"	f	file:
mem_cgroup_move_swap_account	./memcontrol.c	/^static int mem_cgroup_move_swap_account(swp_entry_t entry,$/;"	f	file:
mem_cgroup_move_task	./memcontrol.c	/^static void mem_cgroup_move_task(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_node_nr_lru_pages	./memcontrol.c	/^mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_nr_lru_pages	./memcontrol.c	/^static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_oom	./memcontrol.c	/^static void mem_cgroup_oom(struct mem_cgroup *memcg, gfp_t mask, int order)$/;"	f	file:
mem_cgroup_oom_control_read	./memcontrol.c	/^static int mem_cgroup_oom_control_read(struct seq_file *sf, void *v)$/;"	f	file:
mem_cgroup_oom_control_write	./memcontrol.c	/^static int mem_cgroup_oom_control_write(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_oom_notify	./memcontrol.c	/^static void mem_cgroup_oom_notify(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_oom_notify_cb	./memcontrol.c	/^static int mem_cgroup_oom_notify_cb(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_oom_register_event	./memcontrol.c	/^static int mem_cgroup_oom_register_event(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_oom_synchronize	./memcontrol.c	/^bool mem_cgroup_oom_synchronize(bool handle)$/;"	f
mem_cgroup_oom_trylock	./memcontrol.c	/^static bool mem_cgroup_oom_trylock(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_oom_unlock	./memcontrol.c	/^static void mem_cgroup_oom_unlock(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_oom_unregister_event	./memcontrol.c	/^static void mem_cgroup_oom_unregister_event(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_out_of_memory	./memcontrol.c	/^static void mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,$/;"	f	file:
mem_cgroup_page_lruvec	./memcontrol.c	/^struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct zone *zone)$/;"	f
mem_cgroup_per_node	./memcontrol.c	/^struct mem_cgroup_per_node {$/;"	s	file:
mem_cgroup_per_zone	./memcontrol.c	/^struct mem_cgroup_per_zone {$/;"	s	file:
mem_cgroup_precharge_mc	./memcontrol.c	/^static int mem_cgroup_precharge_mc(struct mm_struct *mm)$/;"	f	file:
mem_cgroup_prepare_migration	./memcontrol.c	/^void mem_cgroup_prepare_migration(struct page *page, struct page *newpage,$/;"	f
mem_cgroup_print_bad_page	./memcontrol.c	/^void mem_cgroup_print_bad_page(struct page *page)$/;"	f
mem_cgroup_print_oom_info	./memcontrol.c	/^void mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)$/;"	f
mem_cgroup_read_events	./memcontrol.c	/^static unsigned long mem_cgroup_read_events(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_read_stat	./memcontrol.c	/^static long mem_cgroup_read_stat(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_read_u64	./memcontrol.c	/^static u64 mem_cgroup_read_u64(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_reclaim	./memcontrol.c	/^static unsigned long mem_cgroup_reclaim(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_reclaim_iter	./memcontrol.c	/^struct mem_cgroup_reclaim_iter {$/;"	s	file:
mem_cgroup_reclaimable	./memcontrol.c	/^static bool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)$/;"	f	file:
mem_cgroup_recursive_stat	./memcontrol.c	/^static unsigned long mem_cgroup_recursive_stat(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_remove_exceeded	./memcontrol.c	/^mem_cgroup_remove_exceeded(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_remove_from_trees	./memcontrol.c	/^static void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_reparent_charges	./memcontrol.c	/^static void mem_cgroup_reparent_charges(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_replace_page_cache	./memcontrol.c	/^void mem_cgroup_replace_page_cache(struct page *oldpage,$/;"	f
mem_cgroup_reset	./memcontrol.c	/^static int mem_cgroup_reset(struct cgroup_subsys_state *css, unsigned int event)$/;"	f	file:
mem_cgroup_resize_limit	./memcontrol.c	/^static int mem_cgroup_resize_limit(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_resize_memsw_limit	./memcontrol.c	/^static int mem_cgroup_resize_memsw_limit(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_same_or_subtree	./memcontrol.c	/^static bool mem_cgroup_same_or_subtree(const struct mem_cgroup *root_memcg,$/;"	f	file:
mem_cgroup_select_victim_node	./memcontrol.c	/^int mem_cgroup_select_victim_node(struct mem_cgroup *memcg)$/;"	f
mem_cgroup_shrink_node_zone	./vmscan.c	/^unsigned long mem_cgroup_shrink_node_zone(struct mem_cgroup *memcg,$/;"	f
mem_cgroup_slabinfo_read	./memcontrol.c	/^static int mem_cgroup_slabinfo_read(struct seq_file *m, void *v)$/;"	f	file:
mem_cgroup_soft_limit_reclaim	./memcontrol.c	/^unsigned long mem_cgroup_soft_limit_reclaim(struct zone *zone, int order,$/;"	f
mem_cgroup_soft_limit_tree_init	./memcontrol.c	/^static void __init mem_cgroup_soft_limit_tree_init(void)$/;"	f	file:
mem_cgroup_soft_reclaim	./memcontrol.c	/^static int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,$/;"	f	file:
mem_cgroup_split_huge_fixup	./memcontrol.c	/^void mem_cgroup_split_huge_fixup(struct page *head)$/;"	f
mem_cgroup_start_move	./memcontrol.c	/^static void mem_cgroup_start_move(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_stat_cpu	./memcontrol.c	/^struct mem_cgroup_stat_cpu {$/;"	s	file:
mem_cgroup_stat_names	./memcontrol.c	/^static const char * const mem_cgroup_stat_names[] = {$/;"	v	file:
mem_cgroup_stolen	./memcontrol.c	/^static bool mem_cgroup_stolen(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_swap_statistics	./memcontrol.c	/^static void mem_cgroup_swap_statistics(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_swappiness	./memcontrol.c	/^int mem_cgroup_swappiness(struct mem_cgroup *memcg)$/;"	f
mem_cgroup_swappiness_read	./memcontrol.c	/^static u64 mem_cgroup_swappiness_read(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_swappiness_write	./memcontrol.c	/^static int mem_cgroup_swappiness_write(struct cgroup_subsys_state *css,$/;"	f	file:
mem_cgroup_threshold	./memcontrol.c	/^static void mem_cgroup_threshold(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_threshold	./memcontrol.c	/^struct mem_cgroup_threshold {$/;"	s	file:
mem_cgroup_threshold_ary	./memcontrol.c	/^struct mem_cgroup_threshold_ary {$/;"	s	file:
mem_cgroup_thresholds	./memcontrol.c	/^struct mem_cgroup_thresholds {$/;"	s	file:
mem_cgroup_tree	./memcontrol.c	/^struct mem_cgroup_tree {$/;"	s	file:
mem_cgroup_tree_per_node	./memcontrol.c	/^struct mem_cgroup_tree_per_node {$/;"	s	file:
mem_cgroup_tree_per_zone	./memcontrol.c	/^struct mem_cgroup_tree_per_zone {$/;"	s	file:
mem_cgroup_try_charge	./memcontrol.c	/^static int mem_cgroup_try_charge(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_try_charge_mm	./memcontrol.c	/^static struct mem_cgroup *mem_cgroup_try_charge_mm(struct mm_struct *mm,$/;"	f	file:
mem_cgroup_try_charge_swapin	./memcontrol.c	/^int mem_cgroup_try_charge_swapin(struct mm_struct *mm, struct page *page,$/;"	f
mem_cgroup_uncharge_cache_page	./memcontrol.c	/^void mem_cgroup_uncharge_cache_page(struct page *page)$/;"	f
mem_cgroup_uncharge_end	./memcontrol.c	/^void mem_cgroup_uncharge_end(void)$/;"	f
mem_cgroup_uncharge_page	./memcontrol.c	/^void mem_cgroup_uncharge_page(struct page *page)$/;"	f
mem_cgroup_uncharge_start	./memcontrol.c	/^void mem_cgroup_uncharge_start(void)$/;"	f
mem_cgroup_uncharge_swap	./memcontrol.c	/^void mem_cgroup_uncharge_swap(swp_entry_t ent)$/;"	f
mem_cgroup_uncharge_swapcache	./memcontrol.c	/^mem_cgroup_uncharge_swapcache(struct page *page, swp_entry_t ent, bool swapout)$/;"	f
mem_cgroup_under_move	./memcontrol.c	/^static bool mem_cgroup_under_move(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_unmark_under_oom	./memcontrol.c	/^static void mem_cgroup_unmark_under_oom(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_update_lru_size	./memcontrol.c	/^void mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,$/;"	f
mem_cgroup_update_page_stat	./memcontrol.c	/^void mem_cgroup_update_page_stat(struct page *page,$/;"	f
mem_cgroup_update_tree	./memcontrol.c	/^static void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)$/;"	f	file:
mem_cgroup_usage	./memcontrol.c	/^static inline u64 mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)$/;"	f	file:
mem_cgroup_usage_register_event	./memcontrol.c	/^static int mem_cgroup_usage_register_event(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_usage_unregister_event	./memcontrol.c	/^static void mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,$/;"	f	file:
mem_cgroup_wait_acct_move	./memcontrol.c	/^static bool mem_cgroup_wait_acct_move(struct mem_cgroup *memcg)$/;"	f	file:
mem_cgroup_write	./memcontrol.c	/^static int mem_cgroup_write(struct cgroup_subsys_state *css, struct cftype *cft,$/;"	f	file:
mem_cgroup_zone_lruvec	./memcontrol.c	/^struct lruvec *mem_cgroup_zone_lruvec(struct zone *zone,$/;"	f
mem_cgroup_zone_nr_lru_pages	./memcontrol.c	/^mem_cgroup_zone_nr_lru_pages(struct mem_cgroup *memcg, int nid, int zid,$/;"	f	file:
mem_cgroup_zoneinfo	./memcontrol.c	/^mem_cgroup_zoneinfo(struct mem_cgroup *memcg, int nid, int zid)$/;"	f	file:
mem_fmt	./hugetlb_cgroup.c	/^static char *mem_fmt(char *buf, int size, unsigned long hsize)$/;"	f	file:
mem_hotplug_mutex	./memory_hotplug.c	/^DEFINE_MUTEX(mem_hotplug_mutex);$/;"	v
mem_init_print_info	./page_alloc.c	/^void __init mem_init_print_info(const char *str)$/;"	f
mem_map	./memory.c	/^EXPORT_SYMBOL(mem_map);$/;"	v
mem_map	./memory.c	/^struct page *mem_map;$/;"	v	typeref:struct:page
mem_map	./nommu.c	/^EXPORT_SYMBOL(mem_map);$/;"	v
mem_map	./nommu.c	/^struct page *mem_map;$/;"	v	typeref:struct:page
mem_map_next	./internal.h	/^static inline struct page *mem_map_next(struct page *iter,$/;"	f
mem_map_offset	./internal.h	/^static inline struct page *mem_map_offset(struct page *base, int offset)$/;"	f
mem_section	./sparse.c	/^EXPORT_SYMBOL(mem_section);$/;"	v
memblock_add	./memblock.c	/^int __init_memblock memblock_add(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_add_node	./memblock.c	/^int __init_memblock memblock_add_node(phys_addr_t base, phys_addr_t size,$/;"	f
memblock_add_region	./memblock.c	/^static int __init_memblock memblock_add_region(struct memblock_type *type,$/;"	f	file:
memblock_addrs_overlap	./memblock.c	/^static unsigned long __init_memblock memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1,$/;"	f	file:
memblock_alloc	./memblock.c	/^phys_addr_t __init memblock_alloc(phys_addr_t size, phys_addr_t align)$/;"	f
memblock_alloc_base	./memblock.c	/^phys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)$/;"	f
memblock_alloc_base_nid	./memblock.c	/^static phys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,$/;"	f	file:
memblock_alloc_nid	./memblock.c	/^phys_addr_t __init memblock_alloc_nid(phys_addr_t size, phys_addr_t align, int nid)$/;"	f
memblock_alloc_try_nid	./memblock.c	/^phys_addr_t __init memblock_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)$/;"	f
memblock_allow_resize	./memblock.c	/^void __init memblock_allow_resize(void)$/;"	f
memblock_cap_size	./memblock.c	/^static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)$/;"	f	file:
memblock_clear_hotplug	./memblock.c	/^int __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_debug_fops	./memblock.c	/^static const struct file_operations memblock_debug_fops = {$/;"	v	typeref:struct:file_operations	file:
memblock_debug_open	./memblock.c	/^static int memblock_debug_open(struct inode *inode, struct file *file)$/;"	f	file:
memblock_debug_show	./memblock.c	/^static int memblock_debug_show(struct seq_file *m, void *private)$/;"	f	file:
memblock_double_array	./memblock.c	/^static int __init_memblock memblock_double_array(struct memblock_type *type,$/;"	f	file:
memblock_dump	./memblock.c	/^static void __init_memblock memblock_dump(struct memblock_type *type, char *name)$/;"	f	file:
memblock_end_of_DRAM	./memblock.c	/^phys_addr_t __init_memblock memblock_end_of_DRAM(void)$/;"	f
memblock_enforce_memory_limit	./memblock.c	/^void __init memblock_enforce_memory_limit(phys_addr_t limit)$/;"	f
memblock_find_in_range	./memblock.c	/^phys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,$/;"	f
memblock_find_in_range_node	./memblock.c	/^phys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,$/;"	f
memblock_free	./memblock.c	/^int __init_memblock memblock_free(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_get_current_limit	./memblock.c	/^phys_addr_t __init_memblock memblock_get_current_limit(void)$/;"	f
memblock_init_debugfs	./memblock.c	/^__initcall(memblock_init_debugfs);$/;"	v
memblock_init_debugfs	./memblock.c	/^static int __init memblock_init_debugfs(void)$/;"	f	file:
memblock_insert_region	./memblock.c	/^static void __init_memblock memblock_insert_region(struct memblock_type *type,$/;"	f	file:
memblock_is_memory	./memblock.c	/^int __init_memblock memblock_is_memory(phys_addr_t addr)$/;"	f
memblock_is_region_memory	./memblock.c	/^int __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_is_region_reserved	./memblock.c	/^int __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_is_reserved	./memblock.c	/^int __init memblock_is_reserved(phys_addr_t addr)$/;"	f
memblock_isolate_range	./memblock.c	/^static int __init_memblock memblock_isolate_range(struct memblock_type *type,$/;"	f	file:
memblock_mark_hotplug	./memblock.c	/^int __init_memblock memblock_mark_hotplug(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_mem_size	./memblock.c	/^phys_addr_t __init memblock_mem_size(unsigned long limit_pfn)$/;"	f
memblock_merge_regions	./memblock.c	/^static void __init_memblock memblock_merge_regions(struct memblock_type *type)$/;"	f	file:
memblock_overlaps_region	./memblock.c	/^static long __init_memblock memblock_overlaps_region(struct memblock_type *type,$/;"	f	file:
memblock_phys_mem_size	./memblock.c	/^phys_addr_t __init memblock_phys_mem_size(void)$/;"	f
memblock_remove	./memblock.c	/^int __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_remove_region	./memblock.c	/^static void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)$/;"	f	file:
memblock_reserve	./memblock.c	/^int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)$/;"	f
memblock_reserve_region	./memblock.c	/^static int __init_memblock memblock_reserve_region(phys_addr_t base,$/;"	f	file:
memblock_search	./memblock.c	/^static int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)$/;"	f	file:
memblock_search_pfn_nid	./memblock.c	/^int __init_memblock memblock_search_pfn_nid(unsigned long pfn,$/;"	f
memblock_set_current_limit	./memblock.c	/^void __init_memblock memblock_set_current_limit(phys_addr_t limit)$/;"	f
memblock_set_node	./memblock.c	/^int __init_memblock memblock_set_node(phys_addr_t base, phys_addr_t size,$/;"	f
memblock_start_of_DRAM	./memblock.c	/^phys_addr_t __init_memblock memblock_start_of_DRAM(void)$/;"	f
memblock_trim_memory	./memblock.c	/^void __init_memblock memblock_trim_memory(phys_addr_t align)$/;"	f
memblock_type_name	./memblock.c	/^memblock_type_name(struct memblock_type *type)$/;"	f	file:
memblock_virt_alloc_internal	./memblock.c	/^static void * __init memblock_virt_alloc_internal($/;"	f	file:
memblock_virt_alloc_try_nid	./memblock.c	/^void * __init memblock_virt_alloc_try_nid($/;"	f
memblock_virt_alloc_try_nid_nopanic	./memblock.c	/^void * __init memblock_virt_alloc_try_nid_nopanic($/;"	f
memcg	./memcontrol.c	/^	struct mem_cgroup	*memcg;		\/* Back pointer, we cannot *\/$/;"	m	struct:mem_cgroup_per_zone	typeref:struct:mem_cgroup_per_zone::mem_cgroup	file:
memcg	./memcontrol.c	/^	struct mem_cgroup *memcg;$/;"	m	struct:create_work	typeref:struct:create_work::mem_cgroup	file:
memcg	./memcontrol.c	/^	struct mem_cgroup *memcg;$/;"	m	struct:mem_cgroup_event	typeref:struct:mem_cgroup_event::mem_cgroup	file:
memcg	./memcontrol.c	/^	struct mem_cgroup *memcg;$/;"	m	struct:oom_wait_info	typeref:struct:oom_wait_info::mem_cgroup	file:
memcg	./rmap.c	/^	struct mem_cgroup *memcg;$/;"	m	struct:page_referenced_arg	typeref:struct:page_referenced_arg::mem_cgroup	file:
memcg_accumulate_slabinfo	./slab_common.c	/^memcg_accumulate_slabinfo(struct kmem_cache *s, struct slabinfo *info)$/;"	f	file:
memcg_activate_kmem	./memcontrol.c	/^static int memcg_activate_kmem(struct mem_cgroup *memcg,$/;"	f	file:
memcg_alloc_cache_params	./memcontrol.c	/^int memcg_alloc_cache_params(struct mem_cgroup *memcg, struct kmem_cache *s,$/;"	f
memcg_bind_pages	./slab.h	/^static inline void memcg_bind_pages(struct kmem_cache *s, int order)$/;"	f
memcg_cache_id	./memcontrol.c	/^int memcg_cache_id(struct mem_cgroup *memcg)$/;"	f
memcg_caches_array_size	./memcontrol.c	/^static size_t memcg_caches_array_size(int num_groups)$/;"	f	file:
memcg_can_account_kmem	./memcontrol.c	/^static inline bool memcg_can_account_kmem(struct mem_cgroup *memcg)$/;"	f	file:
memcg_charge_kmem	./memcontrol.c	/^static int memcg_charge_kmem(struct mem_cgroup *memcg, gfp_t gfp, u64 size)$/;"	f	file:
memcg_check_events	./memcontrol.c	/^static void memcg_check_events(struct mem_cgroup *memcg, struct page *page)$/;"	f	file:
memcg_cpu_hotplug_callback	./memcontrol.c	/^static int memcg_cpu_hotplug_callback(struct notifier_block *nb,$/;"	f	file:
memcg_create_cache_enqueue	./memcontrol.c	/^static void memcg_create_cache_enqueue(struct mem_cgroup *memcg,$/;"	f	file:
memcg_create_cache_name	./memcontrol.c	/^char *memcg_create_cache_name(struct mem_cgroup *memcg,$/;"	f
memcg_create_cache_work_func	./memcontrol.c	/^static void memcg_create_cache_work_func(struct work_struct *w)$/;"	f	file:
memcg_destroy_kmem	./memcontrol.c	/^static void memcg_destroy_kmem(struct mem_cgroup *memcg)$/;"	f	file:
memcg_event_ptable_queue_proc	./memcontrol.c	/^static void memcg_event_ptable_queue_proc(struct file *file,$/;"	f	file:
memcg_event_remove	./memcontrol.c	/^static void memcg_event_remove(struct work_struct *work)$/;"	f	file:
memcg_event_wake	./memcontrol.c	/^static int memcg_event_wake(wait_queue_t *wait, unsigned mode,$/;"	f	file:
memcg_free_cache_params	./memcontrol.c	/^void memcg_free_cache_params(struct kmem_cache *s)$/;"	f
memcg_get_hierarchical_limit	./memcontrol.c	/^static void memcg_get_hierarchical_limit(struct mem_cgroup *memcg,$/;"	f	file:
memcg_has_children	./memcontrol.c	/^static inline bool memcg_has_children(struct mem_cgroup *memcg)$/;"	f	file:
memcg_init_kmem	./memcontrol.c	/^static int memcg_init_kmem(struct mem_cgroup *memcg, struct cgroup_subsys *ss)$/;"	f	file:
memcg_kmem_enabled_key	./memcontrol.c	/^EXPORT_SYMBOL(memcg_kmem_enabled_key);$/;"	v
memcg_kmem_enabled_key	./memcontrol.c	/^struct static_key memcg_kmem_enabled_key;$/;"	v	typeref:struct:static_key
memcg_kmem_is_active	./memcontrol.c	/^static bool memcg_kmem_is_active(struct mem_cgroup *memcg)$/;"	f	file:
memcg_kmem_mark_dead	./memcontrol.c	/^static void memcg_kmem_mark_dead(struct mem_cgroup *memcg)$/;"	f	file:
memcg_kmem_set_active	./memcontrol.c	/^static inline void memcg_kmem_set_active(struct mem_cgroup *memcg)$/;"	f	file:
memcg_kmem_test_and_clear_dead	./memcontrol.c	/^static bool memcg_kmem_test_and_clear_dead(struct mem_cgroup *memcg)$/;"	f	file:
memcg_limited_groups_array_size	./memcontrol.c	/^int memcg_limited_groups_array_size;$/;"	v
memcg_numa_stat_show	./memcontrol.c	/^static int memcg_numa_stat_show(struct seq_file *m, void *v)$/;"	f	file:
memcg_oom_lock_dep_map	./memcontrol.c	/^static struct lockdep_map memcg_oom_lock_dep_map = {$/;"	v	typeref:struct:lockdep_map	file:
memcg_oom_recover	./memcontrol.c	/^static void memcg_oom_recover(struct mem_cgroup *memcg)$/;"	f	file:
memcg_oom_wake_function	./memcontrol.c	/^static int memcg_oom_wake_function(wait_queue_t *wait,$/;"	f	file:
memcg_params_to_cache	./memcontrol.c	/^static struct kmem_cache *memcg_params_to_cache(struct memcg_cache_params *p)$/;"	f	file:
memcg_propagate_kmem	./memcontrol.c	/^static int memcg_propagate_kmem(struct mem_cgroup *memcg)$/;"	f	file:
memcg_propagate_slab_attrs	./slub.c	/^static inline void memcg_propagate_slab_attrs(struct kmem_cache *s) { }$/;"	f	file:
memcg_propagate_slab_attrs	./slub.c	/^static void memcg_propagate_slab_attrs(struct kmem_cache *s)$/;"	f	file:
memcg_register_cache	./memcontrol.c	/^void memcg_register_cache(struct kmem_cache *s)$/;"	f
memcg_release_pages	./slab.h	/^static inline void memcg_release_pages(struct kmem_cache *s, int order)$/;"	f
memcg_resume_kmem_account	./memcontrol.c	/^static inline void memcg_resume_kmem_account(void)$/;"	f	file:
memcg_root_cache	./slab.h	/^static inline struct kmem_cache *memcg_root_cache(struct kmem_cache *s)$/;"	f
memcg_slab_caches	./memcontrol.c	/^	struct list_head memcg_slab_caches;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::list_head	file:
memcg_stat_show	./memcontrol.c	/^static int memcg_stat_show(struct seq_file *m, void *v)$/;"	f	file:
memcg_stock_init	./memcontrol.c	/^static void __init memcg_stock_init(void)$/;"	f	file:
memcg_stock_pcp	./memcontrol.c	/^struct memcg_stock_pcp {$/;"	s	file:
memcg_stop_kmem_account	./memcontrol.c	/^static inline void memcg_stop_kmem_account(void)$/;"	f	file:
memcg_to_vmpressure	./memcontrol.c	/^struct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)$/;"	f
memcg_uncharge_kmem	./memcontrol.c	/^static void memcg_uncharge_kmem(struct mem_cgroup *memcg, u64 size)$/;"	f	file:
memcg_unregister_cache	./memcontrol.c	/^void memcg_unregister_cache(struct kmem_cache *s)$/;"	f
memcg_update_all_caches	./slab_common.c	/^int memcg_update_all_caches(int num_memcgs)$/;"	f
memcg_update_array_size	./memcontrol.c	/^void memcg_update_array_size(int num)$/;"	f
memcg_update_cache_size	./memcontrol.c	/^int memcg_update_cache_size(struct kmem_cache *s, int num_groups)$/;"	f
memcg_update_kmem_limit	./memcontrol.c	/^static int memcg_update_kmem_limit(struct mem_cgroup *memcg,$/;"	f	file:
memcg_wakeup_oom	./memcontrol.c	/^static void memcg_wakeup_oom(struct mem_cgroup *memcg)$/;"	f	file:
memcg_write_event_control	./memcontrol.c	/^static int memcg_write_event_control(struct cgroup_subsys_state *css,$/;"	f	file:
memcmp_pages	./ksm.c	/^static int memcmp_pages(struct page *page1, struct page *page2)$/;"	f	file:
memdup_user	./util.c	/^EXPORT_SYMBOL(memdup_user);$/;"	v
memdup_user	./util.c	/^void *memdup_user(const void __user *src, size_t len)$/;"	f
memfmt	./hugetlb.c	/^static char * __init memfmt(char *buf, unsigned long n)$/;"	f	file:
memmap_init	./page_alloc.c	4106;"	d	file:
memmap_init_zone	./page_alloc.c	/^void __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,$/;"	f
memmap_valid_within	./mmzone.c	/^int memmap_valid_within(unsigned long pfn,$/;"	f
memory_cgrp_subsys	./memcontrol.c	/^EXPORT_SYMBOL(memory_cgrp_subsys);$/;"	v
memory_cgrp_subsys	./memcontrol.c	/^struct cgroup_subsys memory_cgrp_subsys = {$/;"	v	typeref:struct:cgroup_subsys
memory_failure	./memory-failure.c	/^EXPORT_SYMBOL_GPL(memory_failure);$/;"	v
memory_failure	./memory-failure.c	/^int memory_failure(unsigned long pfn, int trapno, int flags)$/;"	f
memory_failure_cpu	./memory-failure.c	/^struct memory_failure_cpu {$/;"	s	file:
memory_failure_entry	./memory-failure.c	/^struct memory_failure_entry {$/;"	s	file:
memory_failure_init	./memory-failure.c	/^core_initcall(memory_failure_init);$/;"	v
memory_failure_init	./memory-failure.c	/^static int __init memory_failure_init(void)$/;"	f	file:
memory_failure_queue	./memory-failure.c	/^EXPORT_SYMBOL_GPL(memory_failure_queue);$/;"	v
memory_failure_queue	./memory-failure.c	/^void memory_failure_queue(unsigned long pfn, int trapno, int flags)$/;"	f
memory_failure_work_func	./memory-failure.c	/^static void memory_failure_work_func(struct work_struct *work)$/;"	f	file:
memory_present	./sparse.c	/^void __init memory_present(int nid, unsigned long start, unsigned long end)$/;"	f
mempolicy_nodemask_intersects	./mempolicy.c	/^bool mempolicy_nodemask_intersects(struct task_struct *tsk,$/;"	f
mempolicy_operations	./mempolicy.c	/^static const struct mempolicy_operations {$/;"	s	file:
mempolicy_slab_node	./mempolicy.c	/^unsigned int mempolicy_slab_node(void)$/;"	f
mempool_alloc	./mempool.c	/^EXPORT_SYMBOL(mempool_alloc);$/;"	v
mempool_alloc	./mempool.c	/^void * mempool_alloc(mempool_t *pool, gfp_t gfp_mask)$/;"	f
mempool_alloc_pages	./mempool.c	/^EXPORT_SYMBOL(mempool_alloc_pages);$/;"	v
mempool_alloc_pages	./mempool.c	/^void *mempool_alloc_pages(gfp_t gfp_mask, void *pool_data)$/;"	f
mempool_alloc_pages_isa	./bounce.c	/^static void *mempool_alloc_pages_isa(gfp_t gfp_mask, void *data)$/;"	f	file:
mempool_alloc_slab	./mempool.c	/^EXPORT_SYMBOL(mempool_alloc_slab);$/;"	v
mempool_alloc_slab	./mempool.c	/^void *mempool_alloc_slab(gfp_t gfp_mask, void *pool_data)$/;"	f
mempool_create	./mempool.c	/^EXPORT_SYMBOL(mempool_create);$/;"	v
mempool_create	./mempool.c	/^mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,$/;"	f
mempool_create_node	./mempool.c	/^EXPORT_SYMBOL(mempool_create_node);$/;"	v
mempool_create_node	./mempool.c	/^mempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,$/;"	f
mempool_destroy	./mempool.c	/^EXPORT_SYMBOL(mempool_destroy);$/;"	v
mempool_destroy	./mempool.c	/^void mempool_destroy(mempool_t *pool)$/;"	f
mempool_free	./mempool.c	/^EXPORT_SYMBOL(mempool_free);$/;"	v
mempool_free	./mempool.c	/^void mempool_free(void *element, mempool_t *pool)$/;"	f
mempool_free_pages	./mempool.c	/^EXPORT_SYMBOL(mempool_free_pages);$/;"	v
mempool_free_pages	./mempool.c	/^void mempool_free_pages(void *element, void *pool_data)$/;"	f
mempool_free_slab	./mempool.c	/^EXPORT_SYMBOL(mempool_free_slab);$/;"	v
mempool_free_slab	./mempool.c	/^void mempool_free_slab(void *element, void *pool_data)$/;"	f
mempool_kfree	./mempool.c	/^EXPORT_SYMBOL(mempool_kfree);$/;"	v
mempool_kfree	./mempool.c	/^void mempool_kfree(void *element, void *pool_data)$/;"	f
mempool_kmalloc	./mempool.c	/^EXPORT_SYMBOL(mempool_kmalloc);$/;"	v
mempool_kmalloc	./mempool.c	/^void *mempool_kmalloc(gfp_t gfp_mask, void *pool_data)$/;"	f
mempool_resize	./mempool.c	/^EXPORT_SYMBOL(mempool_resize);$/;"	v
mempool_resize	./mempool.c	/^int mempool_resize(mempool_t *pool, int new_min_nr, gfp_t gfp_mask)$/;"	f
memsw	./memcontrol.c	/^	struct res_counter memsw;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::res_counter	file:
memsw_cgroup_files	./memcontrol.c	/^static struct cftype memsw_cgroup_files[] = {$/;"	v	typeref:struct:cftype	file:
memsw_cgroup_usage_register_event	./memcontrol.c	/^static int memsw_cgroup_usage_register_event(struct mem_cgroup *memcg,$/;"	f	file:
memsw_cgroup_usage_unregister_event	./memcontrol.c	/^static void memsw_cgroup_usage_unregister_event(struct mem_cgroup *memcg,$/;"	f	file:
memsw_file_init	./memcontrol.c	/^static void __init memsw_file_init(void)$/;"	f	file:
memsw_is_minimum	./memcontrol.c	/^	bool		memsw_is_minimum;$/;"	m	struct:mem_cgroup	file:
memsw_thresholds	./memcontrol.c	/^	struct mem_cgroup_thresholds memsw_thresholds;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::mem_cgroup_thresholds	file:
merge_across_nodes	./ksm.c	/^KSM_ATTR(merge_across_nodes);$/;"	v
merge_across_nodes_show	./ksm.c	/^static ssize_t merge_across_nodes_show(struct kobject *kobj,$/;"	f	file:
merge_across_nodes_store	./ksm.c	/^static ssize_t merge_across_nodes_store(struct kobject *kobj,$/;"	f	file:
might_fault	./memory.c	/^EXPORT_SYMBOL(might_fault);$/;"	v
might_fault	./memory.c	/^void might_fault(void)$/;"	f
migrate_async_suitable	./compaction.c	/^static inline bool migrate_async_suitable(int migratetype)$/;"	f	file:
migrate_balanced_pgdat	./migrate.c	/^static bool migrate_balanced_pgdat(struct pglist_data *pgdat,$/;"	f	file:
migrate_huge_page_move_mapping	./migrate.c	/^int migrate_huge_page_move_mapping(struct address_space *mapping,$/;"	f
migrate_misplaced_page	./migrate.c	/^int migrate_misplaced_page(struct page *page, struct vm_area_struct *vma,$/;"	f
migrate_misplaced_transhuge_page	./migrate.c	/^int migrate_misplaced_transhuge_page(struct mm_struct *mm,$/;"	f
migrate_page	./migrate.c	/^EXPORT_SYMBOL(migrate_page);$/;"	v
migrate_page	./migrate.c	/^int migrate_page(struct address_space *mapping,$/;"	f
migrate_page_add	./mempolicy.c	/^static void migrate_page_add(struct page *page, struct list_head *pagelist,$/;"	f	file:
migrate_page_copy	./migrate.c	/^void migrate_page_copy(struct page *newpage, struct page *page)$/;"	f
migrate_page_move_mapping	./migrate.c	/^int migrate_page_move_mapping(struct address_space *mapping,$/;"	f
migrate_pages	./migrate.c	/^int migrate_pages(struct list_head *from, new_page_t get_new_page,$/;"	f
migrate_pfn	./internal.h	/^	unsigned long migrate_pfn;	\/* isolate_migratepages search base *\/$/;"	m	struct:compact_control
migrate_prep	./migrate.c	/^int migrate_prep(void)$/;"	f
migrate_prep_local	./migrate.c	/^int migrate_prep_local(void)$/;"	f
migrate_ratelimited	./migrate.c	/^bool migrate_ratelimited(int node)$/;"	f
migrate_to_node	./mempolicy.c	/^static int migrate_to_node(struct mm_struct *mm, int source, int dest,$/;"	f	file:
migrate_vmas	./migrate.c	/^int migrate_vmas(struct mm_struct *mm, const nodemask_t *to,$/;"	f
migratepages	./internal.h	/^	struct list_head migratepages;	\/* List of pages being migrated *\/$/;"	m	struct:compact_control	typeref:struct:compact_control::list_head
migratetype	./internal.h	/^	int migratetype;		\/* MOVABLE, RECLAIMABLE etc *\/$/;"	m	struct:compact_control
migratetype_names	./vmstat.c	/^static char * const migratetype_names[MIGRATE_TYPES] = {$/;"	v	file:
migration_entry_wait	./migrate.c	/^void migration_entry_wait(struct mm_struct *mm, pmd_t *pmd,$/;"	f
migration_entry_wait_huge	./migrate.c	/^void migration_entry_wait_huge(struct vm_area_struct *vma,$/;"	f
min_addr	./kmemleak.c	/^static unsigned long min_addr = ULONG_MAX;$/;"	v	file:
min_count	./kmemleak.c	/^	int min_count;			\/* minimum reference count *\/$/;"	m	struct:early_log	file:
min_count	./kmemleak.c	/^	int min_count;$/;"	m	struct:kmemleak_object	file:
min_free_kbytes	./page_alloc.c	/^int min_free_kbytes = 1024;$/;"	v
min_low_pfn	./bootmem.c	/^unsigned long min_low_pfn;$/;"	v
min_low_pfn	./nobootmem.c	/^unsigned long min_low_pfn;$/;"	v
min_order	./page_alloc.c	/^	u32 min_order;$/;"	m	struct:__anon2	file:
min_pages_to_free	./quicklist.c	/^static long min_pages_to_free(struct quicklist *q,$/;"	f	file:
min_partial	./slub.c	/^SLAB_ATTR(min_partial);$/;"	v
min_partial_show	./slub.c	/^static ssize_t min_partial_show(struct kmem_cache *s, char *buf)$/;"	f	file:
min_partial_store	./slub.c	/^static ssize_t min_partial_store(struct kmem_cache *s, const char *buf,$/;"	f	file:
min_pid	./slub.c	/^	long min_pid;$/;"	m	struct:location	file:
min_ratio_store	./backing-dev.c	/^static ssize_t min_ratio_store(struct device *dev,$/;"	f	file:
min_time	./slub.c	/^	long min_time;$/;"	m	struct:location	file:
mincore_huge_pmd	./huge_memory.c	/^int mincore_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f
mincore_hugetlb_page_range	./mincore.c	/^static void mincore_hugetlb_page_range(struct vm_area_struct *vma,$/;"	f	file:
mincore_page	./mincore.c	/^static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)$/;"	f	file:
mincore_page_range	./mincore.c	/^static void mincore_page_range(struct vm_area_struct *vma,$/;"	f	file:
mincore_pmd_range	./mincore.c	/^static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,$/;"	f	file:
mincore_pte_range	./mincore.c	/^static void mincore_pte_range(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f	file:
mincore_pud_range	./mincore.c	/^static void mincore_pud_range(struct vm_area_struct *vma, pgd_t *pgd,$/;"	f	file:
mincore_unmapped_range	./mincore.c	/^static void mincore_unmapped_range(struct vm_area_struct *vma,$/;"	f	file:
mk_huge_pmd	./huge_memory.c	/^static inline pmd_t mk_huge_pmd(struct page *page, pgprot_t prot)$/;"	f	file:
mlock	./memory-failure.c	746;"	d	file:
mlock	./memory-failure.c	803;"	d	file:
mlock_fixup	./mlock.c	/^static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,$/;"	f	file:
mlock_future_check	./mmap.c	/^static inline int mlock_future_check(struct mm_struct *mm,$/;"	f	file:
mlock_migrate_page	./internal.h	/^static inline void mlock_migrate_page(struct page *new, struct page *old) { }$/;"	f
mlock_migrate_page	./internal.h	/^static inline void mlock_migrate_page(struct page *newpage, struct page *page)$/;"	f
mlock_vma_page	./internal.h	/^static inline void mlock_vma_page(struct page *page) { }$/;"	f
mlock_vma_page	./mlock.c	/^void mlock_vma_page(struct page *page)$/;"	f
mlocked_vma_newpage	./internal.h	/^static inline int mlocked_vma_newpage(struct vm_area_struct *v, struct page *p)$/;"	f
mlocked_vma_newpage	./internal.h	/^static inline int mlocked_vma_newpage(struct vm_area_struct *vma,$/;"	f
mm	./huge_memory.c	/^	struct mm_struct *mm;$/;"	m	struct:mm_slot	typeref:struct:mm_slot::mm_struct	file:
mm	./ksm.c	/^	struct mm_struct *mm;$/;"	m	struct:mm_slot	typeref:struct:mm_slot::mm_struct	file:
mm	./ksm.c	/^	struct mm_struct *mm;$/;"	m	struct:rmap_item	typeref:struct:rmap_item::mm_struct	file:
mm_compute_batch	./mm_init.c	/^static void __meminit mm_compute_batch(void)$/;"	f	file:
mm_compute_batch_init	./mm_init.c	/^__initcall(mm_compute_batch_init);$/;"	v
mm_compute_batch_init	./mm_init.c	/^static int __init mm_compute_batch_init(void)$/;"	f	file:
mm_compute_batch_notifier	./mm_init.c	/^static int __meminit mm_compute_batch_notifier(struct notifier_block *self,$/;"	f	file:
mm_counter	./fremap.c	/^static int mm_counter(struct page *page)$/;"	f	file:
mm_drop_all_locks	./mmap.c	/^void mm_drop_all_locks(struct mm_struct *mm)$/;"	f
mm_find_pmd	./rmap.c	/^pmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)$/;"	f
mm_head	./huge_memory.c	/^	struct list_head mm_head;$/;"	m	struct:khugepaged_scan	typeref:struct:khugepaged_scan::list_head	file:
mm_kobj	./mm_init.c	/^EXPORT_SYMBOL_GPL(mm_kobj);$/;"	v
mm_kobj	./mm_init.c	/^struct kobject *mm_kobj;$/;"	v	typeref:struct:kobject
mm_list	./ksm.c	/^	struct list_head mm_list;$/;"	m	struct:mm_slot	typeref:struct:mm_slot::list_head	file:
mm_node	./huge_memory.c	/^	struct list_head mm_node;$/;"	m	struct:mm_slot	typeref:struct:mm_slot::list_head	file:
mm_slot	./huge_memory.c	/^	struct mm_slot *mm_slot;$/;"	m	struct:khugepaged_scan	typeref:struct:khugepaged_scan::mm_slot	file:
mm_slot	./huge_memory.c	/^struct mm_slot {$/;"	s	file:
mm_slot	./ksm.c	/^	struct mm_slot *mm_slot;$/;"	m	struct:ksm_scan	typeref:struct:ksm_scan::mm_slot	file:
mm_slot	./ksm.c	/^struct mm_slot {$/;"	s	file:
mm_slot_cache	./ksm.c	/^static struct kmem_cache *mm_slot_cache;$/;"	v	typeref:struct:kmem_cache	file:
mm_sysfs_init	./mm_init.c	/^postcore_initcall(mm_sysfs_init);$/;"	v
mm_sysfs_init	./mm_init.c	/^static int __init mm_sysfs_init(void)$/;"	f	file:
mm_take_all_locks	./mmap.c	/^int mm_take_all_locks(struct mm_struct *mm)$/;"	f
mmap_arg_struct	./mmap.c	/^struct mmap_arg_struct {$/;"	s	file:
mmap_arg_struct	./nommu.c	/^struct mmap_arg_struct {$/;"	s	file:
mmap_init	./mmap.c	/^void __init mmap_init(void)$/;"	f
mmap_init	./nommu.c	/^void __init mmap_init(void)$/;"	f
mmap_pages_allocated	./nommu.c	/^atomic_long_t mmap_pages_allocated;$/;"	v
mmap_region	./mmap.c	/^unsigned long mmap_region(struct file *file, unsigned long addr,$/;"	f
mminit_dprintk	./internal.h	/^static inline void mminit_dprintk(enum mminit_level level,$/;"	f
mminit_dprintk	./internal.h	309;"	d
mminit_level	./internal.h	/^enum mminit_level {$/;"	g
mminit_loglevel	./mm_init.c	/^int mminit_loglevel;$/;"	v
mminit_validate_memmodel_limits	./internal.h	/^static inline void mminit_validate_memmodel_limits(unsigned long *start_pfn,$/;"	f
mminit_validate_memmodel_limits	./sparse.c	/^void __meminit mminit_validate_memmodel_limits(unsigned long *start_pfn,$/;"	f
mminit_verify_page_links	./internal.h	/^static inline void mminit_verify_page_links(struct page *page,$/;"	f
mminit_verify_page_links	./mm_init.c	/^void __meminit mminit_verify_page_links(struct page *page, enum zone_type zone,$/;"	f
mminit_verify_pageflags_layout	./internal.h	/^static inline void mminit_verify_pageflags_layout(void)$/;"	f
mminit_verify_pageflags_layout	./mm_init.c	/^void __init mminit_verify_pageflags_layout(void)$/;"	f
mminit_verify_zonelist	./internal.h	/^static inline void mminit_verify_zonelist(void)$/;"	f
mminit_verify_zonelist	./mm_init.c	/^void mminit_verify_zonelist(void)$/;"	f
mmu-y	./Makefile	/^mmu-y			:= nommu.o$/;"	m
mmu_notifier_init	./mmu_notifier.c	/^static int __init mmu_notifier_init(void)$/;"	f	file:
mmu_notifier_init	./mmu_notifier.c	/^subsys_initcall(mmu_notifier_init);$/;"	v
mmu_notifier_register	./mmu_notifier.c	/^EXPORT_SYMBOL_GPL(mmu_notifier_register);$/;"	v
mmu_notifier_register	./mmu_notifier.c	/^int mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)$/;"	f
mmu_notifier_unregister	./mmu_notifier.c	/^EXPORT_SYMBOL_GPL(mmu_notifier_unregister);$/;"	v
mmu_notifier_unregister	./mmu_notifier.c	/^void mmu_notifier_unregister(struct mmu_notifier *mn, struct mm_struct *mm)$/;"	f
mod_state	./vmstat.c	/^static inline void mod_state(struct zone *zone,$/;"	f	file:
mod_zone_page_state	./vmstat.c	/^EXPORT_SYMBOL(mod_zone_page_state);$/;"	v
mod_zone_page_state	./vmstat.c	/^void mod_zone_page_state(struct zone *zone, enum zone_stat_item item,$/;"	f
module_init	./page_alloc.c	/^module_init(init_per_zone_wmark_min)$/;"	f
movable_zone	./page_alloc.c	/^EXPORT_SYMBOL(movable_zone);$/;"	v
movable_zone	./page_alloc.c	/^int movable_zone;$/;"	v
move_active_pages_to_lru	./vmscan.c	/^static void move_active_pages_to_lru(struct lruvec *lruvec,$/;"	f	file:
move_anon	./memcontrol.c	/^static bool move_anon(void)$/;"	f	file:
move_charge_at_immigrate	./memcontrol.c	/^	unsigned long move_charge_at_immigrate;$/;"	m	struct:mem_cgroup	file:
move_charge_struct	./memcontrol.c	/^static struct move_charge_struct {$/;"	s	file:
move_file	./memcontrol.c	/^static bool move_file(void)$/;"	f	file:
move_freepages	./page_alloc.c	/^int move_freepages(struct zone *zone,$/;"	f
move_freepages_block	./page_alloc.c	/^int move_freepages_block(struct zone *zone, struct page *page,$/;"	f
move_huge_pmd	./huge_memory.c	/^int move_huge_pmd(struct vm_area_struct *vma, struct vm_area_struct *new_vma,$/;"	f
move_lock	./memcontrol.c	/^	spinlock_t	move_lock;$/;"	m	struct:mem_cgroup	file:
move_lock_mem_cgroup	./memcontrol.c	/^static void move_lock_mem_cgroup(struct mem_cgroup *memcg,$/;"	f	file:
move_page_tables	./mremap.c	/^unsigned long move_page_tables(struct vm_area_struct *vma,$/;"	f
move_pfn_range_left	./memory_hotplug.c	/^static int __meminit move_pfn_range_left(struct zone *z1, struct zone *z2,$/;"	f	file:
move_pfn_range_right	./memory_hotplug.c	/^static int __meminit move_pfn_range_right(struct zone *z1, struct zone *z2,$/;"	f	file:
move_ptes	./mremap.c	/^static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,$/;"	f	file:
move_soft_dirty_pte	./mremap.c	/^static pte_t move_soft_dirty_pte(pte_t pte)$/;"	f	file:
move_to_new_page	./migrate.c	/^static int move_to_new_page(struct page *newpage, struct page *page,$/;"	f	file:
move_type	./memcontrol.c	/^enum move_type {$/;"	g	file:
move_unlock_mem_cgroup	./memcontrol.c	/^static void move_unlock_mem_cgroup(struct mem_cgroup *memcg,$/;"	f	file:
move_vma	./mremap.c	/^static unsigned long move_vma(struct vm_area_struct *vma,$/;"	f	file:
moved_charge	./memcontrol.c	/^	unsigned long moved_charge;$/;"	m	struct:move_charge_struct	file:
moved_swap	./memcontrol.c	/^	unsigned long moved_swap;$/;"	m	struct:move_charge_struct	file:
moving_account	./memcontrol.c	/^	atomic_t	moving_account;$/;"	m	struct:mem_cgroup	file:
moving_task	./memcontrol.c	/^	struct task_struct *moving_task;	\/* a task moving charges *\/$/;"	m	struct:move_charge_struct	typeref:struct:move_charge_struct::task_struct	file:
mpol_free_shared_policy	./mempolicy.c	/^void mpol_free_shared_policy(struct shared_policy *p)$/;"	f
mpol_misplaced	./mempolicy.c	/^int mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)$/;"	f
mpol_new	./mempolicy.c	/^static struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,$/;"	f	file:
mpol_new_bind	./mempolicy.c	/^static int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)$/;"	f	file:
mpol_new_interleave	./mempolicy.c	/^static int mpol_new_interleave(struct mempolicy *pol, const nodemask_t *nodes)$/;"	f	file:
mpol_new_preferred	./mempolicy.c	/^static int mpol_new_preferred(struct mempolicy *pol, const nodemask_t *nodes)$/;"	f	file:
mpol_ops	./mempolicy.c	/^static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {$/;"	v	typeref:struct:mempolicy_operations	file:
mpol_ops	./mempolicy.c	/^} mpol_ops[MPOL_MAX];$/;"	v	typeref:struct:mempolicy_operations	file:
mpol_parse_str	./mempolicy.c	/^int mpol_parse_str(char *str, struct mempolicy **mpol)$/;"	f
mpol_rebind_default	./mempolicy.c	/^static void mpol_rebind_default(struct mempolicy *pol, const nodemask_t *nodes,$/;"	f	file:
mpol_rebind_mm	./mempolicy.c	/^void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)$/;"	f
mpol_rebind_nodemask	./mempolicy.c	/^static void mpol_rebind_nodemask(struct mempolicy *pol, const nodemask_t *nodes,$/;"	f	file:
mpol_rebind_policy	./mempolicy.c	/^static void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask,$/;"	f	file:
mpol_rebind_preferred	./mempolicy.c	/^static void mpol_rebind_preferred(struct mempolicy *pol,$/;"	f	file:
mpol_rebind_task	./mempolicy.c	/^void mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new,$/;"	f
mpol_relative_nodemask	./mempolicy.c	/^static void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,$/;"	f	file:
mpol_set_nodemask	./mempolicy.c	/^static int mpol_set_nodemask(struct mempolicy *pol,$/;"	f	file:
mpol_set_shared_policy	./mempolicy.c	/^int mpol_set_shared_policy(struct shared_policy *info,$/;"	f
mpol_shared_policy_init	./mempolicy.c	/^void mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)$/;"	f
mpol_shared_policy_lookup	./mempolicy.c	/^mpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)$/;"	f
mpol_store_user_nodemask	./mempolicy.c	/^static inline int mpol_store_user_nodemask(const struct mempolicy *pol)$/;"	f	file:
mpol_to_str	./mempolicy.c	/^void mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol)$/;"	f
mprotect_fixup	./mprotect.c	/^mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,$/;"	f
mremap_to	./mremap.c	/^static unsigned long mremap_to(unsigned long addr, unsigned long old_len,$/;"	f	file:
msg	./memory-failure.c	/^	char *msg;$/;"	m	struct:page_state	file:
munlock_vma_page	./mlock.c	/^unsigned int munlock_vma_page(struct page *page)$/;"	f
munlock_vma_pages_all	./internal.h	/^static inline void munlock_vma_pages_all(struct vm_area_struct *vma)$/;"	f
munlock_vma_pages_range	./mlock.c	/^void munlock_vma_pages_range(struct vm_area_struct *vma,$/;"	f
must_snapshot_stable_pages	./bounce.c	/^static int must_snapshot_stable_pages(struct request_queue *q, struct bio *bio)$/;"	f	file:
name	./dmapool.c	/^	char name[32];$/;"	m	struct:dma_pool	file:
name	./slub.c	/^	const char *name;$/;"	m	struct:saved_alias	file:
nd	./memory-failure.c	/^	struct list_head nd;$/;"	m	struct:to_kill	typeref:struct:to_kill::list_head	file:
need_activate_page_drain	./swap.c	/^static bool need_activate_page_drain(int cpu)$/;"	f	file:
need_reserve_slab_rcu	./slub.c	1476;"	d	file:
new	./slab.c	/^	struct array_cache *new[0];$/;"	m	struct:ccupdate_struct	typeref:struct:ccupdate_struct::array_cache	file:
new_node_page	./mempolicy.c	/^static struct page *new_node_page(struct page *page, unsigned long node, int **x)$/;"	f	file:
new_page	./memory-failure.c	/^static struct page *new_page(struct page *p, unsigned long private, int **x)$/;"	f	file:
new_page_node	./migrate.c	/^static struct page *new_page_node(struct page *p, unsigned long private,$/;"	f	file:
new_slab	./slub.c	/^static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)$/;"	f	file:
new_slab_objects	./slub.c	/^static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,$/;"	f	file:
new_vma_page	./mempolicy.c	/^static struct page *new_vma_page(struct page *page, unsigned long private, int **x)$/;"	f	file:
new_vmap_block	./vmalloc.c	/^static struct vmap_block *new_vmap_block(gfp_t gfp_mask)$/;"	f	file:
next	./shmem.c	/^	pgoff_t next;		\/* the next page offset to be fallocated *\/$/;"	m	struct:shmem_falloc	file:
next	./slub.c	/^	struct saved_alias *next;$/;"	m	struct:saved_alias	typeref:struct:saved_alias::saved_alias	file:
next	./zsmalloc.c	/^	void *next;$/;"	m	struct:link_free	file:
next_active_pageblock	./memory_hotplug.c	/^static struct page *next_active_pageblock(struct page *page)$/;"	f	file:
next_node_allowed	./hugetlb.c	/^static int next_node_allowed(int nid, nodemask_t *nodes_allowed)$/;"	f	file:
next_online_pgdat	./mmzone.c	/^struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)$/;"	f
next_reap	./slab.h	/^	unsigned long next_reap;	\/* updated without locking *\/$/;"	m	struct:kmem_cache_node
next_reap_node	./slab.c	/^static void next_reap_node(void)$/;"	f	file:
next_reap_node	./slab.c	716;"	d	file:
next_tid	./slub.c	/^static inline unsigned long next_tid(unsigned long tid)$/;"	f	file:
next_zone	./mmzone.c	/^struct zone *next_zone(struct zone *zone)$/;"	f
next_zones_zonelist	./mmzone.c	/^struct zoneref *next_zones_zonelist(struct zoneref *z,$/;"	f
nid	./ksm.c	/^		int nid;		\/* when node of unstable tree *\/$/;"	m	union:rmap_item::__anon7	file:
nid	./ksm.c	/^	int nid;$/;"	m	struct:stable_node	file:
noaliencache_setup	./slab.c	/^static int __init noaliencache_setup(char *s)$/;"	f	file:
nocpu_base	./memcontrol.c	/^	struct mem_cgroup_stat_cpu nocpu_base;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::mem_cgroup_stat_cpu	file:
node	./kmemleak.c	/^	struct hlist_node node;$/;"	m	struct:kmemleak_scan_area	typeref:struct:kmemleak_scan_area::hlist_node	file:
node	./ksm.c	/^		struct rb_node node;	\/* when node of stable tree *\/$/;"	m	union:stable_node::__anon5	typeref:struct:stable_node::__anon5::rb_node	file:
node	./ksm.c	/^		struct rb_node node;	\/* when node of unstable tree *\/$/;"	m	union:rmap_item::__anon8	typeref:struct:rmap_item::__anon8::rb_node	file:
node	./migrate.c	/^	int node;$/;"	m	struct:page_to_node	file:
node	./vmpressure.c	/^	struct list_head node;$/;"	m	struct:vmpressure_event	typeref:struct:vmpressure_event::list_head	file:
node_hstate	./hugetlb.c	/^struct node_hstate {$/;"	s	file:
node_hstates	./hugetlb.c	/^struct node_hstate node_hstates[MAX_NUMNODES];$/;"	v	typeref:struct:node_hstate
node_load	./page_alloc.c	/^static int node_load[MAX_NUMNODES];$/;"	v	file:
node_map_pfn_alignment	./page_alloc.c	/^unsigned long __init node_map_pfn_alignment(void)$/;"	f
node_match	./slub.c	/^static inline int node_match(struct page *page, int node)$/;"	f	file:
node_memmap_size_bytes	./sparse.c	/^unsigned long __init node_memmap_size_bytes(int nid, unsigned long start_pfn,$/;"	f
node_nr_objs	./slub.c	/^static inline unsigned long node_nr_objs(struct kmem_cache_node *n)$/;"	f	file:
node_nr_slabs	./slub.c	/^static inline unsigned long node_nr_slabs(struct kmem_cache_node *n)$/;"	f	file:
node_order	./page_alloc.c	/^static int node_order[MAX_NUMNODES];$/;"	v	file:
node_random	./mempolicy.c	/^int node_random(const nodemask_t *maskp)$/;"	f
node_states	./page_alloc.c	/^EXPORT_SYMBOL(node_states);$/;"	v
node_states_check_changes_offline	./memory_hotplug.c	/^static void node_states_check_changes_offline(unsigned long nr_pages,$/;"	f	file:
node_states_check_changes_online	./memory_hotplug.c	/^static void node_states_check_changes_online(unsigned long nr_pages,$/;"	f	file:
node_states_clear_node	./memory_hotplug.c	/^static void node_states_clear_node(int node, struct memory_notify *arg)$/;"	f	file:
node_states_set_node	./memory_hotplug.c	/^static void node_states_set_node(int node, struct memory_notify *arg)$/;"	f	file:
node_to_va	./vmalloc.c	/^static struct vmap_area *node_to_va(struct rb_node *n)$/;"	f	file:
nodeinfo	./memcontrol.c	/^	struct mem_cgroup_per_node *nodeinfo[0];$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::mem_cgroup_per_node	file:
nodemask	./vmscan.c	/^	nodemask_t	*nodemask;$/;"	m	struct:scan_control	file:
nodes	./slub.c	/^	nodemask_t nodes;$/;"	m	struct:location	file:
nommu_region_sem	./nommu.c	/^DECLARE_RWSEM(nommu_region_sem);$/;"	v
nommu_region_tree	./nommu.c	/^struct rb_root nommu_region_tree = RB_ROOT;$/;"	v	typeref:struct:rb_root
nommu_shrink_inode_mappings	./nommu.c	/^int nommu_shrink_inode_mappings(struct inode *inode, size_t size,$/;"	f
noop_backing_dev_info	./backing-dev.c	/^EXPORT_SYMBOL_GPL(noop_backing_dev_info);$/;"	v
noop_backing_dev_info	./backing-dev.c	/^struct backing_dev_info noop_backing_dev_info = {$/;"	v	typeref:struct:backing_dev_info
note_cmpxchg_failure	./slub.c	/^static inline void note_cmpxchg_failure(const char *n,$/;"	f	file:
nr_all_pages	./page_alloc.c	/^static unsigned long __meminitdata nr_all_pages;$/;"	v	file:
nr_bdi_congested	./backing-dev.c	/^static atomic_t nr_bdi_congested[2];$/;"	v	file:
nr_falloced	./shmem.c	/^	pgoff_t nr_falloced;	\/* how many new pages have been fallocated *\/$/;"	m	struct:shmem_falloc	file:
nr_free_buffer_pages	./page_alloc.c	/^EXPORT_SYMBOL_GPL(nr_free_buffer_pages);$/;"	v
nr_free_buffer_pages	./page_alloc.c	/^unsigned long nr_free_buffer_pages(void)$/;"	f
nr_free_highpages	./highmem.c	/^unsigned int nr_free_highpages (void)$/;"	f
nr_free_pagecache_pages	./page_alloc.c	/^unsigned long nr_free_pagecache_pages(void)$/;"	f
nr_free_zone_pages	./page_alloc.c	/^static unsigned long nr_free_zone_pages(int offset)$/;"	f	file:
nr_freepages	./internal.h	/^	unsigned long nr_freepages;	\/* Number of isolated free pages *\/$/;"	m	struct:compact_control
nr_hugepages	./hugetlb.c	/^HSTATE_ATTR(nr_hugepages);$/;"	v
nr_hugepages_mempolicy	./hugetlb.c	/^HSTATE_ATTR(nr_hugepages_mempolicy);$/;"	v
nr_hugepages_mempolicy_show	./hugetlb.c	/^static ssize_t nr_hugepages_mempolicy_show(struct kobject *kobj,$/;"	f	file:
nr_hugepages_mempolicy_store	./hugetlb.c	/^static ssize_t nr_hugepages_mempolicy_store(struct kobject *kobj,$/;"	f	file:
nr_hugepages_show	./hugetlb.c	/^static ssize_t nr_hugepages_show(struct kobject *kobj,$/;"	f	file:
nr_hugepages_show_common	./hugetlb.c	/^static ssize_t nr_hugepages_show_common(struct kobject *kobj,$/;"	f	file:
nr_hugepages_store	./hugetlb.c	/^static ssize_t nr_hugepages_store(struct kobject *kobj,$/;"	f	file:
nr_hugepages_store_common	./hugetlb.c	/^static ssize_t nr_hugepages_store_common(bool obey_mempolicy,$/;"	f	file:
nr_kernel_pages	./page_alloc.c	/^static unsigned long __meminitdata nr_kernel_pages;$/;"	v	file:
nr_migratepages	./internal.h	/^	unsigned long nr_migratepages;	\/* Number of pages to migrate *\/$/;"	m	struct:compact_control
nr_node_ids	./page_alloc.c	/^EXPORT_SYMBOL(nr_node_ids);$/;"	v
nr_online_nodes	./page_alloc.c	/^EXPORT_SYMBOL(nr_online_nodes);$/;"	v
nr_overcommit_hugepages	./hugetlb.c	/^HSTATE_ATTR(nr_overcommit_hugepages);$/;"	v
nr_overcommit_hugepages_show	./hugetlb.c	/^static ssize_t nr_overcommit_hugepages_show(struct kobject *kobj,$/;"	f	file:
nr_overcommit_hugepages_store	./hugetlb.c	/^static ssize_t nr_overcommit_hugepages_store(struct kobject *kobj,$/;"	f	file:
nr_page_events	./memcontrol.c	/^	unsigned long nr_page_events;$/;"	m	struct:mem_cgroup_stat_cpu	file:
nr_pages	./memcontrol.c	/^	unsigned int nr_pages;$/;"	m	struct:memcg_stock_pcp	file:
nr_partial	./slab.h	/^	unsigned long nr_partial;$/;"	m	struct:kmem_cache_node
nr_reclaimed	./vmscan.c	/^	unsigned long nr_reclaimed;$/;"	m	struct:scan_control	file:
nr_scanned	./vmscan.c	/^	unsigned long nr_scanned;$/;"	m	struct:scan_control	file:
nr_slabs	./slab.h	/^	atomic_long_t nr_slabs;$/;"	m	struct:kmem_cache_node
nr_swap_pages	./swapfile.c	/^atomic_long_t nr_swap_pages;$/;"	v
nr_swapfiles	./swapfile.c	/^static unsigned int nr_swapfiles;$/;"	v	file:
nr_to_reclaim	./vmscan.c	/^	unsigned long nr_to_reclaim;$/;"	m	struct:scan_control	file:
nr_unswapped	./shmem.c	/^	pgoff_t nr_unswapped;	\/* how often writepage refused to swap out *\/$/;"	m	struct:shmem_falloc	file:
num_fault_mutexes	./hugetlb.c	/^static int num_fault_mutexes;$/;"	v	file:
num_free_chunks	./zbud.c	/^static int num_free_chunks(struct zbud_header *zhdr)$/;"	f	file:
num_objs	./slab.h	/^	unsigned long num_objs;$/;"	m	struct:slabinfo
num_slabs	./slab.h	/^	unsigned long num_slabs;$/;"	m	struct:slabinfo
numa_default_policy	./mempolicy.c	/^void numa_default_policy(void)$/;"	f
numa_migrate_prep	./memory.c	/^static int numa_migrate_prep(struct page *page, struct vm_area_struct *vma,$/;"	f	file:
numa_node	./page_alloc.c	/^EXPORT_PER_CPU_SYMBOL(numa_node);$/;"	v
numa_policy_init	./mempolicy.c	/^void __init numa_policy_init(void)$/;"	f
numa_zonelist_order	./page_alloc.c	/^char numa_zonelist_order[16] = "default";$/;"	v
numa_zonelist_order_handler	./page_alloc.c	/^int numa_zonelist_order_handler(ctl_table *table, int write,$/;"	f
numabalancing_override	./mempolicy.c	/^static int __initdata numabalancing_override;$/;"	v	file:
numainfo_events	./memcontrol.c	/^	atomic_t	numainfo_events;$/;"	m	struct:mem_cgroup	file:
numainfo_updating	./memcontrol.c	/^	atomic_t	numainfo_updating;$/;"	m	struct:mem_cgroup	file:
numamigrate_isolate_page	./migrate.c	/^static int numamigrate_isolate_page(pg_data_t *pgdat, struct page *page)$/;"	f	file:
numamigrate_update_ratelimit	./migrate.c	/^static bool numamigrate_update_ratelimit(pg_data_t *pgdat,$/;"	f	file:
obj-y	./Makefile	/^obj-y			:= filemap.o mempool.o oom_kill.o fadvise.o \\$/;"	m
obj_handle_to_location	./zsmalloc.c	/^static void obj_handle_to_location(unsigned long handle, struct page **page,$/;"	f	file:
obj_idx_to_offset	./zsmalloc.c	/^static unsigned long obj_idx_to_offset(struct page *page,$/;"	f	file:
obj_location_to_handle	./zsmalloc.c	/^static void *obj_location_to_handle(struct page *page, unsigned long obj_idx)$/;"	f	file:
obj_offset	./slab.c	/^static int obj_offset(struct kmem_cache *cachep)$/;"	f	file:
obj_offset	./slab.c	382;"	d	file:
obj_to_index	./slab.c	/^static inline unsigned int obj_to_index(const struct kmem_cache *cache,$/;"	f	file:
object_cache	./kmemleak.c	/^static struct kmem_cache *object_cache;$/;"	v	typeref:struct:kmem_cache	file:
object_err	./slub.c	/^static void object_err(struct kmem_cache *s, struct page *page,$/;"	f	file:
object_list	./kmemleak.c	/^	struct list_head object_list;$/;"	m	struct:kmemleak_object	typeref:struct:kmemleak_object::list_head	file:
object_no_scan	./kmemleak.c	/^static void object_no_scan(unsigned long ptr)$/;"	f	file:
object_size	./slub.c	/^SLAB_ATTR_RO(object_size);$/;"	v
object_size_show	./slub.c	/^static ssize_t object_size_show(struct kmem_cache *s, char *buf)$/;"	f	file:
object_tree_root	./kmemleak.c	/^static struct rb_root object_tree_root = RB_ROOT;$/;"	v	typeref:struct:rb_root	file:
objects	./slub.c	/^SLAB_ATTR_RO(objects);$/;"	v
objects_partial	./slub.c	/^SLAB_ATTR_RO(objects_partial);$/;"	v
objects_partial_show	./slub.c	/^static ssize_t objects_partial_show(struct kmem_cache *s, char *buf)$/;"	f	file:
objects_per_slab	./slab.h	/^	unsigned int objects_per_slab;$/;"	m	struct:slabinfo
objects_show	./slub.c	/^static ssize_t objects_show(struct kmem_cache *s, char *buf)$/;"	f	file:
objs_per_slab	./slub.c	/^SLAB_ATTR_RO(objs_per_slab);$/;"	v
objs_per_slab_show	./slub.c	/^static ssize_t objs_per_slab_show(struct kmem_cache *s, char *buf)$/;"	f	file:
offline_isolated_pages	./memory_hotplug.c	/^offline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)$/;"	f	file:
offline_isolated_pages_cb	./memory_hotplug.c	/^offline_isolated_pages_cb(unsigned long start, unsigned long nr_pages,$/;"	f	file:
offline_page_cgroup	./page_cgroup.c	/^static int __meminit offline_page_cgroup(unsigned long start_pfn,$/;"	f	file:
offline_pages	./memory_hotplug.c	/^int offline_pages(unsigned long start_pfn, unsigned long nr_pages)$/;"	f
offset	./dmapool.c	/^	unsigned int offset;$/;"	m	struct:dma_page	file:
offset	./mmap.c	/^	unsigned long offset;$/;"	m	struct:mmap_arg_struct	file:
offset	./nommu.c	/^	unsigned long offset;$/;"	m	struct:mmap_arg_struct	file:
offset	./zswap.c	/^	pgoff_t offset;$/;"	m	struct:zswap_entry	file:
offset_il_node	./mempolicy.c	/^static unsigned offset_il_node(struct mempolicy *pol,$/;"	f	file:
oldchecksum	./ksm.c	/^	unsigned int oldchecksum;	\/* when unstable *\/$/;"	m	struct:rmap_item	file:
on_freelist	./slub.c	/^static int on_freelist(struct kmem_cache *s, struct page *page, void *search)$/;"	f	file:
on_slab_alc_key	./slab.c	/^static struct lock_class_key on_slab_alc_key;$/;"	v	typeref:struct:lock_class_key	file:
on_slab_l3_key	./slab.c	/^static struct lock_class_key on_slab_l3_key;$/;"	v	typeref:struct:lock_class_key	file:
on_slab_lock_classes	./slab.c	/^static inline void on_slab_lock_classes(struct kmem_cache *cachep)$/;"	f	file:
on_slab_lock_classes_node	./slab.c	/^static inline void on_slab_lock_classes_node(struct kmem_cache *cachep, int node)$/;"	f	file:
on_slab_lock_classes_node	./slab.c	/^static void on_slab_lock_classes_node(struct kmem_cache *cachep, int q)$/;"	f	file:
on_tree	./memcontrol.c	/^	bool			on_tree;$/;"	m	struct:mem_cgroup_per_zone	file:
ondemand_readahead	./readahead.c	/^ondemand_readahead(struct address_space *mapping,$/;"	f	file:
one_stable_tree	./ksm.c	/^static struct rb_root one_stable_tree[1] = { RB_ROOT };$/;"	v	typeref:struct:rb_root	file:
one_unstable_tree	./ksm.c	/^static struct rb_root one_unstable_tree[1] = { RB_ROOT };$/;"	v	typeref:struct:rb_root	file:
online_page_callback	./memory_hotplug.c	/^static online_page_callback_t online_page_callback = generic_online_page;$/;"	v	file:
online_page_cgroup	./page_cgroup.c	/^static int __meminit online_page_cgroup(unsigned long start_pfn,$/;"	f	file:
online_pages	./memory_hotplug.c	/^int __ref online_pages(unsigned long pfn, unsigned long nr_pages, int online_type)$/;"	f
online_pages_range	./memory_hotplug.c	/^static int online_pages_range(unsigned long start_pfn, unsigned long nr_pages,$/;"	f	file:
oo_make	./slub.c	/^static inline struct kmem_cache_order_objects oo_make(int order,$/;"	f	file:
oo_objects	./slub.c	/^static inline int oo_objects(struct kmem_cache_order_objects x)$/;"	f	file:
oo_order	./slub.c	/^static inline int oo_order(struct kmem_cache_order_objects x)$/;"	f	file:
oom_badness	./oom_kill.c	/^unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,$/;"	f
oom_kill_disable	./memcontrol.c	/^	int		oom_kill_disable;$/;"	m	struct:mem_cgroup	file:
oom_kill_process	./oom_kill.c	/^void oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,$/;"	f
oom_lock	./memcontrol.c	/^	bool		oom_lock;$/;"	m	struct:mem_cgroup	file:
oom_notify	./memcontrol.c	/^	struct list_head oom_notify;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::list_head	file:
oom_scan_process_thread	./oom_kill.c	/^enum oom_scan_t oom_scan_process_thread(struct task_struct *task,$/;"	f
oom_unkillable_task	./oom_kill.c	/^static bool oom_unkillable_task(struct task_struct *p,$/;"	f	file:
oom_wait_info	./memcontrol.c	/^struct oom_wait_info {$/;"	s	file:
oom_wakeups	./memcontrol.c	/^	atomic_t	oom_wakeups;$/;"	m	struct:mem_cgroup	file:
op_type	./kmemleak.c	/^	int op_type;			\/* kmemleak operation type *\/$/;"	m	struct:early_log	file:
ops	./zbud.c	/^	struct zbud_ops *ops;$/;"	m	struct:zbud_pool	typeref:struct:zbud_pool::zbud_ops	file:
order	./internal.h	/^	int order;			\/* order a direct compactor needs *\/$/;"	m	struct:compact_control
order	./slub.c	/^SLAB_ATTR(order);$/;"	v
order	./vmscan.c	/^	int order;$/;"	m	struct:scan_control	file:
order_objects	./slub.c	/^static inline int order_objects(int order, unsigned long size, int reserved)$/;"	f	file:
order_show	./slub.c	/^static ssize_t order_show(struct kmem_cache *s, char *buf)$/;"	f	file:
order_store	./slub.c	/^static ssize_t order_store(struct kmem_cache *s,$/;"	f	file:
out_of_memory	./oom_kill.c	/^void out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask,$/;"	f
outcome	./memory-failure.c	/^enum outcome {$/;"	g	file:
overcommit_kbytes_handler	./util.c	/^int overcommit_kbytes_handler(struct ctl_table *table, int write,$/;"	f
overcommit_ratio_handler	./util.c	/^int overcommit_ratio_handler(struct ctl_table *table, int write,$/;"	f
pack_shadow	./workingset.c	/^static void *pack_shadow(unsigned long eviction, struct zone *zone)$/;"	f	file:
page	./highmem.c	/^	struct page *page;$/;"	m	struct:page_address_map	typeref:struct:page_address_map::page	file:
page	./memcontrol.c	/^	struct page	*page;$/;"	m	union:mc_target	typeref:struct:mc_target::page	file:
page	./migrate.c	/^	struct page *page;$/;"	m	struct:page_to_node	typeref:struct:page_to_node::page	file:
page_action	./memory-failure.c	/^static int page_action(struct page_state *ps, struct page *p,$/;"	f	file:
page_add_anon_rmap	./rmap.c	/^void page_add_anon_rmap(struct page *page,$/;"	f
page_add_file_rmap	./rmap.c	/^void page_add_file_rmap(struct page *page)$/;"	f
page_add_new_anon_rmap	./rmap.c	/^void page_add_new_anon_rmap(struct page *page,$/;"	f
page_address	./highmem.c	/^EXPORT_SYMBOL(page_address);$/;"	v
page_address	./highmem.c	/^void *page_address(const struct page *page)$/;"	f
page_address_htable	./highmem.c	/^} ____cacheline_aligned_in_smp page_address_htable[1<<PA_HASH_ORDER];$/;"	v	typeref:struct:page_address_slot	file:
page_address_in_vma	./rmap.c	/^unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)$/;"	f
page_address_init	./highmem.c	/^void __init page_address_init(void)$/;"	f
page_address_map	./highmem.c	/^struct page_address_map {$/;"	s	file:
page_address_maps	./highmem.c	/^static struct page_address_map page_address_maps[LAST_PKMAP];$/;"	v	typeref:struct:page_address_map	file:
page_address_slot	./highmem.c	/^static struct page_address_slot {$/;"	s	file:
page_alloc_cpu_notify	./page_alloc.c	/^static int page_alloc_cpu_notify(struct notifier_block *self,$/;"	f	file:
page_alloc_init	./page_alloc.c	/^void __init page_alloc_init(void)$/;"	f
page_cache_async_readahead	./readahead.c	/^EXPORT_SYMBOL_GPL(page_cache_async_readahead);$/;"	v
page_cache_async_readahead	./readahead.c	/^page_cache_async_readahead(struct address_space *mapping,$/;"	f
page_cache_next_hole	./filemap.c	/^EXPORT_SYMBOL(page_cache_next_hole);$/;"	v
page_cache_next_hole	./filemap.c	/^pgoff_t page_cache_next_hole(struct address_space *mapping,$/;"	f
page_cache_prev_hole	./filemap.c	/^EXPORT_SYMBOL(page_cache_prev_hole);$/;"	v
page_cache_prev_hole	./filemap.c	/^pgoff_t page_cache_prev_hole(struct address_space *mapping,$/;"	f
page_cache_read	./filemap.c	/^static int page_cache_read(struct file *file, pgoff_t offset)$/;"	f	file:
page_cache_sync_readahead	./readahead.c	/^EXPORT_SYMBOL_GPL(page_cache_sync_readahead);$/;"	v
page_cache_sync_readahead	./readahead.c	/^void page_cache_sync_readahead(struct address_space *mapping,$/;"	f
page_cache_tree_delete	./filemap.c	/^static void page_cache_tree_delete(struct address_space *mapping,$/;"	f	file:
page_cache_tree_insert	./filemap.c	/^static int page_cache_tree_insert(struct address_space *mapping,$/;"	f	file:
page_cgroup_callback	./page_cgroup.c	/^static int __meminit page_cgroup_callback(struct notifier_block *self,$/;"	f	file:
page_cgroup_init	./page_cgroup.c	/^void __init page_cgroup_init(void)$/;"	f
page_cgroup_init_flatmem	./page_cgroup.c	/^void __init page_cgroup_init_flatmem(void)$/;"	f
page_cgroup_zoneinfo	./memcontrol.c	/^page_cgroup_zoneinfo(struct mem_cgroup *memcg, struct page *page)$/;"	f	file:
page_check_address_pmd	./huge_memory.c	/^pmd_t *page_check_address_pmd(struct page *page,$/;"	f
page_check_dirty_writeback	./vmscan.c	/^static void page_check_dirty_writeback(struct page *page,$/;"	f	file:
page_check_references	./vmscan.c	/^static enum page_references page_check_references(struct page *page,$/;"	f	file:
page_cluster	./swap.c	/^int page_cluster;$/;"	v
page_cpupid_xchg_last	./mmzone.c	/^int page_cpupid_xchg_last(struct page *page, int cpupid)$/;"	f
page_evictable	./vmscan.c	/^int page_evictable(struct page *page)$/;"	f
page_get_anon_vma	./rmap.c	/^struct anon_vma *page_get_anon_vma(struct page *page)$/;"	f
page_is_buddy	./page_alloc.c	/^static inline int page_is_buddy(struct page *page, struct page *buddy,$/;"	f	file:
page_is_consistent	./page_alloc.c	/^static int page_is_consistent(struct zone *zone, struct page *page)$/;"	f	file:
page_list	./dmapool.c	/^	struct list_head page_list;$/;"	m	struct:dma_page	typeref:struct:dma_page::list_head	file:
page_list	./dmapool.c	/^	struct list_head page_list;$/;"	m	struct:dma_pool	typeref:struct:dma_pool::list_head	file:
page_lock_anon_vma_read	./rmap.c	/^struct anon_vma *page_lock_anon_vma_read(struct page *page)$/;"	f
page_mapped_in_vma	./rmap.c	/^int page_mapped_in_vma(struct page *page, struct vm_area_struct *vma)$/;"	f
page_mapping	./util.c	/^struct address_space *page_mapping(struct page *page)$/;"	f
page_mkclean	./rmap.c	/^EXPORT_SYMBOL_GPL(page_mkclean);$/;"	v
page_mkclean	./rmap.c	/^int page_mkclean(struct page *page)$/;"	f
page_mkclean_one	./rmap.c	/^static int page_mkclean_one(struct page *page, struct vm_area_struct *vma,$/;"	f	file:
page_move_anon_rmap	./rmap.c	/^void page_move_anon_rmap(struct page *page,$/;"	f
page_not_mapped	./rmap.c	/^static int page_not_mapped(struct page *page)$/;"	f	file:
page_order	./internal.h	/^static inline unsigned long page_order(struct page *page)$/;"	f
page_outside_zone_boundaries	./page_alloc.c	/^static int page_outside_zone_boundaries(struct zone *zone, struct page *page)$/;"	f	file:
page_poison	./debug-pagealloc.c	/^static inline bool page_poison(struct page *page)$/;"	f	file:
page_pool	./bounce.c	/^static mempool_t *page_pool, *isa_page_pool;$/;"	v	file:
page_ptl_cachep	./memory.c	/^static struct kmem_cache *page_ptl_cachep;$/;"	v	typeref:struct:kmem_cache	file:
page_referenced	./rmap.c	/^int page_referenced(struct page *page,$/;"	f
page_referenced_arg	./rmap.c	/^struct page_referenced_arg {$/;"	s	file:
page_referenced_one	./rmap.c	/^int page_referenced_one(struct page *page, struct vm_area_struct *vma,$/;"	f
page_references	./vmscan.c	/^enum page_references {$/;"	g	file:
page_remove_rmap	./rmap.c	/^void page_remove_rmap(struct page *page)$/;"	f
page_slot	./highmem.c	/^static struct page_address_slot *page_slot(const struct page *page)$/;"	f	file:
page_state	./memory-failure.c	/^static struct page_state {$/;"	s	file:
page_swap_info	./swapfile.c	/^struct swap_info_struct *page_swap_info(struct page *page)$/;"	f
page_swapcount	./swapfile.c	/^int page_swapcount(struct page *page)$/;"	f
page_table_shareable	./hugetlb.c	/^static unsigned long page_table_shareable(struct vm_area_struct *svma,$/;"	f	file:
page_to_nid	./sparse.c	/^EXPORT_SYMBOL(page_to_nid);$/;"	v
page_to_nid	./sparse.c	/^int page_to_nid(const struct page *page)$/;"	f
page_to_node	./migrate.c	/^struct page_to_node {$/;"	s	file:
page_trans_compound_anon	./ksm.c	/^static struct page *page_trans_compound_anon(struct page *page)$/;"	f	file:
page_trans_compound_anon_split	./ksm.c	/^static int page_trans_compound_anon_split(struct page *page)$/;"	f	file:
page_unlock_anon_vma_read	./rmap.c	/^void page_unlock_anon_vma_read(struct anon_vma *anon_vma)$/;"	f
page_waitqueue	./filemap.c	/^static wait_queue_head_t *page_waitqueue(struct page *page)$/;"	f	file:
page_writeback_init	./page-writeback.c	/^void __init page_writeback_init(void)$/;"	f
pageblock_free	./memory_hotplug.c	/^static inline int pageblock_free(struct page *page)$/;"	f	file:
pageblock_is_reserved	./page_alloc.c	/^static int pageblock_is_reserved(unsigned long start_pfn, unsigned long end_pfn)$/;"	f	file:
pagecache_write_begin	./filemap.c	/^EXPORT_SYMBOL(pagecache_write_begin);$/;"	v
pagecache_write_begin	./filemap.c	/^int pagecache_write_begin(struct file *file, struct address_space *mapping,$/;"	f
pagecache_write_end	./filemap.c	/^EXPORT_SYMBOL(pagecache_write_end);$/;"	v
pagecache_write_end	./filemap.c	/^int pagecache_write_end(struct file *file, struct address_space *mapping,$/;"	f
pagefault_out_of_memory	./oom_kill.c	/^void pagefault_out_of_memory(void)$/;"	f
pageflag_names	./page_alloc.c	/^static const struct trace_print_flags pageflag_names[] = {$/;"	v	typeref:struct:trace_print_flags	file:
pageout	./vmscan.c	/^static pageout_t pageout(struct page *page, struct address_space *mapping,$/;"	f	file:
pageout_t	./vmscan.c	/^} pageout_t;$/;"	t	typeref:enum:__anon13	file:
pages_allocated	./zsmalloc.c	/^	u64 pages_allocated;$/;"	m	struct:size_class	file:
pages_collapsed_attr	./huge_memory.c	/^static struct kobj_attribute pages_collapsed_attr =$/;"	v	typeref:struct:kobj_attribute	file:
pages_collapsed_show	./huge_memory.c	/^static ssize_t pages_collapsed_show(struct kobject *kobj,$/;"	f	file:
pages_identical	./ksm.c	/^static inline int pages_identical(struct page *page1, struct page *page2)$/;"	f	file:
pages_nr	./zbud.c	/^	u64 pages_nr;$/;"	m	struct:zbud_pool	file:
pages_per_zspage	./zsmalloc.c	/^	int pages_per_zspage;$/;"	m	struct:size_class	file:
pages_shared	./ksm.c	/^KSM_ATTR_RO(pages_shared);$/;"	v
pages_shared_show	./ksm.c	/^static ssize_t pages_shared_show(struct kobject *kobj,$/;"	f	file:
pages_sharing	./ksm.c	/^KSM_ATTR_RO(pages_sharing);$/;"	v
pages_sharing_show	./ksm.c	/^static ssize_t pages_sharing_show(struct kobject *kobj,$/;"	f	file:
pages_to_scan	./ksm.c	/^KSM_ATTR(pages_to_scan);$/;"	v
pages_to_scan_attr	./huge_memory.c	/^static struct kobj_attribute pages_to_scan_attr =$/;"	v	typeref:struct:kobj_attribute	file:
pages_to_scan_show	./huge_memory.c	/^static ssize_t pages_to_scan_show(struct kobject *kobj,$/;"	f	file:
pages_to_scan_show	./ksm.c	/^static ssize_t pages_to_scan_show(struct kobject *kobj,$/;"	f	file:
pages_to_scan_store	./huge_memory.c	/^static ssize_t pages_to_scan_store(struct kobject *kobj,$/;"	f	file:
pages_to_scan_store	./ksm.c	/^static ssize_t pages_to_scan_store(struct kobject *kobj,$/;"	f	file:
pages_unshared	./ksm.c	/^KSM_ATTR_RO(pages_unshared);$/;"	v
pages_unshared_show	./ksm.c	/^static ssize_t pages_unshared_show(struct kobject *kobj,$/;"	f	file:
pages_volatile	./ksm.c	/^KSM_ATTR_RO(pages_volatile);$/;"	v
pages_volatile_show	./ksm.c	/^static ssize_t pages_volatile_show(struct kobject *kobj,$/;"	f	file:
pageset_init	./page_alloc.c	/^static void pageset_init(struct per_cpu_pageset *p)$/;"	f	file:
pageset_set_batch	./page_alloc.c	/^static void pageset_set_batch(struct per_cpu_pageset *p, unsigned long batch)$/;"	f	file:
pageset_set_high	./page_alloc.c	/^static void pageset_set_high(struct per_cpu_pageset *p,$/;"	f	file:
pageset_set_high_and_batch	./page_alloc.c	/^static void __meminit pageset_set_high_and_batch(struct zone *zone,$/;"	f	file:
pageset_update	./page_alloc.c	/^static void pageset_update(struct per_cpu_pages *pcp, unsigned long high,$/;"	f	file:
pagetypeinfo_file_ops	./vmstat.c	/^static const struct file_operations pagetypeinfo_file_ops = {$/;"	v	typeref:struct:file_operations	file:
pagetypeinfo_op	./vmstat.c	/^static const struct seq_operations pagetypeinfo_op = {$/;"	v	typeref:struct:seq_operations	file:
pagetypeinfo_open	./vmstat.c	/^static int pagetypeinfo_open(struct inode *inode, struct file *file)$/;"	f	file:
pagetypeinfo_show	./vmstat.c	/^static int pagetypeinfo_show(struct seq_file *m, void *arg)$/;"	f	file:
pagetypeinfo_showblockcount	./vmstat.c	/^static int pagetypeinfo_showblockcount(struct seq_file *m, void *arg)$/;"	f	file:
pagetypeinfo_showblockcount_print	./vmstat.c	/^static void pagetypeinfo_showblockcount_print(struct seq_file *m,$/;"	f	file:
pagetypeinfo_showfree	./vmstat.c	/^static int pagetypeinfo_showfree(struct seq_file *m, void *arg)$/;"	f	file:
pagetypeinfo_showfree_print	./vmstat.c	/^static void pagetypeinfo_showfree_print(struct seq_file *m,$/;"	f	file:
pagevec_lookup	./swap.c	/^EXPORT_SYMBOL(pagevec_lookup);$/;"	v
pagevec_lookup	./swap.c	/^unsigned pagevec_lookup(struct pagevec *pvec, struct address_space *mapping,$/;"	f
pagevec_lookup_entries	./swap.c	/^unsigned pagevec_lookup_entries(struct pagevec *pvec,$/;"	f
pagevec_lookup_tag	./swap.c	/^EXPORT_SYMBOL(pagevec_lookup_tag);$/;"	v
pagevec_lookup_tag	./swap.c	/^unsigned pagevec_lookup_tag(struct pagevec *pvec, struct address_space *mapping,$/;"	f
pagevec_lru_move_fn	./swap.c	/^static void pagevec_lru_move_fn(struct pagevec *pvec,$/;"	f	file:
pagevec_move_tail	./swap.c	/^static void pagevec_move_tail(struct pagevec *pvec)$/;"	f	file:
pagevec_move_tail_fn	./swap.c	/^static void pagevec_move_tail_fn(struct page *page, struct lruvec *lruvec,$/;"	f	file:
pagevec_remove_exceptionals	./swap.c	/^void pagevec_remove_exceptionals(struct pagevec *pvec)$/;"	f
paint_it	./kmemleak.c	/^static void paint_it(struct kmemleak_object *object, int color)$/;"	f	file:
paint_ptr	./kmemleak.c	/^static void paint_ptr(unsigned long ptr, int color)$/;"	f	file:
parent_hugetlb_cgroup	./hugetlb_cgroup.c	/^parent_hugetlb_cgroup(struct hugetlb_cgroup *h_cg)$/;"	f	file:
parent_mem_cgroup	./memcontrol.c	/^EXPORT_SYMBOL(parent_mem_cgroup);$/;"	v
parent_mem_cgroup	./memcontrol.c	/^struct mem_cgroup *parent_mem_cgroup(struct mem_cgroup *memcg)$/;"	f
parsed_hstate	./hugetlb.c	/^static struct hstate * __initdata parsed_hstate;$/;"	v	typeref:struct:__initdata	file:
partial	./slab.h	/^	struct list_head partial;$/;"	m	struct:kmem_cache_node	typeref:struct:kmem_cache_node::list_head
partial	./slub.c	/^SLAB_ATTR_RO(partial);$/;"	v
partial_show	./slub.c	/^static ssize_t partial_show(struct kmem_cache *s, char *buf)$/;"	f	file:
pcp_counter_lock	./memcontrol.c	/^	spinlock_t pcp_counter_lock;$/;"	m	struct:mem_cgroup	file:
pcpu_addr_in_first_chunk	./percpu.c	/^static bool pcpu_addr_in_first_chunk(void *addr)$/;"	f	file:
pcpu_addr_in_reserved_chunk	./percpu.c	/^static bool pcpu_addr_in_reserved_chunk(void *addr)$/;"	f	file:
pcpu_addr_to_page	./percpu-km.c	/^static struct page *pcpu_addr_to_page(void *addr)$/;"	f	file:
pcpu_addr_to_page	./percpu-vm.c	/^static struct page *pcpu_addr_to_page(void *addr)$/;"	f	file:
pcpu_alloc	./percpu.c	/^static void __percpu *pcpu_alloc(size_t size, size_t align, bool reserved)$/;"	f	file:
pcpu_alloc_alloc_info	./percpu.c	/^struct pcpu_alloc_info * __init pcpu_alloc_alloc_info(int nr_groups,$/;"	f
pcpu_alloc_area	./percpu.c	/^static int pcpu_alloc_area(struct pcpu_chunk *chunk, int size, int align)$/;"	f	file:
pcpu_alloc_chunk	./percpu.c	/^static struct pcpu_chunk *pcpu_alloc_chunk(void)$/;"	f	file:
pcpu_alloc_pages	./percpu-vm.c	/^static int pcpu_alloc_pages(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_base_addr	./percpu.c	/^EXPORT_SYMBOL_GPL(pcpu_base_addr);$/;"	v
pcpu_build_alloc_info	./percpu.c	/^static struct pcpu_alloc_info * __init pcpu_build_alloc_info($/;"	f	file:
pcpu_chunk	./percpu.c	/^struct pcpu_chunk {$/;"	s	file:
pcpu_chunk_addr	./percpu.c	/^static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_chunk_addr_search	./percpu.c	/^static struct pcpu_chunk *pcpu_chunk_addr_search(void *addr)$/;"	f	file:
pcpu_chunk_page	./percpu-vm.c	/^static struct page *pcpu_chunk_page(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_chunk_relocate	./percpu.c	/^static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)$/;"	f	file:
pcpu_chunk_slot	./percpu.c	/^static int pcpu_chunk_slot(const struct pcpu_chunk *chunk)$/;"	f	file:
pcpu_create_chunk	./percpu-km.c	/^static struct pcpu_chunk *pcpu_create_chunk(void)$/;"	f	file:
pcpu_create_chunk	./percpu-vm.c	/^static struct pcpu_chunk *pcpu_create_chunk(void)$/;"	f	file:
pcpu_depopulate_chunk	./percpu-km.c	/^static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk, int off, int size)$/;"	f	file:
pcpu_depopulate_chunk	./percpu-vm.c	/^static void pcpu_depopulate_chunk(struct pcpu_chunk *chunk, int off, int size)$/;"	f	file:
pcpu_destroy_chunk	./percpu-km.c	/^static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)$/;"	f	file:
pcpu_destroy_chunk	./percpu-vm.c	/^static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)$/;"	f	file:
pcpu_dfl_fc_alloc	./percpu.c	/^static void * __init pcpu_dfl_fc_alloc(unsigned int cpu, size_t size,$/;"	f	file:
pcpu_dfl_fc_free	./percpu.c	/^static void __init pcpu_dfl_fc_free(void *ptr, size_t size)$/;"	f	file:
pcpu_dump_alloc_info	./percpu.c	/^static void pcpu_dump_alloc_info(const char *lvl,$/;"	f	file:
pcpu_embed_first_chunk	./percpu.c	/^int __init pcpu_embed_first_chunk(size_t reserved_size, size_t dyn_size,$/;"	f
pcpu_extend_area_map	./percpu.c	/^static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)$/;"	f	file:
pcpu_first_chunk	./percpu.c	/^static struct pcpu_chunk *pcpu_first_chunk;$/;"	v	typeref:struct:pcpu_chunk	file:
pcpu_for_each_pop_region	./percpu.c	272;"	d	file:
pcpu_for_each_unpop_region	./percpu.c	267;"	d	file:
pcpu_free_alloc_info	./percpu.c	/^void __init pcpu_free_alloc_info(struct pcpu_alloc_info *ai)$/;"	f
pcpu_free_area	./percpu.c	/^static void pcpu_free_area(struct pcpu_chunk *chunk, int freeme)$/;"	f	file:
pcpu_free_chunk	./percpu.c	/^static void pcpu_free_chunk(struct pcpu_chunk *chunk)$/;"	f	file:
pcpu_free_pages	./percpu-vm.c	/^static void pcpu_free_pages(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_free_vm_areas	./vmalloc.c	/^void pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms)$/;"	f
pcpu_get_page_chunk	./percpu.c	/^static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)$/;"	f	file:
pcpu_get_pages_and_bitmap	./percpu-vm.c	/^static struct page **pcpu_get_pages_and_bitmap(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_get_vm_areas	./vmalloc.c	/^struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,$/;"	f
pcpu_map_pages	./percpu-vm.c	/^static int pcpu_map_pages(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_mem_free	./percpu.c	/^static void pcpu_mem_free(void *ptr, size_t size)$/;"	f	file:
pcpu_mem_zalloc	./percpu.c	/^static void *pcpu_mem_zalloc(size_t size)$/;"	f	file:
pcpu_need_to_extend	./percpu.c	/^static int pcpu_need_to_extend(struct pcpu_chunk *chunk)$/;"	f	file:
pcpu_next_pop	./percpu.c	/^static void __maybe_unused pcpu_next_pop(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_next_unpop	./percpu.c	/^static void __maybe_unused pcpu_next_unpop(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_page_first_chunk	./percpu.c	/^int __init pcpu_page_first_chunk(size_t reserved_size,$/;"	f
pcpu_page_idx	./percpu.c	/^static int __maybe_unused pcpu_page_idx(unsigned int cpu, int page_idx)$/;"	f	file:
pcpu_populate_chunk	./percpu-km.c	/^static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)$/;"	f	file:
pcpu_populate_chunk	./percpu-vm.c	/^static int pcpu_populate_chunk(struct pcpu_chunk *chunk, int off, int size)$/;"	f	file:
pcpu_post_map_flush	./percpu-vm.c	/^static void pcpu_post_map_flush(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_post_unmap_tlb_flush	./percpu-vm.c	/^static void pcpu_post_unmap_tlb_flush(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_pre_unmap_flush	./percpu-vm.c	/^static void pcpu_pre_unmap_flush(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_reclaim	./percpu.c	/^static void pcpu_reclaim(struct work_struct *work)$/;"	f	file:
pcpu_reserved_chunk	./percpu.c	/^static struct pcpu_chunk *pcpu_reserved_chunk;$/;"	v	typeref:struct:pcpu_chunk	file:
pcpu_reserved_chunk_limit	./percpu.c	/^static int pcpu_reserved_chunk_limit;$/;"	v	file:
pcpu_set_page_chunk	./percpu.c	/^static void pcpu_set_page_chunk(struct page *page, struct pcpu_chunk *pcpu)$/;"	f	file:
pcpu_setup_first_chunk	./percpu.c	/^int __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai,$/;"	f
pcpu_size_to_slot	./percpu.c	/^static int pcpu_size_to_slot(int size)$/;"	f	file:
pcpu_unmap_pages	./percpu-vm.c	/^static void pcpu_unmap_pages(struct pcpu_chunk *chunk,$/;"	f	file:
pcpu_verify_alloc_info	./percpu-km.c	/^static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)$/;"	f	file:
pcpu_verify_alloc_info	./percpu-vm.c	/^static int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)$/;"	f	file:
pdflush_proc_obsolete	./backing-dev.c	/^int pdflush_proc_obsolete(struct ctl_table *table, int write,$/;"	f
per_cpu_ptr_to_phys	./percpu.c	/^phys_addr_t per_cpu_ptr_to_phys(void *addr)$/;"	f
per_node_hstate_attr_group	./hugetlb.c	/^static struct attribute_group per_node_hstate_attr_group = {$/;"	v	typeref:struct:attribute_group	file:
per_node_hstate_attrs	./hugetlb.c	/^static struct attribute *per_node_hstate_attrs[] = {$/;"	v	typeref:struct:attribute	file:
percpu_alloc_setup	./percpu.c	/^static int __init percpu_alloc_setup(char *str)$/;"	f	file:
percpu_init_late	./percpu.c	/^void __init percpu_init_late(void)$/;"	f
percpu_pagelist_fraction	./page_alloc.c	/^int percpu_pagelist_fraction;$/;"	v
percpu_pagelist_fraction_sysctl_handler	./page_alloc.c	/^int percpu_pagelist_fraction_sysctl_handler(ctl_table *table, int write,$/;"	f
persistent_huge_pages	./hugetlb.c	1476;"	d	file:
pfmemalloc_match	./slub.c	/^static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags)$/;"	f	file:
pfmemalloc_watermark_ok	./vmscan.c	/^static bool pfmemalloc_watermark_ok(pg_data_t *pgdat)$/;"	f	file:
pfn	./memory-failure.c	/^	unsigned long pfn;$/;"	m	struct:memory_failure_entry	file:
pfn_inject_exit	./hwpoison-inject.c	/^module_exit(pfn_inject_exit);$/;"	v
pfn_inject_exit	./hwpoison-inject.c	/^static void pfn_inject_exit(void)$/;"	f	file:
pfn_inject_init	./hwpoison-inject.c	/^module_init(pfn_inject_init);$/;"	v
pfn_inject_init	./hwpoison-inject.c	/^static int pfn_inject_init(void)$/;"	f	file:
pfn_max_align_down	./page_alloc.c	/^static unsigned long pfn_max_align_down(unsigned long pfn)$/;"	f	file:
pfn_max_align_up	./page_alloc.c	/^static unsigned long pfn_max_align_up(unsigned long pfn)$/;"	f	file:
pfn_to_bitidx	./page_alloc.c	/^static inline int pfn_to_bitidx(struct zone *zone, unsigned long pfn)$/;"	f	file:
pgd_clear_bad	./pgtable-generic.c	/^void pgd_clear_bad(pgd_t *pgd)$/;"	f
pgdat_balanced	./vmscan.c	/^static bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)$/;"	f	file:
pgdat_page_cgroup_init	./page_cgroup.c	/^void __meminit pgdat_page_cgroup_init(struct pglist_data *pgdat)$/;"	f
pgprot_modify	./mprotect.c	/^static inline pgprot_t pgprot_modify(pgprot_t oldprot, pgprot_t newprot)$/;"	f	file:
pgtable_trans_huge_deposit	./pgtable-generic.c	/^void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,$/;"	f
pgtable_trans_huge_withdraw	./pgtable-generic.c	/^pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)$/;"	f
pid	./kmemleak.c	/^	pid_t pid;			\/* pid of the current task *\/$/;"	m	struct:kmemleak_object	file:
pid	./slub.c	/^	int pid;		\/* Pid context *\/$/;"	m	struct:track	file:
pkmap_count	./highmem.c	/^static int pkmap_count[LAST_PKMAP];$/;"	v	file:
pkmap_page_table	./highmem.c	/^pte_t * pkmap_page_table;$/;"	v
pm_restore_gfp_mask	./page_alloc.c	/^void pm_restore_gfp_mask(void)$/;"	f
pm_restrict_gfp_mask	./page_alloc.c	/^void pm_restrict_gfp_mask(void)$/;"	f
pm_suspended_storage	./page_alloc.c	/^bool pm_suspended_storage(void)$/;"	f
pmd_clear_bad	./pgtable-generic.c	/^void pmd_clear_bad(pmd_t *pmd)$/;"	f
pmd_trans_migrating	./migrate.c	/^bool pmd_trans_migrating(pmd_t pmd)$/;"	f
pmdp_clear_flush	./pgtable-generic.c	/^pmd_t pmdp_clear_flush(struct vm_area_struct *vma, unsigned long address,$/;"	f
pmdp_clear_flush_young	./pgtable-generic.c	/^int pmdp_clear_flush_young(struct vm_area_struct *vma,$/;"	f
pmdp_invalidate	./pgtable-generic.c	/^void pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,$/;"	f
pmdp_set_access_flags	./pgtable-generic.c	/^int pmdp_set_access_flags(struct vm_area_struct *vma,$/;"	f
pmdp_splitting_flush	./pgtable-generic.c	/^void pmdp_splitting_flush(struct vm_area_struct *vma, unsigned long address,$/;"	f
pointer	./kmemleak.c	/^	unsigned long pointer;$/;"	m	struct:kmemleak_object	file:
poison	./slub.c	/^SLAB_ATTR(poison);$/;"	v
poison_obj	./slab.c	/^static void poison_obj(struct kmem_cache *cachep, void *addr, unsigned char val)$/;"	f	file:
poison_page	./debug-pagealloc.c	/^static void poison_page(struct page *page)$/;"	f	file:
poison_pages	./debug-pagealloc.c	/^static void poison_pages(struct page *page, int n)$/;"	f	file:
poison_show	./slub.c	/^static ssize_t poison_show(struct kmem_cache *s, char *buf)$/;"	f	file:
poison_store	./slub.c	/^static ssize_t poison_store(struct kmem_cache *s,$/;"	f	file:
policy_cache	./mempolicy.c	/^static struct kmem_cache *policy_cache;$/;"	v	typeref:struct:kmem_cache	file:
policy_modes	./mempolicy.c	/^static const char * const policy_modes[] =$/;"	v	file:
policy_nodemask	./mempolicy.c	/^static nodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy)$/;"	f	file:
policy_zone	./mempolicy.c	/^enum zone_type policy_zone = 0;$/;"	v	typeref:enum:zone_type
policy_zonelist	./mempolicy.c	/^static struct zonelist *policy_zonelist(gfp_t gfp, struct mempolicy *policy,$/;"	f	file:
pool_alloc_page	./dmapool.c	/^static struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)$/;"	f	file:
pool_find_page	./dmapool.c	/^static struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)$/;"	f	file:
pool_free_page	./dmapool.c	/^static void pool_free_page(struct dma_pool *pool, struct dma_page *page)$/;"	f	file:
pool_initialise_page	./dmapool.c	/^static void pool_initialise_page(struct dma_pool *pool, struct dma_page *page)$/;"	f	file:
pools	./dmapool.c	/^	struct list_head pools;$/;"	m	struct:dma_pool	typeref:struct:dma_pool::list_head	file:
populated	./percpu.c	/^	unsigned long		populated[];	\/* populated bitmap *\/$/;"	m	struct:pcpu_chunk	file:
pos_alloc_page	./pos.c	/^struct page *pos_alloc_page(int kind)$/;"	f
pos_copy_and_free_map_array	./pos.c	/^int pos_copy_and_free_map_array(struct pos_vm_area *dst_vma, struct pos_map_array *src_map)$/;"	f
pos_copy_partial_map_array	./pos.c	/^int pos_copy_partial_map_array(struct pos_vm_area *dst_vma, struct pos_map_array *src_map,$/;"	f
pos_create_or_merge_vma	./pos.c	/^int pos_create_or_merge_vma(struct pos_superblock *sb,$/;"	f
pos_delete_or_split_vma	./pos.c	/^int pos_delete_or_split_vma(struct pos_superblock *sb,$/;"	f
pos_find_and_alloc_pfn	./pos.c	/^unsigned long pos_find_and_alloc_pfn(struct pos_vm_area *vma, unsigned long addr)$/;"	f
pos_find_and_alloc_pfn_pval	./pos.c	/^unsigned long pos_find_and_alloc_pfn_pval(struct pos_pval_descriptor *pval_desc, unsigned long addr, struct vm_area_struct *vma)$/;"	f
pos_find_and_alloc_pval_desc	./pos.c	/^unsigned long pos_find_and_alloc_pval_desc(unsigned long address, struct vm_area_struct *vma)$/;"	f
pos_find_and_remove_pval_desc	./pos.c	/^EXPORT_SYMBOL(pos_find_and_remove_pval_desc);$/;"	v
pos_find_and_remove_pval_desc	./pos.c	/^void pos_find_and_remove_pval_desc(struct inode *inode)$/;"	f
pos_find_pval_desc	./pos.c	/^pos_find_pval_desc(struct pos_pval_device *pval_dev, unsigned long ino)$/;"	f
pos_find_pval_desc_prepare	./pos.c	/^pos_find_pval_desc_prepare(struct pos_pval_device *pval_dev, unsigned long ino,$/;"	f	file:
pos_find_vma	./pos.c	/^struct pos_vm_area *pos_find_vma(struct pos_superblock *sb, unsigned long addr)$/;"	f
pos_find_vma_prepare	./pos.c	/^pos_find_vma_prepare(struct pos_superblock *sb, unsigned long addr,$/;"	f	file:
pos_find_vma_prev	./pos.c	/^pos_find_vma_prev(struct pos_superblock *sb, unsigned long addr,$/;"	f
pos_free_map_array	./pos.c	/^void pos_free_map_array(struct pos_map_array *map_array)$/;"	f
pos_free_page	./pos.c	/^void pos_free_page(unsigned long pfn)$/;"	f
pos_get_sb	./pos.c	/^struct pos_superblock* pos_get_sb(void)$/;"	f
pos_get_unmapped_area	./pos.c	/^unsigned long pos_get_unmapped_area(unsigned long len, struct pos_vm_area **prev_vma)$/;"	f
pos_init	./pos.c	/^EXPORT_SYMBOL(pos_init);$/;"	v
pos_init	./pos.c	/^void pos_init(void)$/;"	f
pos_insert_pfn_to_map_array	./pos.c	/^int pos_insert_pfn_to_map_array(struct pos_vm_area *vma, $/;"	f
pos_insert_pval_desc	./pos.c	/^int pos_insert_pval_desc(struct pos_pval_device *pval_dev, struct pos_pval_descriptor *pval_desc)$/;"	f
pos_insert_vm_area	./pos.c	/^int pos_insert_vm_area(struct pos_superblock *sb, struct pos_vm_area *vma)$/;"	f
pos_kfree	./pos.c	/^void pos_kfree(void *addr)$/;"	f
pos_kmalloc	./pos.c	/^void *pos_kmalloc(unsigned long size)$/;"	f
pos_kmem_cache_alloc	./pos.c	/^void *pos_kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)$/;"	f
pos_kmem_cache_create	./pos.c	/^pos_kmem_cache_create (const char *name, size_t size, size_t align,$/;"	f
pos_kmem_cache_destroy	./pos.c	/^void pos_kmem_cache_destroy(struct kmem_cache *cachep)$/;"	f
pos_kmem_cache_free	./pos.c	/^void pos_kmem_cache_free(struct kmem_cache *cachep, void *objp)$/;"	f
pos_level_to_pages	./pos.c	/^unsigned long pos_level_to_pages(int level)$/;"	f
pos_map_superblock	./pos.c	/^struct pos_superblock *pos_map_superblock(void)$/;"	f
pos_map_vma	./pos.c	/^int pos_map_vma(struct mm_struct *mm, unsigned long start, unsigned long end,$/;"	f
pos_merge_map_array	./pos.c	/^int pos_merge_map_array(struct pos_vm_area *dst_vma, struct pos_vm_area *src_vma)$/;"	f
pos_ns_burst	./pos_namespace.c	/^void pos_ns_burst(struct pos_ns_trie_node *prev_trie_node, int prev_index)$/;"	f
pos_ns_delete	./pos_namespace.c	/^struct pos_ns_record *pos_ns_delete(struct pos_ns_trie_node *root,$/;"	f
pos_ns_delete_record	./pos_namespace.c	/^struct pos_ns_record *pos_ns_delete_record(struct pos_ns_container *container,$/;"	f
pos_ns_insert	./pos_namespace.c	/^struct pos_ns_record *pos_ns_insert(struct pos_ns_trie_node *root,$/;"	f
pos_ns_insert_record	./pos_namespace.c	/^void pos_ns_insert_record(struct pos_ns_container *container, struct pos_ns_record *record)$/;"	f
pos_ns_limit_burst	./pos_namespace.c	/^int pos_ns_limit_burst(struct pos_ns_trie_node *trie_node, int index,$/;"	f
pos_ns_ratio_burst	./pos_namespace.c	/^int pos_ns_ratio_burst(struct pos_ns_trie_node *trie_node, int index,$/;"	f
pos_ns_search	./pos_namespace.c	/^struct pos_ns_record *pos_ns_search(struct pos_ns_trie_node *root,$/;"	f
pos_ns_search_container	./pos_namespace.c	/^struct pos_ns_record *pos_ns_search_container(struct pos_ns_container *container,$/;"	f
pos_ns_trend_burst	./pos_namespace.c	/^int pos_ns_trend_burst(struct pos_ns_trie_node *trie_node, int index,$/;"	f
pos_pages_to_level	./pos.c	/^int pos_pages_to_level(unsigned long nr_pages)$/;"	f
pos_pval_desc_link_rb	./pos.c	/^void pos_pval_desc_link_rb(struct pos_pval_device *pval_dev, struct pos_pval_descriptor *pval_desc,$/;"	f
pos_pval_table_index	./pos.c	/^int pos_pval_table_index(dev_t device)$/;"	f
pos_ratio_polynom	./page-writeback.c	/^static long long pos_ratio_polynom(unsigned long setpoint,$/;"	f	file:
pos_reduce_map_array	./pos.c	/^void pos_reduce_map_array(struct pos_map_array *map_array,$/;"	f
pos_reduce_map_array_level	./pos.c	/^int pos_reduce_map_array_level(struct pos_vm_area *vma)$/;"	f
pos_remove_pval_desc	./pos.c	/^void pos_remove_pval_desc(struct pos_pval_device *pval_dev, struct pos_pval_descriptor *pval_desc)$/;"	f
pos_remove_vm_area	./pos.c	/^void pos_remove_vm_area(struct pos_superblock *sb, struct pos_vm_area *vma,$/;"	f
pos_sb	./pos.c	/^struct pos_superblock* pos_sb;$/;"	v	typeref:struct:pos_superblock
pos_task_pid_struct_cachep	./pos.c	/^struct kmem_cache *pos_task_pid_struct_cachep;$/;"	v	typeref:struct:kmem_cache
pos_unmap_area	./pos.c	/^void pos_unmap_area(struct pos_superblock *sb, unsigned long addr)$/;"	f
pos_unmap_vma	./pos.c	/^void pos_unmap_vma(struct mm_struct *mm, struct pos_vm_area *pos_vma)$/;"	f
pos_vfree	./pos.c	/^void pos_vfree(void *addr)$/;"	f
pos_vma_link_list	./pos.c	/^void pos_vma_link_list(struct pos_superblock *sb, struct pos_vm_area *vma,$/;"	f
pos_vma_link_list2	./pos.c	/^void pos_vma_link_list2(struct pos_descriptor *desc, struct pos_vm_area *vma)$/;"	f
pos_vma_link_rb	./pos.c	/^void pos_vma_link_rb(struct pos_superblock *sb, struct pos_vm_area *vma,$/;"	f
pos_vmalloc	./pos.c	/^void *pos_vmalloc(unsigned long size)$/;"	f
pr_fmt	./kmemleak.c	64;"	d	file:
pr_fmt	./zbud.c	44;"	d	file:
pr_fmt	./zswap.c	23;"	d	file:
precharge	./memcontrol.c	/^	unsigned long precharge;$/;"	m	struct:move_charge_struct	file:
preferred_node_policy	./mempolicy.c	/^static struct mempolicy preferred_node_policy[MAX_NUMNODES];$/;"	v	typeref:struct:mempolicy	file:
prefetch_freepointer	./slub.c	/^static void prefetch_freepointer(const struct kmem_cache *s, void *object)$/;"	f	file:
prefetch_prev_lru_page	./vmscan.c	102;"	d	file:
prefetch_prev_lru_page	./vmscan.c	112;"	d	file:
prefetchw_prev_lru_page	./vmscan.c	116;"	d	file:
prefetchw_prev_lru_page	./vmscan.c	126;"	d	file:
prep_compound_gigantic_page	./hugetlb.c	/^static void __init prep_compound_gigantic_page(struct page *page,$/;"	f	file:
prep_compound_huge_page	./hugetlb.c	/^static void __init prep_compound_huge_page(struct page *page, int order)$/;"	f	file:
prep_compound_page	./page_alloc.c	/^void prep_compound_page(struct page *page, unsigned long order)$/;"	f
prep_new_huge_page	./hugetlb.c	/^static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)$/;"	f	file:
prep_new_page	./page_alloc.c	/^static int prep_new_page(struct page *page, int order, gfp_t gfp_flags)$/;"	f	file:
prep_zero_page	./page_alloc.c	/^static inline void prep_zero_page(struct page *page, int order, gfp_t gfp_flags)$/;"	f	file:
prepare_kswapd_sleep	./vmscan.c	/^static bool prepare_kswapd_sleep(pg_data_t *pgdat, int order, long remaining,$/;"	f	file:
primary	./memcontrol.c	/^	struct mem_cgroup_threshold_ary *primary;$/;"	m	struct:mem_cgroup_thresholds	typeref:struct:mem_cgroup_thresholds::mem_cgroup_threshold_ary	file:
print_bad_pte	./memory.c	/^static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,$/;"	f	file:
print_log_trace	./kmemleak.c	/^static void __init print_log_trace(struct early_log *log)$/;"	f	file:
print_objinfo	./slab.c	/^static void print_objinfo(struct kmem_cache *cachep, void *objp, int lines)$/;"	f	file:
print_page_info	./slub.c	/^static void print_page_info(struct page *page)$/;"	f	file:
print_section	./slub.c	/^static void print_section(char *text, u8 *addr, unsigned int length)$/;"	f	file:
print_slabinfo_header	./slab_common.c	/^void print_slabinfo_header(struct seq_file *m)$/;"	f
print_track	./slub.c	/^static void print_track(const char *s, struct track *t)$/;"	f	file:
print_tracking	./slub.c	/^static void print_tracking(struct kmem_cache *s, void *object)$/;"	f	file:
print_trailer	./slub.c	/^static void print_trailer(struct kmem_cache *s, struct page *page, u8 *p)$/;"	f	file:
print_unreferenced	./kmemleak.c	/^static void print_unreferenced(struct seq_file *seq,$/;"	f	file:
print_vma_addr	./memory.c	/^void print_vma_addr(char *prefix, unsigned long ip)$/;"	f
priority	./vmscan.c	/^	int priority;$/;"	m	struct:scan_control	file:
probe_kernel_read	./maccess.c	/^EXPORT_SYMBOL_GPL(probe_kernel_read);$/;"	v
probe_kernel_write	./maccess.c	/^EXPORT_SYMBOL_GPL(probe_kernel_write);$/;"	v
proc_poll_event	./swapfile.c	/^static atomic_t proc_poll_event = ATOMIC_INIT(0);$/;"	v	file:
proc_slabinfo_operations	./slab_common.c	/^static const struct file_operations proc_slabinfo_operations = {$/;"	v	typeref:struct:file_operations	file:
proc_slabstats_operations	./slab.c	/^static const struct file_operations proc_slabstats_operations = {$/;"	v	typeref:struct:file_operations	file:
proc_swaps_operations	./swapfile.c	/^static const struct file_operations proc_swaps_operations = {$/;"	v	typeref:struct:file_operations	file:
proc_vmalloc_init	./vmalloc.c	/^module_init(proc_vmalloc_init);$/;"	v
proc_vmalloc_init	./vmalloc.c	/^static int __init proc_vmalloc_init(void)$/;"	f	file:
proc_vmalloc_operations	./vmalloc.c	/^static const struct file_operations proc_vmalloc_operations = {$/;"	v	typeref:struct:file_operations	file:
proc_vmstat_file_operations	./vmstat.c	/^static const struct file_operations proc_vmstat_file_operations = {$/;"	v	typeref:struct:file_operations	file:
proc_zoneinfo_file_operations	./vmstat.c	/^static const struct file_operations proc_zoneinfo_file_operations = {$/;"	v	typeref:struct:file_operations	file:
process_slab	./slub.c	/^static void process_slab(struct loc_track *t, struct kmem_cache *s,$/;"	f	file:
process_vm_rw	./process_vm_access.c	/^static ssize_t process_vm_rw(pid_t pid,$/;"	f	file:
process_vm_rw_core	./process_vm_access.c	/^static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,$/;"	f	file:
process_vm_rw_pages	./process_vm_access.c	/^static int process_vm_rw_pages(struct page **pages,$/;"	f	file:
process_vm_rw_single_vec	./process_vm_access.c	/^static int process_vm_rw_single_vec(unsigned long addr,$/;"	f	file:
procswaps_init	./swapfile.c	/^__initcall(procswaps_init);$/;"	v
procswaps_init	./swapfile.c	/^static int __init procswaps_init(void)$/;"	f	file:
prot	./mmap.c	/^	unsigned long prot;$/;"	m	struct:mmap_arg_struct	file:
prot	./nommu.c	/^	unsigned long prot;$/;"	m	struct:mmap_arg_struct	file:
protect_vma	./nommu.c	/^static void protect_vma(struct vm_area_struct *vma, unsigned long flags)$/;"	f	file:
protection_map	./mmap.c	/^pgprot_t protection_map[16] = {$/;"	v
pt	./memcontrol.c	/^	poll_table pt;$/;"	m	struct:mem_cgroup_event	file:
pte_unmap_same	./memory.c	/^static inline int pte_unmap_same(struct mm_struct *mm, pmd_t *pmd,$/;"	f	file:
ptep_clear_flush	./pgtable-generic.c	/^pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,$/;"	f
ptep_clear_flush_young	./pgtable-generic.c	/^int ptep_clear_flush_young(struct vm_area_struct *vma,$/;"	f
ptep_set_access_flags	./pgtable-generic.c	/^int ptep_set_access_flags(struct vm_area_struct *vma,$/;"	f
ptlock_alloc	./memory.c	/^bool ptlock_alloc(struct page *page)$/;"	f
ptlock_cache_init	./memory.c	/^void __init ptlock_cache_init(void)$/;"	f
ptlock_free	./memory.c	/^void ptlock_free(struct page *page)$/;"	f
ptr	./kmemleak.c	/^	const void *ptr;		\/* allocated\/freed memory block *\/$/;"	m	struct:early_log	file:
pud_clear_bad	./pgtable-generic.c	/^void pud_clear_bad(pud_t *pud)$/;"	f
purge	./vmalloc.c	/^	struct list_head purge;$/;"	m	struct:vmap_block	typeref:struct:vmap_block::list_head	file:
purge_fragmented_blocks	./vmalloc.c	/^static void purge_fragmented_blocks(int cpu)$/;"	f	file:
purge_fragmented_blocks_allcpus	./vmalloc.c	/^static void purge_fragmented_blocks_allcpus(void)$/;"	f	file:
purge_vmap_area_lazy	./vmalloc.c	/^static void purge_vmap_area_lazy(void)$/;"	f	file:
put_compound_page	./swap.c	/^static void put_compound_page(struct page *page)$/;"	f	file:
put_cpu_partial	./slub.c	/^static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)$/;"	f	file:
put_huge_zero_page	./huge_memory.c	/^static void put_huge_zero_page(void)$/;"	f	file:
put_nommu_region	./nommu.c	/^static void put_nommu_region(struct vm_region *region)$/;"	f	file:
put_object	./kmemleak.c	/^static void put_object(struct kmemleak_object *object)$/;"	f	file:
put_page	./swap.c	/^EXPORT_SYMBOL(put_page);$/;"	v
put_page	./swap.c	/^void put_page(struct page *page)$/;"	f
put_page_bootmem	./memory_hotplug.c	/^void put_page_bootmem(struct page *page)$/;"	f
put_pages_list	./swap.c	/^EXPORT_SYMBOL(put_pages_list);$/;"	v
put_pages_list	./swap.c	/^void put_pages_list(struct list_head *pages)$/;"	f
putback_active_hugepage	./hugetlb.c	/^void putback_active_hugepage(struct page *page)$/;"	f
putback_inactive_pages	./vmscan.c	/^putback_inactive_pages(struct lruvec *lruvec, struct list_head *page_list)$/;"	f	file:
putback_lru_page	./vmscan.c	/^void putback_lru_page(struct page *page)$/;"	f
putback_movable_pages	./migrate.c	/^void putback_movable_pages(struct list_head *l)$/;"	f
pvm_determine_end	./vmalloc.c	/^static unsigned long pvm_determine_end(struct vmap_area **pnext,$/;"	f	file:
pvm_find_next_prev	./vmalloc.c	/^static bool pvm_find_next_prev(unsigned long end,$/;"	f	file:
queue_pages_hugetlb_pmd_range	./mempolicy.c	/^static void queue_pages_hugetlb_pmd_range(struct vm_area_struct *vma,$/;"	f	file:
queue_pages_pgd_range	./mempolicy.c	/^static inline int queue_pages_pgd_range(struct vm_area_struct *vma,$/;"	f	file:
queue_pages_pmd_range	./mempolicy.c	/^static inline int queue_pages_pmd_range(struct vm_area_struct *vma, pud_t *pud,$/;"	f	file:
queue_pages_pte_range	./mempolicy.c	/^static int queue_pages_pte_range(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f	file:
queue_pages_pud_range	./mempolicy.c	/^static inline int queue_pages_pud_range(struct vm_area_struct *vma, pgd_t *pgd,$/;"	f	file:
queue_pages_range	./mempolicy.c	/^queue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,$/;"	f	file:
quicklist_total_size	./quicklist.c	/^unsigned long quicklist_total_size(void)$/;"	f
quicklist_trim	./quicklist.c	/^void quicklist_trim(int nr, void (*dtor)(void *),$/;"	f
ra_submit	./internal.h	/^static inline unsigned long ra_submit(struct file_ra_state *ra,$/;"	f
ratelimit_handler	./page-writeback.c	/^ratelimit_handler(struct notifier_block *self, unsigned long action,$/;"	f	file:
ratelimit_nb	./page-writeback.c	/^static struct notifier_block ratelimit_nb = {$/;"	v	typeref:struct:notifier_block	file:
ratelimit_pages	./page-writeback.c	/^static long ratelimit_pages = 32;$/;"	v	file:
rb_node	./kmemleak.c	/^	struct rb_node rb_node;$/;"	m	struct:kmemleak_object	typeref:struct:kmemleak_object::rb_node	file:
rb_root	./memcontrol.c	/^	struct rb_root rb_root;$/;"	m	struct:mem_cgroup_tree_per_zone	typeref:struct:mem_cgroup_tree_per_zone::rb_root	file:
rb_tree_per_node	./memcontrol.c	/^	struct mem_cgroup_tree_per_node *rb_tree_per_node[MAX_NUMNODES];$/;"	m	struct:mem_cgroup_tree	typeref:struct:mem_cgroup_tree::mem_cgroup_tree_per_node	file:
rb_tree_per_zone	./memcontrol.c	/^	struct mem_cgroup_tree_per_zone rb_tree_per_zone[MAX_NR_ZONES];$/;"	m	struct:mem_cgroup_tree_per_node	typeref:struct:mem_cgroup_tree_per_node::mem_cgroup_tree_per_zone	file:
rbnode	./zswap.c	/^	struct rb_node rbnode;$/;"	m	struct:zswap_entry	typeref:struct:zswap_entry::rb_node	file:
rbroot	./zswap.c	/^	struct rb_root rbroot;$/;"	m	struct:zswap_tree	typeref:struct:zswap_tree::rb_root	file:
rcu	./kmemleak.c	/^	struct rcu_head rcu;		\/* object_list lockless traversal *\/$/;"	m	struct:kmemleak_object	typeref:struct:kmemleak_object::rcu_head	file:
rcu_free_slab	./slub.c	/^static void rcu_free_slab(struct rcu_head *h)$/;"	f	file:
rcu_head	./vmalloc.c	/^	struct rcu_head rcu_head;$/;"	m	struct:vmap_block	typeref:struct:vmap_block::rcu_head	file:
read_ahead_kb_store	./backing-dev.c	/^static ssize_t read_ahead_kb_store(struct device *dev,$/;"	f	file:
read_cache_page	./filemap.c	/^EXPORT_SYMBOL(read_cache_page);$/;"	v
read_cache_page	./filemap.c	/^struct page *read_cache_page(struct address_space *mapping,$/;"	f
read_cache_page_gfp	./filemap.c	/^EXPORT_SYMBOL(read_cache_page_gfp);$/;"	v
read_cache_page_gfp	./filemap.c	/^struct page *read_cache_page_gfp(struct address_space *mapping,$/;"	f
read_cache_pages	./readahead.c	/^EXPORT_SYMBOL(read_cache_pages);$/;"	v
read_cache_pages	./readahead.c	/^int read_cache_pages(struct address_space *mapping, struct list_head *pages,$/;"	f
read_cache_pages_invalidate_page	./readahead.c	/^static void read_cache_pages_invalidate_page(struct address_space *mapping,$/;"	f	file:
read_cache_pages_invalidate_pages	./readahead.c	/^static void read_cache_pages_invalidate_pages(struct address_space *mapping,$/;"	f	file:
read_pages	./readahead.c	/^static int read_pages(struct address_space *mapping, struct file *filp,$/;"	f	file:
read_scan_unevictable_node	./vmscan.c	/^static ssize_t read_scan_unevictable_node(struct device *dev,$/;"	f	file:
read_swap_cache_async	./swap_state.c	/^struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,$/;"	f
read_swap_header	./swapfile.c	/^static unsigned long read_swap_header(struct swap_info_struct *p,$/;"	f	file:
reap_alien	./slab.c	/^static void reap_alien(struct kmem_cache *cachep, struct kmem_cache_node *n)$/;"	f	file:
reap_alien	./slab.c	910;"	d	file:
rebind	./mempolicy.c	/^	void (*rebind)(struct mempolicy *pol, const nodemask_t *nodes,$/;"	m	struct:mempolicy_operations	file:
recheck_pfmemalloc_active	./slab.c	/^static void recheck_pfmemalloc_active(struct kmem_cache *cachep,$/;"	f	file:
reclaim_account	./slub.c	/^SLAB_ATTR(reclaim_account);$/;"	v
reclaim_account_show	./slub.c	/^static ssize_t reclaim_account_show(struct kmem_cache *s, char *buf)$/;"	f	file:
reclaim_account_store	./slub.c	/^static ssize_t reclaim_account_store(struct kmem_cache *s,$/;"	f	file:
reclaim_clean_pages_from_list	./vmscan.c	/^unsigned long reclaim_clean_pages_from_list(struct zone *zone,$/;"	f
reclaim_iter	./memcontrol.c	/^	struct mem_cgroup_reclaim_iter reclaim_iter[DEF_PRIORITY + 1];$/;"	m	struct:mem_cgroup_per_zone	typeref:struct:mem_cgroup_per_zone::mem_cgroup_reclaim_iter	file:
red_zone	./slub.c	/^SLAB_ATTR(red_zone);$/;"	v
red_zone_show	./slub.c	/^static ssize_t red_zone_show(struct kmem_cache *s, char *buf)$/;"	f	file:
red_zone_store	./slub.c	/^static ssize_t red_zone_store(struct kmem_cache *s,$/;"	f	file:
redirty_page_for_writepage	./page-writeback.c	/^EXPORT_SYMBOL(redirty_page_for_writepage);$/;"	v
redirty_page_for_writepage	./page-writeback.c	/^int redirty_page_for_writepage(struct writeback_control *wbc, struct page *page)$/;"	f
refcount	./zswap.c	/^	int refcount;$/;"	m	struct:zswap_entry	file:
referenced	./rmap.c	/^	int referenced;$/;"	m	struct:page_referenced_arg	file:
refill_stock	./memcontrol.c	/^static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)$/;"	f	file:
refresh_cpu_vm_stats	./vmstat.c	/^static void refresh_cpu_vm_stats(void)$/;"	f	file:
refresh_zone_stat_thresholds	./vmstat.c	/^void refresh_zone_stat_thresholds(void)$/;"	f
region_add	./hugetlb.c	/^static long region_add(struct resv_map *resv, long f, long t)$/;"	f	file:
region_chg	./hugetlb.c	/^static long region_chg(struct resv_map *resv, long f, long t)$/;"	f	file:
region_count	./hugetlb.c	/^static long region_count(struct resv_map *resv, long f, long t)$/;"	f	file:
region_truncate	./hugetlb.c	/^static long region_truncate(struct resv_map *resv, long end)$/;"	f	file:
register_event	./memcontrol.c	/^	int (*register_event)(struct mem_cgroup *memcg,$/;"	m	struct:mem_cgroup_event	file:
register_memory_resource	./memory_hotplug.c	/^static struct resource *register_memory_resource(u64 start, u64 size)$/;"	f	file:
register_oom_notifier	./oom_kill.c	/^EXPORT_SYMBOL_GPL(register_oom_notifier);$/;"	v
register_oom_notifier	./oom_kill.c	/^int register_oom_notifier(struct notifier_block *nb)$/;"	f
register_page_bootmem_info_node	./memory_hotplug.c	/^void register_page_bootmem_info_node(struct pglist_data *pgdat)$/;"	f
register_page_bootmem_info_section	./memory_hotplug.c	/^static void register_page_bootmem_info_section(unsigned long start_pfn)$/;"	f	file:
register_shrinker	./vmscan.c	/^EXPORT_SYMBOL(register_shrinker);$/;"	v
register_shrinker	./vmscan.c	/^int register_shrinker(struct shrinker *shrinker)$/;"	f
reinsert_swap_info	./swapfile.c	/^static void reinsert_swap_info(struct swap_info_struct *p)$/;"	f	file:
release_freepages	./compaction.c	/^static unsigned long release_freepages(struct list_head *freelist)$/;"	f	file:
release_memory_resource	./memory_hotplug.c	/^static void release_memory_resource(struct resource *res)$/;"	f	file:
release_pages	./swap.c	/^EXPORT_SYMBOL(release_pages);$/;"	v
release_pages	./swap.c	/^void release_pages(struct page **pages, int nr, int cold)$/;"	f
release_pte_page	./huge_memory.c	/^static void release_pte_page(struct page *page)$/;"	f	file:
release_pte_pages	./huge_memory.c	/^static void release_pte_pages(pte_t *pte, pte_t *_pte)$/;"	f	file:
remap_pfn_range	./memory.c	/^EXPORT_SYMBOL(remap_pfn_range);$/;"	v
remap_pfn_range	./memory.c	/^int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,$/;"	f
remap_pfn_range	./nommu.c	/^EXPORT_SYMBOL(remap_pfn_range);$/;"	v
remap_pfn_range	./nommu.c	/^int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,$/;"	f
remap_pmd_range	./memory.c	/^static inline int remap_pmd_range(struct mm_struct *mm, pud_t *pud,$/;"	f	file:
remap_pte_range	./memory.c	/^static int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,$/;"	f	file:
remap_pud_range	./memory.c	/^static inline int remap_pud_range(struct mm_struct *mm, pgd_t *pgd,$/;"	f	file:
remap_vmalloc_range	./nommu.c	/^EXPORT_SYMBOL(remap_vmalloc_range);$/;"	v
remap_vmalloc_range	./nommu.c	/^int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,$/;"	f
remap_vmalloc_range	./vmalloc.c	/^EXPORT_SYMBOL(remap_vmalloc_range);$/;"	v
remap_vmalloc_range	./vmalloc.c	/^int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,$/;"	f
remap_vmalloc_range_partial	./vmalloc.c	/^EXPORT_SYMBOL(remap_vmalloc_range_partial);$/;"	v
remap_vmalloc_range_partial	./vmalloc.c	/^int remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr,$/;"	f
remote_node_defrag_ratio	./slub.c	/^SLAB_ATTR(remote_node_defrag_ratio);$/;"	v
remote_node_defrag_ratio_show	./slub.c	/^static ssize_t remote_node_defrag_ratio_show(struct kmem_cache *s, char *buf)$/;"	f	file:
remote_node_defrag_ratio_store	./slub.c	/^static ssize_t remote_node_defrag_ratio_store(struct kmem_cache *s,$/;"	f	file:
remove	./memcontrol.c	/^	struct work_struct remove;$/;"	m	struct:mem_cgroup_event	typeref:struct:mem_cgroup_event::work_struct	file:
remove_all_stable_nodes	./ksm.c	/^static int remove_all_stable_nodes(void)$/;"	f	file:
remove_element	./mempool.c	/^static void *remove_element(mempool_t *pool)$/;"	f	file:
remove_full	./slub.c	/^static inline void remove_full(struct kmem_cache *s, struct kmem_cache_node *n,$/;"	f	file:
remove_full	./slub.c	/^static void remove_full(struct kmem_cache *s, struct kmem_cache_node *n, struct page *page)$/;"	f	file:
remove_linear_migration_ptes_from_nonlinear	./migrate.c	/^static int remove_linear_migration_ptes_from_nonlinear(struct page *page,$/;"	f	file:
remove_mapping	./vmscan.c	/^int remove_mapping(struct address_space *mapping, struct page *page)$/;"	f
remove_memory	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(remove_memory);$/;"	v
remove_memory	./memory_hotplug.c	/^void __ref remove_memory(int nid, u64 start, u64 size)$/;"	f
remove_migration_pte	./migrate.c	/^static int remove_migration_pte(struct page *new, struct vm_area_struct *vma,$/;"	f	file:
remove_migration_ptes	./migrate.c	/^static void remove_migration_ptes(struct page *old, struct page *new)$/;"	f	file:
remove_node_from_stable_tree	./ksm.c	/^static void remove_node_from_stable_tree(struct stable_node *stable_node)$/;"	f	file:
remove_partial	./slub.c	/^static inline void remove_partial(struct kmem_cache_node *n,$/;"	f	file:
remove_rmap_item_from_tree	./ksm.c	/^static void remove_rmap_item_from_tree(struct rmap_item *rmap_item)$/;"	f	file:
remove_stable_node	./ksm.c	/^static int remove_stable_node(struct stable_node *stable_node)$/;"	f	file:
remove_trailing_rmap_items	./ksm.c	/^static void remove_trailing_rmap_items(struct mm_slot *mm_slot,$/;"	f	file:
remove_vm_area	./vmalloc.c	/^struct vm_struct *remove_vm_area(const void *addr)$/;"	f
remove_vma	./mmap.c	/^static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)$/;"	f	file:
remove_vma_list	./mmap.c	/^static void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)$/;"	f	file:
remove_zspage	./zsmalloc.c	/^static void remove_zspage(struct page *page, struct size_class *class,$/;"	f	file:
replace_page	./ksm.c	/^static int replace_page(struct vm_area_struct *vma, struct page *page,$/;"	f	file:
replace_page_cache_page	./filemap.c	/^EXPORT_SYMBOL_GPL(replace_page_cache_page);$/;"	v
replace_page_cache_page	./filemap.c	/^int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)$/;"	f
report_hugepages	./hugetlb.c	/^static void __init report_hugepages(void)$/;"	f	file:
required_kernelcore	./page_alloc.c	/^static unsigned long __initdata required_kernelcore;$/;"	v	file:
required_movablecore	./page_alloc.c	/^static unsigned long __initdata required_movablecore;$/;"	v	file:
res	./memcontrol.c	/^	struct res_counter res;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::res_counter	file:
res	./memory-failure.c	/^	unsigned long res;$/;"	m	struct:page_state	file:
res_type	./memcontrol.c	/^enum res_type {$/;"	g	file:
reserve_bootmem	./bootmem.c	/^int __init reserve_bootmem(unsigned long addr, unsigned long size,$/;"	f
reserve_bootmem_node	./bootmem.c	/^int __init reserve_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,$/;"	f
reserve_mem_nb	./mmap.c	/^static struct notifier_block reserve_mem_nb = {$/;"	v	typeref:struct:notifier_block	file:
reserve_mem_notifier	./mmap.c	/^static int reserve_mem_notifier(struct notifier_block *nb,$/;"	f	file:
reserved	./memory-failure.c	754;"	d	file:
reserved	./memory-failure.c	811;"	d	file:
reserved	./slub.c	/^SLAB_ATTR_RO(reserved);$/;"	v
reserved_show	./slub.c	/^static ssize_t reserved_show(struct kmem_cache *s, char *buf)$/;"	f	file:
reset_all_zones_managed_pages	./bootmem.c	/^void __init reset_all_zones_managed_pages(void)$/;"	f
reset_all_zones_managed_pages	./nobootmem.c	/^void __init reset_all_zones_managed_pages(void)$/;"	f
reset_alloc_batches	./page_alloc.c	/^static void reset_alloc_batches(struct zonelist *zonelist,$/;"	f	file:
reset_isolation_suitable	./compaction.c	/^void reset_isolation_suitable(pg_data_t *pgdat)$/;"	f
reset_node_managed_pages	./bootmem.c	/^static inline void __init reset_node_managed_pages(pg_data_t *pgdat)$/;"	f	file:
reset_node_managed_pages	./nobootmem.c	/^static inline void __init reset_node_managed_pages(pg_data_t *pgdat)$/;"	f	file:
reset_page	./zsmalloc.c	/^static void reset_page(struct page *page)$/;"	f	file:
reset_vma_resv_huge_pages	./hugetlb.c	/^void reset_vma_resv_huge_pages(struct vm_area_struct *vma)$/;"	f
resiliency_test	./slub.c	/^static void resiliency_test(void) {};$/;"	f	file:
resiliency_test	./slub.c	/^static void resiliency_test(void)$/;"	f	file:
resize_zone	./memory_hotplug.c	/^static void resize_zone(struct zone *zone, unsigned long start_pfn,$/;"	f	file:
restore_bytes	./slub.c	/^static void restore_bytes(struct kmem_cache *s, char *message, u8 data,$/;"	f	file:
restore_online_page_callback	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(restore_online_page_callback);$/;"	v
restore_online_page_callback	./memory_hotplug.c	/^int restore_online_page_callback(online_page_callback_t callback)$/;"	f
resv_hugepages	./hugetlb.c	/^HSTATE_ATTR_RO(resv_hugepages);$/;"	v
resv_hugepages_show	./hugetlb.c	/^static ssize_t resv_hugepages_show(struct kobject *kobj,$/;"	f	file:
resv_map_alloc	./hugetlb.c	/^struct resv_map *resv_map_alloc(void)$/;"	f
resv_map_release	./hugetlb.c	/^void resv_map_release(struct kref *ref)$/;"	f
return_unused_surplus_pages	./hugetlb.c	/^static void return_unused_surplus_pages(struct hstate *h,$/;"	f	file:
reusable_anon_vma	./mmap.c	/^static struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)$/;"	f	file:
reuse_swap_page	./swapfile.c	/^int reuse_swap_page(struct page *page)$/;"	f
rmap_item	./ksm.c	/^struct rmap_item {$/;"	s	file:
rmap_item_cache	./ksm.c	/^static struct kmem_cache *rmap_item_cache;$/;"	v	typeref:struct:kmem_cache	file:
rmap_list	./ksm.c	/^	struct rmap_item **rmap_list;$/;"	m	struct:ksm_scan	typeref:struct:ksm_scan::rmap_item	file:
rmap_list	./ksm.c	/^	struct rmap_item *rmap_list;$/;"	m	struct:mm_slot	typeref:struct:mm_slot::rmap_item	file:
rmap_list	./ksm.c	/^	struct rmap_item *rmap_list;$/;"	m	struct:rmap_item	typeref:struct:rmap_item::rmap_item	file:
rmap_walk	./rmap.c	/^int rmap_walk(struct page *page, struct rmap_walk_control *rwc)$/;"	f
rmap_walk_anon	./rmap.c	/^static int rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc)$/;"	f	file:
rmap_walk_anon_lock	./rmap.c	/^static struct anon_vma *rmap_walk_anon_lock(struct page *page,$/;"	f	file:
rmap_walk_file	./rmap.c	/^static int rmap_walk_file(struct page *page, struct rmap_walk_control *rwc)$/;"	f	file:
rmap_walk_ksm	./ksm.c	/^int rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)$/;"	f
rmqueue_bulk	./page_alloc.c	/^static int rmqueue_bulk(struct zone *zone, unsigned int order,$/;"	f	file:
rmv_page_order	./page_alloc.c	/^static inline void rmv_page_order(struct page *page)$/;"	f	file:
rollback_node_hotadd	./memory_hotplug.c	/^static void rollback_node_hotadd(int nid, pg_data_t *pgdat)$/;"	f	file:
root_stable_tree	./ksm.c	/^static struct rb_root *root_stable_tree = one_stable_tree;$/;"	v	typeref:struct:rb_root	file:
root_unstable_tree	./ksm.c	/^static struct rb_root *root_unstable_tree = one_unstable_tree;$/;"	v	typeref:struct:rb_root	file:
rotate_reclaimable_page	./swap.c	/^void rotate_reclaimable_page(struct page *page)$/;"	f
round_hint_to_min	./mmap.c	/^static inline unsigned long round_hint_to_min(unsigned long hint)$/;"	f	file:
run	./ksm.c	/^KSM_ATTR(run);$/;"	v
run_show	./ksm.c	/^static ssize_t run_show(struct kobject *kobj, struct kobj_attribute *attr,$/;"	f	file:
run_store	./ksm.c	/^static ssize_t run_store(struct kobject *kobj, struct kobj_attribute *attr,$/;"	f	file:
s	./slub.c	/^	struct kmem_cache *s;$/;"	m	struct:saved_alias	typeref:struct:saved_alias::kmem_cache	file:
s_next	./vmalloc.c	/^static void *s_next(struct seq_file *m, void *p, loff_t *pos)$/;"	f	file:
s_show	./slab_common.c	/^static int s_show(struct seq_file *m, void *p)$/;"	f	file:
s_show	./vmalloc.c	/^static int s_show(struct seq_file *m, void *p)$/;"	f	file:
s_start	./slab_common.c	/^static void *s_start(struct seq_file *m, loff_t *pos)$/;"	f	file:
sanity_checks	./slub.c	/^SLAB_ATTR(sanity_checks);$/;"	v
sanity_checks_show	./slub.c	/^static ssize_t sanity_checks_show(struct kmem_cache *s, char *buf)$/;"	f	file:
sanity_checks_store	./slub.c	/^static ssize_t sanity_checks_store(struct kmem_cache *s,$/;"	f	file:
saved_alias	./slub.c	/^struct saved_alias {$/;"	s	file:
saved_gfp_mask	./page_alloc.c	/^static gfp_t saved_gfp_mask;$/;"	v	file:
sc	./memory-failure.c	744;"	d	file:
sc	./memory-failure.c	801;"	d	file:
scan_area_cache	./kmemleak.c	/^static struct kmem_cache *scan_area_cache;$/;"	v	typeref:struct:kmem_cache	file:
scan_balance	./vmscan.c	/^enum scan_balance {$/;"	g	file:
scan_block	./kmemleak.c	/^static void scan_block(void *_start, void *_end,$/;"	f	file:
scan_control	./vmscan.c	/^struct scan_control {$/;"	s	file:
scan_get_next_rmap_item	./ksm.c	/^static struct rmap_item *scan_get_next_rmap_item(struct page **page)$/;"	f	file:
scan_gray_list	./kmemleak.c	/^static void scan_gray_list(void)$/;"	f	file:
scan_movable_pages	./memory_hotplug.c	/^static unsigned long scan_movable_pages(unsigned long start, unsigned long end)$/;"	f	file:
scan_nodes	./memcontrol.c	/^	nodemask_t	scan_nodes;$/;"	m	struct:mem_cgroup	file:
scan_object	./kmemleak.c	/^static void scan_object(struct kmemleak_object *object)$/;"	f	file:
scan_shadow_nodes	./workingset.c	/^static unsigned long scan_shadow_nodes(struct shrinker *shrinker,$/;"	f	file:
scan_should_stop	./kmemleak.c	/^static int scan_should_stop(void)$/;"	f	file:
scan_sleep_millisecs_attr	./huge_memory.c	/^static struct kobj_attribute scan_sleep_millisecs_attr =$/;"	v	typeref:struct:kobj_attribute	file:
scan_sleep_millisecs_show	./huge_memory.c	/^static ssize_t scan_sleep_millisecs_show(struct kobject *kobj,$/;"	f	file:
scan_sleep_millisecs_store	./huge_memory.c	/^static ssize_t scan_sleep_millisecs_store(struct kobject *kobj,$/;"	f	file:
scan_swap_map	./swapfile.c	/^static unsigned long scan_swap_map(struct swap_info_struct *si,$/;"	f	file:
scan_swap_map_ssd_cluster_conflict	./swapfile.c	/^scan_swap_map_ssd_cluster_conflict(struct swap_info_struct *si,$/;"	f	file:
scan_swap_map_try_ssd_cluster	./swapfile.c	/^static void scan_swap_map_try_ssd_cluster(struct swap_info_struct *si,$/;"	f	file:
scan_thread	./kmemleak.c	/^static struct task_struct *scan_thread;$/;"	v	typeref:struct:task_struct	file:
scan_unevictable_handler	./vmscan.c	/^int scan_unevictable_handler(struct ctl_table *table, int write,$/;"	f
scan_unevictable_pages	./vmscan.c	/^unsigned long scan_unevictable_pages;$/;"	v
scan_unevictable_register_node	./vmscan.c	/^int scan_unevictable_register_node(struct node *node)$/;"	f
scan_unevictable_unregister_node	./vmscan.c	/^void scan_unevictable_unregister_node(struct node *node)$/;"	f
seg_inform	./pos.c	/^struct seg_inform {$/;"	s	file:
select_bad_process	./oom_kill.c	/^static struct task_struct *select_bad_process(unsigned int *ppoints,$/;"	f	file:
seqnr	./ksm.c	/^	unsigned long seqnr;$/;"	m	struct:ksm_scan	file:
set_bdi_congested	./backing-dev.c	/^EXPORT_SYMBOL(set_bdi_congested);$/;"	v
set_bdi_congested	./backing-dev.c	/^void set_bdi_congested(struct backing_dev_info *bdi, int sync)$/;"	f
set_dma_reserve	./page_alloc.c	/^void __init set_dma_reserve(unsigned long new_dma_reserve)$/;"	f
set_free_obj	./slab.c	/^static inline void set_free_obj(struct page *page,$/;"	f	file:
set_freepointer	./slub.c	/^static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)$/;"	f	file:
set_hashdist	./page_alloc.c	/^static int __init set_hashdist(char *str)$/;"	f	file:
set_highest_priority_index	./swapfile.c	/^static void set_highest_priority_index(int type)$/;"	f	file:
set_huge_ptep_writable	./hugetlb.c	/^static void set_huge_ptep_writable(struct vm_area_struct *vma,$/;"	f	file:
set_huge_zero_page	./huge_memory.c	/^static bool set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,$/;"	f	file:
set_iounmap_nonlazy	./vmalloc.c	/^void set_iounmap_nonlazy(void)$/;"	f
set_max_huge_pages	./hugetlb.c	/^static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,$/;"	f	file:
set_migratetype_isolate	./page_isolation.c	/^int set_migratetype_isolate(struct page *page, bool skip_hwpoisoned_pages)$/;"	f
set_min_partial	./slub.c	/^static void set_min_partial(struct kmem_cache *s, unsigned long min)$/;"	f	file:
set_mminit_loglevel	./mm_init.c	/^static __init int set_mminit_loglevel(char *str)$/;"	f	file:
set_obj_pfmemalloc	./slab.c	/^static inline void set_obj_pfmemalloc(void **objp)$/;"	f	file:
set_online_page_callback	./memory_hotplug.c	/^EXPORT_SYMBOL_GPL(set_online_page_callback);$/;"	v
set_online_page_callback	./memory_hotplug.c	/^int set_online_page_callback(online_page_callback_t callback)$/;"	f
set_page_address	./highmem.c	/^void set_page_address(struct page *page, void *virtual)$/;"	f
set_page_count	./internal.h	/^static inline void set_page_count(struct page *page, int v)$/;"	f
set_page_dirty	./page-writeback.c	/^EXPORT_SYMBOL(set_page_dirty);$/;"	v
set_page_dirty	./page-writeback.c	/^int set_page_dirty(struct page *page)$/;"	f
set_page_dirty_balance	./page-writeback.c	/^void set_page_dirty_balance(struct page *page)$/;"	f
set_page_dirty_lock	./page-writeback.c	/^EXPORT_SYMBOL(set_page_dirty_lock);$/;"	v
set_page_dirty_lock	./page-writeback.c	/^int set_page_dirty_lock(struct page *page)$/;"	f
set_page_guard_flag	./page_alloc.c	/^static inline void set_page_guard_flag(struct page *page) { }$/;"	f	file:
set_page_guard_flag	./page_alloc.c	/^static inline void set_page_guard_flag(struct page *page)$/;"	f	file:
set_page_hwpoison_huge_page	./memory-failure.c	/^static void set_page_hwpoison_huge_page(struct page *hpage)$/;"	f	file:
set_page_order	./page_alloc.c	/^static inline void set_page_order(struct page *page, int order)$/;"	f	file:
set_page_poison	./debug-pagealloc.c	/^static inline void set_page_poison(struct page *page)$/;"	f	file:
set_page_refcounted	./internal.h	/^static inline void set_page_refcounted(struct page *page)$/;"	f
set_page_slub_counters	./slub.c	/^static inline void set_page_slub_counters(struct page *page, unsigned long counters_new)$/;"	f	file:
set_pageblock_flags_group	./page_alloc.c	/^void set_pageblock_flags_group(struct page *page, unsigned long flags,$/;"	f
set_pageblock_migratetype	./page_alloc.c	/^void set_pageblock_migratetype(struct page *page, int migratetype)$/;"	f
set_pageblock_order	./page_alloc.c	/^void __paginginit set_pageblock_order(void)$/;"	f
set_pgdat_percpu_threshold	./vmstat.c	/^void set_pgdat_percpu_threshold(pg_data_t *pgdat,$/;"	f
set_recommended_min_free_kbytes	./huge_memory.c	/^late_initcall(set_recommended_min_free_kbytes);$/;"	v
set_recommended_min_free_kbytes	./huge_memory.c	/^static int set_recommended_min_free_kbytes(void)$/;"	f	file:
set_section_nid	./sparse.c	/^static inline void set_section_nid(unsigned long section_nr, int nid)$/;"	f	file:
set_section_nid	./sparse.c	/^static void set_section_nid(unsigned long section_nr, int nid)$/;"	f	file:
set_slob	./slob.c	/^static void set_slob(slob_t *s, slobidx_t size, slob_t *next)$/;"	f	file:
set_slob_page_free	./slob.c	/^static void set_slob_page_free(struct page *sp, struct list_head *list)$/;"	f	file:
set_track	./slub.c	/^static void set_track(struct kmem_cache *s, void *object,$/;"	f	file:
set_up_node	./slab.c	/^static void __init set_up_node(struct kmem_cache *cachep, int index)$/;"	f	file:
set_vma_private_data	./hugetlb.c	/^static void set_vma_private_data(struct vm_area_struct *vma,$/;"	f	file:
set_vma_resv_flags	./hugetlb.c	/^static void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)$/;"	f	file:
set_vma_resv_map	./hugetlb.c	/^static void set_vma_resv_map(struct vm_area_struct *vma, struct resv_map *map)$/;"	f	file:
set_zonelist_order	./page_alloc.c	/^static void set_zonelist_order(void)$/;"	f	file:
set_zspage_mapping	./zsmalloc.c	/^static void set_zspage_mapping(struct page *page, unsigned int class_idx,$/;"	f	file:
setup_cpu_cache	./slab.c	/^static int __init_refok setup_cpu_cache(struct kmem_cache *cachep, gfp_t gfp)$/;"	f	file:
setup_fail_page_alloc	./page_alloc.c	/^static int __init setup_fail_page_alloc(char *str)$/;"	f	file:
setup_failslab	./failslab.c	/^static int __init setup_failslab(char *str)$/;"	f	file:
setup_node_pointer	./slab.c	/^static void setup_node_pointer(struct kmem_cache *cachep)$/;"	f	file:
setup_nr_node_ids	./page_alloc.c	/^void __init setup_nr_node_ids(void)$/;"	f
setup_numa_zonelist_order	./page_alloc.c	/^static __init int setup_numa_zonelist_order(char *s)$/;"	f	file:
setup_numabalancing	./mempolicy.c	/^static int __init setup_numabalancing(char *str)$/;"	f	file:
setup_object	./slub.c	/^static void setup_object(struct kmem_cache *s, struct page *page,$/;"	f	file:
setup_object_debug	./slub.c	/^static inline void setup_object_debug(struct kmem_cache *s,$/;"	f	file:
setup_object_debug	./slub.c	/^static void setup_object_debug(struct kmem_cache *s, struct page *page,$/;"	f	file:
setup_pageset	./page_alloc.c	/^static void setup_pageset(struct per_cpu_pageset *p, unsigned long batch)$/;"	f	file:
setup_per_cpu_areas	./percpu.c	/^void __init setup_per_cpu_areas(void)$/;"	f
setup_per_cpu_pageset	./page_alloc.c	/^void __init setup_per_cpu_pageset(void)$/;"	f
setup_per_zone_inactive_ratio	./page_alloc.c	/^static void __meminit setup_per_zone_inactive_ratio(void)$/;"	f	file:
setup_per_zone_lowmem_reserve	./page_alloc.c	/^static void setup_per_zone_lowmem_reserve(void)$/;"	f	file:
setup_per_zone_wmarks	./page_alloc.c	/^void setup_per_zone_wmarks(void)$/;"	f
setup_slub_debug	./slub.c	/^static int __init setup_slub_debug(char *str)$/;"	f	file:
setup_slub_max_order	./slub.c	/^static int __init setup_slub_max_order(char *str)$/;"	f	file:
setup_slub_min_objects	./slub.c	/^static int __init setup_slub_min_objects(char *str)$/;"	f	file:
setup_slub_min_order	./slub.c	/^static int __init setup_slub_min_order(char *str)$/;"	f	file:
setup_slub_nomerge	./slub.c	/^static int __init setup_slub_nomerge(char *str)$/;"	f	file:
setup_swap_extents	./swapfile.c	/^static int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)$/;"	f	file:
setup_swap_map_and_extents	./swapfile.c	/^static int setup_swap_map_and_extents(struct swap_info_struct *p,$/;"	f	file:
setup_transparent_hugepage	./huge_memory.c	/^static int __init setup_transparent_hugepage(char *str)$/;"	f	file:
setup_usemap	./page_alloc.c	/^static inline void setup_usemap(struct pglist_data *pgdat, struct zone *zone,$/;"	f	file:
setup_usemap	./page_alloc.c	/^static void __init setup_usemap(struct pglist_data *pgdat,$/;"	f	file:
setup_vmalloc_vm	./vmalloc.c	/^static void setup_vmalloc_vm(struct vm_struct *vm, struct vmap_area *va,$/;"	f	file:
setup_vmstat	./vmstat.c	/^static int __init setup_vmstat(void)$/;"	f	file:
setup_zone_migrate_reserve	./page_alloc.c	/^static void setup_zone_migrate_reserve(struct zone *zone)$/;"	f	file:
setup_zone_pageset	./page_alloc.c	/^static void __meminit setup_zone_pageset(struct zone *zone)$/;"	f	file:
sgp_type	./shmem.c	/^enum sgp_type {$/;"	g	file:
shadow_lru_isolate	./workingset.c	/^static enum lru_status shadow_lru_isolate(struct list_head *item,$/;"	f	file:
shadow_nodes_key	./workingset.c	/^static struct lock_class_key shadow_nodes_key;$/;"	v	typeref:struct:lock_class_key	file:
shake_page	./memory-failure.c	/^EXPORT_SYMBOL_GPL(shake_page);$/;"	v
shake_page	./memory-failure.c	/^void shake_page(struct page *p, int access)$/;"	f
shared	./slab.h	/^	struct array_cache *shared;	\/* shared per node *\/$/;"	m	struct:kmem_cache_node	typeref:struct:kmem_cache_node::array_cache
shared	./slab.h	/^	unsigned int shared;$/;"	m	struct:slabinfo
shared_avail	./slab.h	/^	unsigned long shared_avail;$/;"	m	struct:slabinfo
shared_fs_poolid_map	./cleancache.c	/^static int shared_fs_poolid_map[MAX_INITIALIZABLE_FS];$/;"	v	file:
shared_policy_replace	./mempolicy.c	/^static int shared_policy_replace(struct shared_policy *sp, unsigned long start,$/;"	f	file:
shm_mnt	./shmem.c	/^static struct vfsmount *shm_mnt;$/;"	v	typeref:struct:vfsmount	file:
shmem_acct_block	./shmem.c	/^static inline int shmem_acct_block(unsigned long flags)$/;"	f	file:
shmem_acct_size	./shmem.c	/^static inline int shmem_acct_size(unsigned long flags, loff_t size)$/;"	f	file:
shmem_acct_size	./shmem.c	2817;"	d	file:
shmem_add_to_page_cache	./shmem.c	/^static int shmem_add_to_page_cache(struct page *page,$/;"	f	file:
shmem_alloc_inode	./shmem.c	/^static struct inode *shmem_alloc_inode(struct super_block *sb)$/;"	f	file:
shmem_alloc_page	./shmem.c	/^static inline struct page *shmem_alloc_page(gfp_t gfp,$/;"	f	file:
shmem_alloc_page	./shmem.c	/^static struct page *shmem_alloc_page(gfp_t gfp,$/;"	f	file:
shmem_aops	./shmem.c	/^static const struct address_space_operations shmem_aops = {$/;"	v	typeref:struct:address_space_operations	file:
shmem_aops	./shmem.c	/^static const struct address_space_operations shmem_aops;$/;"	v	typeref:struct:address_space_operations	file:
shmem_confirm_swap	./shmem.c	/^static bool shmem_confirm_swap(struct address_space *mapping,$/;"	f	file:
shmem_create	./shmem.c	/^static int shmem_create(struct inode *dir, struct dentry *dentry, umode_t mode,$/;"	f	file:
shmem_default_max_blocks	./shmem.c	/^static unsigned long shmem_default_max_blocks(void)$/;"	f	file:
shmem_default_max_inodes	./shmem.c	/^static unsigned long shmem_default_max_inodes(void)$/;"	f	file:
shmem_delete_from_page_cache	./shmem.c	/^static void shmem_delete_from_page_cache(struct page *page, void *radswap)$/;"	f	file:
shmem_destroy_callback	./shmem.c	/^static void shmem_destroy_callback(struct rcu_head *head)$/;"	f	file:
shmem_destroy_inode	./shmem.c	/^static void shmem_destroy_inode(struct inode *inode)$/;"	f	file:
shmem_destroy_inodecache	./shmem.c	/^static void shmem_destroy_inodecache(void)$/;"	f	file:
shmem_dir_inode_operations	./shmem.c	/^static const struct inode_operations shmem_dir_inode_operations = {$/;"	v	typeref:struct:inode_operations	file:
shmem_dir_inode_operations	./shmem.c	/^static const struct inode_operations shmem_dir_inode_operations;$/;"	v	typeref:struct:inode_operations	file:
shmem_encode_fh	./shmem.c	/^static int shmem_encode_fh(struct inode *inode, __u32 *fh, int *len,$/;"	f	file:
shmem_evict_inode	./shmem.c	/^static void shmem_evict_inode(struct inode *inode)$/;"	f	file:
shmem_export_ops	./shmem.c	/^static const struct export_operations shmem_export_ops = {$/;"	v	typeref:struct:export_operations	file:
shmem_falloc	./shmem.c	/^struct shmem_falloc {$/;"	s	file:
shmem_fallocate	./shmem.c	/^static long shmem_fallocate(struct file *file, int mode, loff_t offset,$/;"	f	file:
shmem_fault	./shmem.c	/^static int shmem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f	file:
shmem_fh_to_dentry	./shmem.c	/^static struct dentry *shmem_fh_to_dentry(struct super_block *sb,$/;"	f	file:
shmem_file_aio_read	./shmem.c	/^static ssize_t shmem_file_aio_read(struct kiocb *iocb,$/;"	f	file:
shmem_file_llseek	./shmem.c	/^static loff_t shmem_file_llseek(struct file *file, loff_t offset, int whence)$/;"	f	file:
shmem_file_operations	./shmem.c	/^static const struct file_operations shmem_file_operations = {$/;"	v	typeref:struct:file_operations	file:
shmem_file_operations	./shmem.c	/^static const struct file_operations shmem_file_operations;$/;"	v	typeref:struct:file_operations	file:
shmem_file_operations	./shmem.c	2815;"	d	file:
shmem_file_setup	./shmem.c	/^EXPORT_SYMBOL_GPL(shmem_file_setup);$/;"	v
shmem_file_setup	./shmem.c	/^struct file *shmem_file_setup(const char *name, loff_t size, unsigned long flags)$/;"	f
shmem_file_splice_read	./shmem.c	/^static ssize_t shmem_file_splice_read(struct file *in, loff_t *ppos,$/;"	f	file:
shmem_fill_super	./shmem.c	/^int shmem_fill_super(struct super_block *sb, void *data, int silent)$/;"	f
shmem_follow_link	./shmem.c	/^static void *shmem_follow_link(struct dentry *dentry, struct nameidata *nd)$/;"	f	file:
shmem_follow_short_symlink	./shmem.c	/^static void *shmem_follow_short_symlink(struct dentry *dentry, struct nameidata *nd)$/;"	f	file:
shmem_free_inode	./shmem.c	/^static void shmem_free_inode(struct super_block *sb)$/;"	f	file:
shmem_free_swap	./shmem.c	/^static int shmem_free_swap(struct address_space *mapping,$/;"	f	file:
shmem_fs_type	./shmem.c	/^static struct file_system_type shmem_fs_type = {$/;"	v	typeref:struct:file_system_type	file:
shmem_get_inode	./shmem.c	/^static struct inode *shmem_get_inode(struct super_block *sb, const struct inode *dir,$/;"	f	file:
shmem_get_inode	./shmem.c	2816;"	d	file:
shmem_get_parent	./shmem.c	/^static struct dentry *shmem_get_parent(struct dentry *child)$/;"	f	file:
shmem_get_policy	./shmem.c	/^static struct mempolicy *shmem_get_policy(struct vm_area_struct *vma,$/;"	f	file:
shmem_get_sbmpol	./shmem.c	/^static inline struct mempolicy *shmem_get_sbmpol(struct shmem_sb_info *sbinfo)$/;"	f	file:
shmem_get_sbmpol	./shmem.c	/^static struct mempolicy *shmem_get_sbmpol(struct shmem_sb_info *sbinfo)$/;"	f	file:
shmem_getpage	./shmem.c	/^static inline int shmem_getpage(struct inode *inode, pgoff_t index,$/;"	f	file:
shmem_getpage_gfp	./shmem.c	/^static int shmem_getpage_gfp(struct inode *inode, pgoff_t index,$/;"	f	file:
shmem_getxattr	./shmem.c	/^static ssize_t shmem_getxattr(struct dentry *dentry, const char *name,$/;"	f	file:
shmem_init	./shmem.c	/^int __init shmem_init(void)$/;"	f
shmem_init_inode	./shmem.c	/^static void shmem_init_inode(void *foo)$/;"	f	file:
shmem_init_inodecache	./shmem.c	/^static int shmem_init_inodecache(void)$/;"	f	file:
shmem_initxattrs	./shmem.c	/^static int shmem_initxattrs(struct inode *inode,$/;"	f	file:
shmem_initxattrs	./shmem.c	1367;"	d	file:
shmem_inode_cachep	./shmem.c	/^static struct kmem_cache *shmem_inode_cachep;$/;"	v	typeref:struct:kmem_cache	file:
shmem_inode_operations	./shmem.c	/^static const struct inode_operations shmem_inode_operations = {$/;"	v	typeref:struct:inode_operations	file:
shmem_inode_operations	./shmem.c	/^static const struct inode_operations shmem_inode_operations;$/;"	v	typeref:struct:inode_operations	file:
shmem_kernel_file_setup	./shmem.c	/^struct file *shmem_kernel_file_setup(const char *name, loff_t size, unsigned long flags)$/;"	f
shmem_link	./shmem.c	/^static int shmem_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)$/;"	f	file:
shmem_listxattr	./shmem.c	/^static ssize_t shmem_listxattr(struct dentry *dentry, char *buffer, size_t size)$/;"	f	file:
shmem_lock	./shmem.c	/^int shmem_lock(struct file *file, int lock, struct user_struct *user)$/;"	f
shmem_mapping	./shmem.c	/^bool shmem_mapping(struct address_space *mapping)$/;"	f
shmem_match	./shmem.c	/^static int shmem_match(struct inode *ino, void *vfh)$/;"	f	file:
shmem_mkdir	./shmem.c	/^static int shmem_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)$/;"	f	file:
shmem_mknod	./shmem.c	/^shmem_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)$/;"	f	file:
shmem_mmap	./shmem.c	/^static int shmem_mmap(struct file *file, struct vm_area_struct *vma)$/;"	f	file:
shmem_mount	./shmem.c	/^static struct dentry *shmem_mount(struct file_system_type *fs_type,$/;"	f	file:
shmem_ops	./shmem.c	/^static const struct super_operations shmem_ops = {$/;"	v	typeref:struct:super_operations	file:
shmem_ops	./shmem.c	/^static const struct super_operations shmem_ops;$/;"	v	typeref:struct:super_operations	file:
shmem_parse_options	./shmem.c	/^static int shmem_parse_options(char *options, struct shmem_sb_info *sbinfo,$/;"	f	file:
shmem_put_link	./shmem.c	/^static void shmem_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)$/;"	f	file:
shmem_put_super	./shmem.c	/^static void shmem_put_super(struct super_block *sb)$/;"	f	file:
shmem_radix_tree_replace	./shmem.c	/^static int shmem_radix_tree_replace(struct address_space *mapping,$/;"	f	file:
shmem_read_mapping_page_gfp	./shmem.c	/^EXPORT_SYMBOL_GPL(shmem_read_mapping_page_gfp);$/;"	v
shmem_read_mapping_page_gfp	./shmem.c	/^struct page *shmem_read_mapping_page_gfp(struct address_space *mapping,$/;"	f
shmem_recalc_inode	./shmem.c	/^static void shmem_recalc_inode(struct inode *inode)$/;"	f	file:
shmem_remount_fs	./shmem.c	/^static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)$/;"	f	file:
shmem_removexattr	./shmem.c	/^static int shmem_removexattr(struct dentry *dentry, const char *name)$/;"	f	file:
shmem_rename	./shmem.c	/^static int shmem_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)$/;"	f	file:
shmem_replace_page	./shmem.c	/^static int shmem_replace_page(struct page **pagep, gfp_t gfp,$/;"	f	file:
shmem_reserve_inode	./shmem.c	/^static int shmem_reserve_inode(struct super_block *sb)$/;"	f	file:
shmem_rmdir	./shmem.c	/^static int shmem_rmdir(struct inode *dir, struct dentry *dentry)$/;"	f	file:
shmem_seek_hole_data	./shmem.c	/^static pgoff_t shmem_seek_hole_data(struct address_space *mapping,$/;"	f	file:
shmem_set_policy	./shmem.c	/^static int shmem_set_policy(struct vm_area_struct *vma, struct mempolicy *mpol)$/;"	f	file:
shmem_setattr	./shmem.c	/^static int shmem_setattr(struct dentry *dentry, struct iattr *attr)$/;"	f	file:
shmem_setxattr	./shmem.c	/^static int shmem_setxattr(struct dentry *dentry, const char *name,$/;"	f	file:
shmem_short_symlink_operations	./shmem.c	/^static const struct inode_operations shmem_short_symlink_operations = {$/;"	v	typeref:struct:inode_operations	file:
shmem_short_symlink_operations	./shmem.c	/^static const struct inode_operations shmem_short_symlink_operations;$/;"	v	typeref:struct:inode_operations	file:
shmem_should_replace_page	./shmem.c	/^static bool shmem_should_replace_page(struct page *page, gfp_t gfp)$/;"	f	file:
shmem_show_mpol	./shmem.c	/^static inline void shmem_show_mpol(struct seq_file *seq, struct mempolicy *mpol)$/;"	f	file:
shmem_show_mpol	./shmem.c	/^static void shmem_show_mpol(struct seq_file *seq, struct mempolicy *mpol)$/;"	f	file:
shmem_show_options	./shmem.c	/^static int shmem_show_options(struct seq_file *seq, struct dentry *root)$/;"	f	file:
shmem_special_inode_operations	./shmem.c	/^static const struct inode_operations shmem_special_inode_operations = {$/;"	v	typeref:struct:inode_operations	file:
shmem_special_inode_operations	./shmem.c	/^static const struct inode_operations shmem_special_inode_operations;$/;"	v	typeref:struct:inode_operations	file:
shmem_statfs	./shmem.c	/^static int shmem_statfs(struct dentry *dentry, struct kstatfs *buf)$/;"	f	file:
shmem_swapin	./shmem.c	/^static inline struct page *shmem_swapin(swp_entry_t swap, gfp_t gfp,$/;"	f	file:
shmem_swapin	./shmem.c	/^static struct page *shmem_swapin(swp_entry_t swap, gfp_t gfp,$/;"	f	file:
shmem_symlink	./shmem.c	/^static int shmem_symlink(struct inode *dir, struct dentry *dentry, const char *symname)$/;"	f	file:
shmem_symlink_inode_operations	./shmem.c	/^static const struct inode_operations shmem_symlink_inode_operations = {$/;"	v	typeref:struct:inode_operations	file:
shmem_symlink_inode_operations	./shmem.c	/^static const struct inode_operations shmem_symlink_inode_operations;$/;"	v	typeref:struct:inode_operations	file:
shmem_tmpfile	./shmem.c	/^shmem_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)$/;"	f	file:
shmem_truncate_range	./shmem.c	/^EXPORT_SYMBOL_GPL(shmem_truncate_range);$/;"	v
shmem_truncate_range	./shmem.c	/^void shmem_truncate_range(struct inode *inode, loff_t lstart, loff_t lend)$/;"	f
shmem_unacct_blocks	./shmem.c	/^static inline void shmem_unacct_blocks(unsigned long flags, long pages)$/;"	f	file:
shmem_unacct_size	./shmem.c	/^static inline void shmem_unacct_size(unsigned long flags, loff_t size)$/;"	f	file:
shmem_unacct_size	./shmem.c	2818;"	d	file:
shmem_undo_range	./shmem.c	/^static void shmem_undo_range(struct inode *inode, loff_t lstart, loff_t lend,$/;"	f	file:
shmem_unlink	./shmem.c	/^static int shmem_unlink(struct inode *dir, struct dentry *dentry)$/;"	f	file:
shmem_unlock_mapping	./shmem.c	/^void shmem_unlock_mapping(struct address_space *mapping)$/;"	f
shmem_unuse	./shmem.c	/^int shmem_unuse(swp_entry_t swap, struct page *page)$/;"	f
shmem_unuse_inode	./shmem.c	/^static int shmem_unuse_inode(struct shmem_inode_info *info,$/;"	f	file:
shmem_vm_ops	./shmem.c	/^static const struct vm_operations_struct shmem_vm_ops = {$/;"	v	typeref:struct:vm_operations_struct	file:
shmem_vm_ops	./shmem.c	/^static const struct vm_operations_struct shmem_vm_ops;$/;"	v	typeref:struct:vm_operations_struct	file:
shmem_vm_ops	./shmem.c	2814;"	d	file:
shmem_write_begin	./shmem.c	/^shmem_write_begin(struct file *file, struct address_space *mapping,$/;"	f	file:
shmem_write_end	./shmem.c	/^shmem_write_end(struct file *file, struct address_space *mapping,$/;"	f	file:
shmem_writepage	./shmem.c	/^static int shmem_writepage(struct page *page, struct writeback_control *wbc)$/;"	f	file:
shmem_xattr_handlers	./shmem.c	/^static const struct xattr_handler *shmem_xattr_handlers[] = {$/;"	v	typeref:struct:xattr_handler	file:
shmem_xattr_validate	./shmem.c	/^static int shmem_xattr_validate(const char *name)$/;"	f	file:
shmem_zero_setup	./shmem.c	/^int shmem_zero_setup(struct vm_area_struct *vma)$/;"	f
should_alloc_retry	./page_alloc.c	/^should_alloc_retry(gfp_t gfp_mask, unsigned int order,$/;"	f	file:
should_continue_reclaim	./vmscan.c	/^static inline bool should_continue_reclaim(struct zone *zone,$/;"	f	file:
should_fail_alloc_page	./page_alloc.c	/^static bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)$/;"	f	file:
should_fail_alloc_page	./page_alloc.c	/^static inline bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)$/;"	f	file:
should_failslab	./failslab.c	/^bool should_failslab(size_t size, gfp_t gfpflags, unsigned long cache_flags)$/;"	f
should_release_lock	./compaction.c	/^static inline bool should_release_lock(spinlock_t *lock)$/;"	f	file:
should_suppress_show_mem	./page_alloc.c	/^static inline bool should_suppress_show_mem(void)$/;"	f	file:
show	./slub.c	/^	ssize_t (*show)(struct kmem_cache *s, char *buf);$/;"	m	struct:slab_attribute	file:
show_free_areas	./page_alloc.c	/^void show_free_areas(unsigned int filter)$/;"	f
show_migration_types	./page_alloc.c	/^static void show_migration_types(unsigned char type)$/;"	f	file:
show_node	./page_alloc.c	/^static inline void show_node(struct zone *zone)$/;"	f	file:
show_numa_info	./vmalloc.c	/^static void show_numa_info(struct seq_file *m, struct vm_struct *v)$/;"	f	file:
show_pools	./dmapool.c	/^show_pools(struct device *dev, struct device_attribute *attr, char *buf)$/;"	f	file:
show_slab_objects	./slub.c	/^static ssize_t show_slab_objects(struct kmem_cache *s,$/;"	f	file:
show_stat	./slub.c	/^static int show_stat(struct kmem_cache *s, char *buf, enum stat_item si)$/;"	f	file:
show_swap_cache_info	./swap_state.c	/^void show_swap_cache_info(void)$/;"	f
show_symbol	./slab.c	/^static void show_symbol(struct seq_file *m, unsigned long address)$/;"	f	file:
shrink	./slub.c	/^SLAB_ATTR(shrink);$/;"	v
shrink_active_list	./vmscan.c	/^static void shrink_active_list(unsigned long nr_to_scan,$/;"	f	file:
shrink_all_memory	./vmscan.c	/^unsigned long shrink_all_memory(unsigned long nr_to_reclaim)$/;"	f
shrink_huge_zero_page_count	./huge_memory.c	/^static unsigned long shrink_huge_zero_page_count(struct shrinker *shrink,$/;"	f	file:
shrink_huge_zero_page_scan	./huge_memory.c	/^static unsigned long shrink_huge_zero_page_scan(struct shrinker *shrink,$/;"	f	file:
shrink_inactive_list	./vmscan.c	/^shrink_inactive_list(unsigned long nr_to_scan, struct lruvec *lruvec,$/;"	f	file:
shrink_list	./vmscan.c	/^static unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,$/;"	f	file:
shrink_lruvec	./vmscan.c	/^static void shrink_lruvec(struct lruvec *lruvec, struct scan_control *sc)$/;"	f	file:
shrink_page_list	./vmscan.c	/^static unsigned long shrink_page_list(struct list_head *page_list,$/;"	f	file:
shrink_pgdat_span	./memory_hotplug.c	/^static void shrink_pgdat_span(struct pglist_data *pgdat,$/;"	f	file:
shrink_readahead_size_eio	./filemap.c	/^static void shrink_readahead_size_eio(struct file *filp,$/;"	f	file:
shrink_show	./slub.c	/^static ssize_t shrink_show(struct kmem_cache *s, char *buf)$/;"	f	file:
shrink_slab	./vmscan.c	/^unsigned long shrink_slab(struct shrink_control *shrinkctl,$/;"	f
shrink_slab_node	./vmscan.c	/^shrink_slab_node(struct shrink_control *shrinkctl, struct shrinker *shrinker,$/;"	f	file:
shrink_store	./slub.c	/^static ssize_t shrink_store(struct kmem_cache *s,$/;"	f	file:
shrink_vma	./nommu.c	/^static int shrink_vma(struct mm_struct *mm,$/;"	f	file:
shrink_zone	./vmscan.c	/^static void shrink_zone(struct zone *zone, struct scan_control *sc)$/;"	f	file:
shrink_zone_span	./memory_hotplug.c	/^static void shrink_zone_span(struct zone *zone, unsigned long start_pfn,$/;"	f	file:
shrink_zones	./vmscan.c	/^static bool shrink_zones(struct zonelist *zonelist, struct scan_control *sc)$/;"	f	file:
si_meminfo	./page_alloc.c	/^EXPORT_SYMBOL(si_meminfo);$/;"	v
si_meminfo	./page_alloc.c	/^void si_meminfo(struct sysinfo *val)$/;"	f
si_meminfo_node	./page_alloc.c	/^void si_meminfo_node(struct sysinfo *val, int nid)$/;"	f
si_swapinfo	./swapfile.c	/^void si_swapinfo(struct sysinfo *val)$/;"	f
single_bit_flip	./debug-pagealloc.c	/^static bool single_bit_flip(unsigned char a, unsigned char b)$/;"	f	file:
single_flag_show	./huge_memory.c	/^static ssize_t single_flag_show(struct kobject *kobj,$/;"	f	file:
single_flag_store	./huge_memory.c	/^static ssize_t single_flag_store(struct kobject *kobj,$/;"	f	file:
size	./dmapool.c	/^	size_t size;$/;"	m	struct:dma_pool	file:
size	./kmemleak.c	/^	size_t size;			\/* memory block size *\/$/;"	m	struct:early_log	file:
size	./kmemleak.c	/^	size_t size;$/;"	m	struct:kmemleak_object	file:
size	./kmemleak.c	/^	size_t size;$/;"	m	struct:kmemleak_scan_area	file:
size	./memcontrol.c	/^	unsigned int size;$/;"	m	struct:mem_cgroup_threshold_ary	file:
size	./pos.c	/^	unsigned long size;$/;"	m	struct:seg_inform	file:
size	./slob.c	/^	int size;$/;"	m	struct:slob_rcu	file:
size	./zsmalloc.c	/^	int size;$/;"	m	struct:size_class	file:
size_class	./zsmalloc.c	/^	struct size_class size_class[ZS_SIZE_CLASSES];$/;"	m	struct:zs_pool	typeref:struct:zs_pool::size_class	file:
size_class	./zsmalloc.c	/^struct size_class {$/;"	s	file:
size_index	./slab_common.c	/^static s8 size_index[24] = {$/;"	v	file:
size_index_elem	./slab_common.c	/^static inline int size_index_elem(size_t bytes)$/;"	f	file:
size_to_chunks	./zbud.c	/^static int size_to_chunks(int size)$/;"	f	file:
size_to_hstate	./hugetlb.c	/^struct hstate *size_to_hstate(unsigned long size)$/;"	f
skip_free_areas_node	./page_alloc.c	/^bool skip_free_areas_node(unsigned int flags, int nid)$/;"	f
slab	./memory-failure.c	753;"	d	file:
slab	./memory-failure.c	810;"	d	file:
slab_alloc	./slab.c	/^slab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)$/;"	f	file:
slab_alloc	./slub.c	/^static __always_inline void *slab_alloc(struct kmem_cache *s,$/;"	f	file:
slab_alloc_node	./slab.c	/^slab_alloc_node(struct kmem_cache *cachep, gfp_t flags, int nodeid,$/;"	f	file:
slab_alloc_node	./slub.c	/^static __always_inline void *slab_alloc_node(struct kmem_cache *s,$/;"	f	file:
slab_attr_group	./slub.c	/^static struct attribute_group slab_attr_group = {$/;"	v	typeref:struct:attribute_group	file:
slab_attr_show	./slub.c	/^static ssize_t slab_attr_show(struct kobject *kobj,$/;"	f	file:
slab_attr_store	./slub.c	/^static ssize_t slab_attr_store(struct kobject *kobj,$/;"	f	file:
slab_attribute	./slub.c	/^struct slab_attribute {$/;"	s	file:
slab_attrs	./slub.c	/^static struct attribute *slab_attrs[] = {$/;"	v	typeref:struct:attribute	file:
slab_bug	./slub.c	/^static void slab_bug(struct kmem_cache *s, char *fmt, ...)$/;"	f	file:
slab_caches	./slab_common.c	/^LIST_HEAD(slab_caches);$/;"	v
slab_caches_mutex	./memcontrol.c	/^	struct mutex slab_caches_mutex;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::mutex	file:
slab_cpuup_callback	./slub.c	/^static int slab_cpuup_callback(struct notifier_block *nfb,$/;"	f	file:
slab_destroy	./slab.c	/^static void slab_destroy(struct kmem_cache *cachep, struct page *page)$/;"	f	file:
slab_destroy_debugcheck	./slab.c	/^static void slab_destroy_debugcheck(struct kmem_cache *cachep,$/;"	f	file:
slab_early_init	./slab.c	/^static int slab_early_init = 1;$/;"	v	file:
slab_equal_or_root	./slab.h	/^static inline bool slab_equal_or_root(struct kmem_cache *s,$/;"	f
slab_err	./slub.c	/^static void slab_err(struct kmem_cache *s, struct page *page,$/;"	f	file:
slab_error	./slab.c	645;"	d	file:
slab_fix	./slub.c	/^static void slab_fix(struct kmem_cache *s, char *fmt, ...)$/;"	f	file:
slab_free	./slub.c	/^static __always_inline void slab_free(struct kmem_cache *s,$/;"	f	file:
slab_free_hook	./slub.c	/^static inline void slab_free_hook(struct kmem_cache *s, void *x)$/;"	f	file:
slab_get_obj	./slab.c	/^static void *slab_get_obj(struct kmem_cache *cachep, struct page *page,$/;"	f	file:
slab_index	./slub.c	/^static inline int slab_index(void *p, struct kmem_cache *s, void *addr)$/;"	f	file:
slab_is_available	./slab_common.c	/^int slab_is_available(void)$/;"	f
slab_kmem_cache_release	./slab_common.c	/^void slab_kmem_cache_release(struct kmem_cache *s)$/;"	f
slab_kset	./slub.c	/^static struct kset *slab_kset;$/;"	v	typeref:struct:kset	file:
slab_ksize	./slub.c	/^static inline size_t slab_ksize(const struct kmem_cache *s)$/;"	f	file:
slab_ktype	./slub.c	/^static struct kobj_type slab_ktype = {$/;"	v	typeref:struct:kobj_type	file:
slab_lock	./slub.c	/^static __always_inline void slab_lock(struct page *page)$/;"	f	file:
slab_map_pages	./slab.c	/^static void slab_map_pages(struct kmem_cache *cache, struct page *page,$/;"	f	file:
slab_max_order	./slab.c	/^static int slab_max_order = SLAB_MAX_ORDER_LO;$/;"	v	file:
slab_max_order_setup	./slab.c	/^static int __init slab_max_order_setup(char *str)$/;"	f	file:
slab_mem_going_offline_callback	./slub.c	/^static int slab_mem_going_offline_callback(void *arg)$/;"	f	file:
slab_mem_going_online_callback	./slub.c	/^static int slab_mem_going_online_callback(void *arg)$/;"	f	file:
slab_mem_offline_callback	./slub.c	/^static void slab_mem_offline_callback(void *arg)$/;"	f	file:
slab_memory_callback	./slab.c	/^static int __meminit slab_memory_callback(struct notifier_block *self,$/;"	f	file:
slab_memory_callback	./slub.c	/^static int slab_memory_callback(struct notifier_block *self,$/;"	f	file:
slab_memory_callback_nb	./slub.c	/^static struct notifier_block slab_memory_callback_nb = {$/;"	v	typeref:struct:notifier_block	file:
slab_mutex	./slab_common.c	/^DEFINE_MUTEX(slab_mutex);$/;"	v
slab_next	./slab_common.c	/^void *slab_next(struct seq_file *m, void *p, loff_t *pos)$/;"	f
slab_notifier	./slub.c	/^static struct notifier_block slab_notifier = {$/;"	v	typeref:struct:notifier_block	file:
slab_notifier	./slub.c	/^static struct notifier_block slab_notifier;$/;"	v	typeref:struct:notifier_block	file:
slab_order	./slub.c	/^static inline int slab_order(int size, int min_objects,$/;"	f	file:
slab_out_of_memory	./slab.c	/^slab_out_of_memory(struct kmem_cache *cachep, gfp_t gfpflags, int nodeid)$/;"	f	file:
slab_out_of_memory	./slub.c	/^slab_out_of_memory(struct kmem_cache *s, gfp_t gfpflags, int nid)$/;"	f	file:
slab_pad_check	./slub.c	/^static inline int slab_pad_check(struct kmem_cache *s, struct page *page)$/;"	f	file:
slab_pad_check	./slub.c	/^static int slab_pad_check(struct kmem_cache *s, struct page *page)$/;"	f	file:
slab_post_alloc_hook	./slub.c	/^static inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,$/;"	f	file:
slab_post_alloc_hook	./slub.c	/^static inline void slab_post_alloc_hook(struct kmem_cache *s,$/;"	f	file:
slab_pre_alloc_hook	./slub.c	/^static inline int slab_pre_alloc_hook(struct kmem_cache *s, gfp_t flags)$/;"	f	file:
slab_proc_init	./slab.c	/^module_init(slab_proc_init);$/;"	v
slab_proc_init	./slab.c	/^static int __init slab_proc_init(void)$/;"	f	file:
slab_proc_init	./slab_common.c	/^module_init(slab_proc_init);$/;"	v
slab_proc_init	./slab_common.c	/^static int __init slab_proc_init(void)$/;"	f	file:
slab_put_obj	./slab.c	/^static void slab_put_obj(struct kmem_cache *cachep, struct page *page,$/;"	f	file:
slab_set_debugobj_lock_classes	./slab.c	/^static void slab_set_debugobj_lock_classes(struct kmem_cache *cachep)$/;"	f	file:
slab_set_debugobj_lock_classes_node	./slab.c	/^static void slab_set_debugobj_lock_classes_node(struct kmem_cache *cachep, int node)$/;"	f	file:
slab_set_lock_classes	./slab.c	/^static void slab_set_lock_classes(struct kmem_cache *cachep,$/;"	f	file:
slab_should_failslab	./slab.c	/^static bool slab_should_failslab(struct kmem_cache *cachep, gfp_t flags)$/;"	f	file:
slab_size	./slub.c	/^SLAB_ATTR_RO(slab_size);$/;"	v
slab_size_show	./slub.c	/^static ssize_t slab_size_show(struct kmem_cache *s, char *buf)$/;"	f	file:
slab_stat_type	./slub.c	/^enum slab_stat_type {$/;"	g	file:
slab_state	./slab.h	/^enum slab_state {$/;"	g
slab_state	./slab_common.c	/^enum slab_state slab_state;$/;"	v	typeref:enum:slab_state
slab_stop	./slab_common.c	/^void slab_stop(struct seq_file *m, void *p)$/;"	f
slab_sysfs_init	./slub.c	/^__initcall(slab_sysfs_init);$/;"	v
slab_sysfs_init	./slub.c	/^static int __init slab_sysfs_init(void)$/;"	f	file:
slab_sysfs_ops	./slub.c	/^static const struct sysfs_ops slab_sysfs_ops = {$/;"	v	typeref:struct:sysfs_ops	file:
slab_uevent_ops	./slub.c	/^static const struct kset_uevent_ops slab_uevent_ops = {$/;"	v	typeref:struct:kset_uevent_ops	file:
slab_unlock	./slub.c	/^static __always_inline void slab_unlock(struct page *page)$/;"	f	file:
slab_unmergeable	./slub.c	/^static int slab_unmergeable(struct kmem_cache *s)$/;"	f	file:
slabinfo	./slab.h	/^struct slabinfo {$/;"	s
slabinfo_op	./slab_common.c	/^static const struct seq_operations slabinfo_op = {$/;"	v	typeref:struct:seq_operations	file:
slabinfo_open	./slab_common.c	/^static int slabinfo_open(struct inode *inode, struct file *file)$/;"	f	file:
slabinfo_show_stats	./slab.c	/^void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *cachep)$/;"	f
slabinfo_show_stats	./slub.c	/^void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)$/;"	f
slabinfo_write	./slab.c	/^ssize_t slabinfo_write(struct file *file, const char __user *buffer,$/;"	f
slabinfo_write	./slub.c	/^ssize_t slabinfo_write(struct file *file, const char __user *buffer,$/;"	f
slabs	./slub.c	/^SLAB_ATTR_RO(slabs);$/;"	v
slabs_cpu_partial	./slub.c	/^SLAB_ATTR_RO(slabs_cpu_partial);$/;"	v
slabs_cpu_partial_show	./slub.c	/^static ssize_t slabs_cpu_partial_show(struct kmem_cache *s, char *buf)$/;"	f	file:
slabs_free	./slab.h	/^	struct list_head slabs_free;$/;"	m	struct:kmem_cache_node	typeref:struct:kmem_cache_node::list_head
slabs_full	./slab.h	/^	struct list_head slabs_full;$/;"	m	struct:kmem_cache_node	typeref:struct:kmem_cache_node::list_head
slabs_node	./slub.c	/^static inline unsigned long slabs_node(struct kmem_cache *s, int node)$/;"	f	file:
slabs_partial	./slab.h	/^	struct list_head slabs_partial;	\/* partial list first, better asm code *\/$/;"	m	struct:kmem_cache_node	typeref:struct:kmem_cache_node::list_head
slabs_show	./slub.c	/^static ssize_t slabs_show(struct kmem_cache *s, char *buf)$/;"	f	file:
slabs_tofree	./slab.c	/^static inline int slabs_tofree(struct kmem_cache *cachep,$/;"	f	file:
slabstats_op	./slab.c	/^static const struct seq_operations slabstats_op = {$/;"	v	typeref:struct:seq_operations	file:
slabstats_open	./slab.c	/^static int slabstats_open(struct inode *inode, struct file *file)$/;"	f	file:
sleep_millisecs	./ksm.c	/^KSM_ATTR(sleep_millisecs);$/;"	v
sleep_millisecs_show	./ksm.c	/^static ssize_t sleep_millisecs_show(struct kobject *kobj,$/;"	f	file:
sleep_millisecs_store	./ksm.c	/^static ssize_t sleep_millisecs_store(struct kobject *kobj,$/;"	f	file:
sleep_on_page	./filemap.c	/^static int sleep_on_page(void *word)$/;"	f	file:
sleep_on_page_killable	./filemap.c	/^static int sleep_on_page_killable(void *word)$/;"	f	file:
slob_alloc	./slob.c	/^static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)$/;"	f	file:
slob_alloc_node	./slob.c	/^EXPORT_SYMBOL(slob_alloc_node);$/;"	v
slob_alloc_node	./slob.c	/^void *slob_alloc_node(struct kmem_cache *c, gfp_t flags, int node)$/;"	f
slob_block	./slob.c	/^struct slob_block {$/;"	s	file:
slob_free	./slob.c	/^static void slob_free(void *block, int size)$/;"	f	file:
slob_free_pages	./slob.c	/^static void slob_free_pages(void *b, int order)$/;"	f	file:
slob_last	./slob.c	/^static int slob_last(slob_t *s)$/;"	f	file:
slob_new_pages	./slob.c	/^static void *slob_new_pages(gfp_t gfp, int order, int node)$/;"	f	file:
slob_next	./slob.c	/^static slob_t *slob_next(slob_t *s)$/;"	f	file:
slob_page_alloc	./slob.c	/^static void *slob_page_alloc(struct page *sp, size_t size, int align)$/;"	f	file:
slob_page_free	./slob.c	/^static inline int slob_page_free(struct page *sp)$/;"	f	file:
slob_rcu	./slob.c	/^struct slob_rcu {$/;"	s	file:
slob_t	./slob.c	/^typedef struct slob_block slob_t;$/;"	t	typeref:struct:slob_block	file:
slob_units	./slob.c	/^static slobidx_t slob_units(slob_t *s)$/;"	f	file:
slobidx_t	./slob.c	/^typedef s16 slobidx_t;$/;"	t	file:
slobidx_t	./slob.c	/^typedef s32 slobidx_t;$/;"	t	file:
slub_debug	./slub.c	/^static int slub_debug = DEBUG_DEFAULT_FLAGS;$/;"	v	file:
slub_debug	./slub.c	/^static int slub_debug;$/;"	v	file:
slub_debug	./slub.c	1274;"	d	file:
slub_debug_slabs	./slub.c	/^static char *slub_debug_slabs;$/;"	v	file:
slub_max_order	./slub.c	/^static int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;$/;"	v	file:
slub_min_objects	./slub.c	/^static int slub_min_objects;$/;"	v	file:
slub_min_order	./slub.c	/^static int slub_min_order;$/;"	v	file:
slub_nomerge	./slub.c	/^static int slub_nomerge;$/;"	v	file:
sn_cache	./mempolicy.c	/^static struct kmem_cache *sn_cache;$/;"	v	typeref:struct:kmem_cache	file:
sock_release_memcg	./memcontrol.c	/^void sock_release_memcg(struct sock *sk)$/;"	f
sock_update_memcg	./memcontrol.c	/^EXPORT_SYMBOL(sock_update_memcg);$/;"	v
sock_update_memcg	./memcontrol.c	/^void sock_update_memcg(struct sock *sk)$/;"	f
soft_limit_tree_from_page	./memcontrol.c	/^soft_limit_tree_from_page(struct page *page)$/;"	f	file:
soft_limit_tree_node_zone	./memcontrol.c	/^soft_limit_tree_node_zone(int nid, int zid)$/;"	f	file:
soft_offline_huge_page	./memory-failure.c	/^static int soft_offline_huge_page(struct page *page, int flags)$/;"	f	file:
soft_offline_page	./memory-failure.c	/^int soft_offline_page(struct page *page, int flags)$/;"	f
sp_alloc	./mempolicy.c	/^static struct sp_node *sp_alloc(unsigned long start, unsigned long end,$/;"	f	file:
sp_delete	./mempolicy.c	/^static void sp_delete(struct shared_policy *sp, struct sp_node *n)$/;"	f	file:
sp_free	./mempolicy.c	/^static void sp_free(struct sp_node *n)$/;"	f	file:
sp_insert	./mempolicy.c	/^static void sp_insert(struct shared_policy *sp, struct sp_node *new)$/;"	f	file:
sp_lookup	./mempolicy.c	/^sp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)$/;"	f	file:
sp_node_init	./mempolicy.c	/^static void sp_node_init(struct sp_node *node, unsigned long start,$/;"	f	file:
spare	./memcontrol.c	/^	struct mem_cgroup_threshold_ary *spare;$/;"	m	struct:mem_cgroup_thresholds	typeref:struct:mem_cgroup_thresholds::mem_cgroup_threshold_ary	file:
sparse_add_one_section	./sparse.c	/^int __meminit sparse_add_one_section(struct zone *zone, unsigned long start_pfn)$/;"	f
sparse_decode_mem_map	./sparse.c	/^struct page *sparse_decode_mem_map(unsigned long coded_mem_map, unsigned long pnum)$/;"	f
sparse_early_mem_map_alloc	./sparse.c	/^static struct page __init *sparse_early_mem_map_alloc(unsigned long pnum)$/;"	f	file:
sparse_early_mem_maps_alloc_node	./sparse.c	/^static void __init sparse_early_mem_maps_alloc_node(void *data,$/;"	f	file:
sparse_early_nid	./sparse.c	/^static inline int sparse_early_nid(struct mem_section *section)$/;"	f	file:
sparse_early_usemaps_alloc_node	./sparse.c	/^static void __init sparse_early_usemaps_alloc_node(void *data,$/;"	f	file:
sparse_early_usemaps_alloc_pgdat_section	./sparse.c	/^sparse_early_usemaps_alloc_pgdat_section(struct pglist_data *pgdat,$/;"	f	file:
sparse_encode_early_nid	./sparse.c	/^static inline unsigned long sparse_encode_early_nid(int nid)$/;"	f	file:
sparse_encode_mem_map	./sparse.c	/^static unsigned long sparse_encode_mem_map(struct page *mem_map, unsigned long pnum)$/;"	f	file:
sparse_index_alloc	./sparse.c	/^static struct mem_section noinline __init_refok *sparse_index_alloc(int nid)$/;"	f	file:
sparse_index_init	./sparse.c	/^static inline int sparse_index_init(unsigned long section_nr, int nid)$/;"	f	file:
sparse_index_init	./sparse.c	/^static int __meminit sparse_index_init(unsigned long section_nr, int nid)$/;"	f	file:
sparse_init	./sparse.c	/^void __init sparse_init(void)$/;"	f
sparse_init_one_section	./sparse.c	/^static int __meminit sparse_init_one_section(struct mem_section *ms,$/;"	f	file:
sparse_mem_map_populate	./sparse-vmemmap.c	/^struct page * __meminit sparse_mem_map_populate(unsigned long pnum, int nid)$/;"	f
sparse_mem_map_populate	./sparse.c	/^struct page __init *sparse_mem_map_populate(unsigned long pnum, int nid)$/;"	f
sparse_mem_maps_populate_node	./sparse-vmemmap.c	/^void __init sparse_mem_maps_populate_node(struct page **map_map,$/;"	f
sparse_mem_maps_populate_node	./sparse.c	/^void __init sparse_mem_maps_populate_node(struct page **map_map,$/;"	f
sparse_memory_present_with_active_regions	./page_alloc.c	/^void __init sparse_memory_present_with_active_regions(int nid)$/;"	f
sparse_remove_one_section	./sparse.c	/^void sparse_remove_one_section(struct zone *zone, struct mem_section *ms)$/;"	f
special_mapping_close	./mmap.c	/^static void special_mapping_close(struct vm_area_struct *vma)$/;"	f	file:
special_mapping_fault	./mmap.c	/^static int special_mapping_fault(struct vm_area_struct *vma,$/;"	f	file:
special_mapping_vmops	./mmap.c	/^static const struct vm_operations_struct special_mapping_vmops = {$/;"	v	typeref:struct:vm_operations_struct	file:
split_free_page	./page_alloc.c	/^int split_free_page(struct page *page)$/;"	f
split_huge_page_address	./huge_memory.c	/^static void split_huge_page_address(struct mm_struct *mm,$/;"	f	file:
split_huge_page_pmd_mm	./huge_memory.c	/^void split_huge_page_pmd_mm(struct mm_struct *mm, unsigned long address,$/;"	f
split_huge_page_to_list	./huge_memory.c	/^int split_huge_page_to_list(struct page *page, struct list_head *list)$/;"	f
split_page	./page_alloc.c	/^EXPORT_SYMBOL_GPL(split_page);$/;"	v
split_page	./page_alloc.c	/^void split_page(struct page *page, unsigned int order)$/;"	f
split_vma	./mmap.c	/^int split_vma(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
split_vma	./nommu.c	/^int split_vma(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f
srcu	./mmu_notifier.c	/^static struct srcu_struct srcu;$/;"	v	typeref:struct:srcu_struct	file:
stable_node	./ksm.c	/^struct stable_node {$/;"	s	file:
stable_node_cache	./ksm.c	/^static struct kmem_cache *stable_node_cache;$/;"	v	typeref:struct:kmem_cache	file:
stable_pages_required_show	./backing-dev.c	/^static ssize_t stable_pages_required_show(struct device *dev,$/;"	f	file:
stable_tree_append	./ksm.c	/^static void stable_tree_append(struct rmap_item *rmap_item,$/;"	f	file:
stable_tree_insert	./ksm.c	/^static struct stable_node *stable_tree_insert(struct page *kpage)$/;"	f	file:
stable_tree_search	./ksm.c	/^static struct page *stable_tree_search(struct page *page)$/;"	f	file:
stack_guard_page	./memory.c	/^static inline int stack_guard_page(struct vm_area_struct *vma, unsigned long addr)$/;"	f	file:
start	./kmemleak.c	/^	unsigned long start;$/;"	m	struct:kmemleak_scan_area	file:
start	./shmem.c	/^	pgoff_t start;		\/* start of range currently being fallocated *\/$/;"	m	struct:shmem_falloc	file:
start_cpu_timer	./slab.c	/^static void start_cpu_timer(int cpu)$/;"	f	file:
start_cpu_timer	./vmstat.c	/^static void start_cpu_timer(int cpu)$/;"	f	file:
start_isolate_page_range	./page_isolation.c	/^int start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,$/;"	f
start_khugepaged	./huge_memory.c	/^static int start_khugepaged(void)$/;"	f	file:
start_scan_thread	./kmemleak.c	/^static void start_scan_thread(void)$/;"	f	file:
stat	./memcontrol.c	/^	struct mem_cgroup_stat_cpu __percpu *stat;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::__percpu	file:
stat	./slub.c	/^static inline void stat(const struct kmem_cache *s, enum stat_item si)$/;"	f	file:
status	./migrate.c	/^	int status;$/;"	m	struct:page_to_node	file:
stop_scan_thread	./kmemleak.c	/^static void stop_scan_thread(void)$/;"	f	file:
store	./slub.c	/^	ssize_t (*store)(struct kmem_cache *s, const char *x, size_t count);$/;"	m	struct:slab_attribute	file:
store_stackinfo	./slab.c	/^static void store_stackinfo(struct kmem_cache *cachep, unsigned long *addr,$/;"	f	file:
store_user	./slub.c	/^SLAB_ATTR(store_user);$/;"	v
store_user_show	./slub.c	/^static ssize_t store_user_show(struct kmem_cache *s, char *buf)$/;"	f	file:
store_user_store	./slub.c	/^static ssize_t store_user_store(struct kmem_cache *s,$/;"	f	file:
strndup_user	./util.c	/^EXPORT_SYMBOL(strndup_user);$/;"	v
strndup_user	./util.c	/^char *strndup_user(const char __user *s, long n)$/;"	f
subpool_inode	./hugetlb.c	/^static inline struct hugepage_subpool *subpool_inode(struct inode *inode)$/;"	f	file:
subpool_vma	./hugetlb.c	/^static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)$/;"	f	file:
suitable_migration_target	./compaction.c	/^static bool suitable_migration_target(struct page *page)$/;"	f	file:
sum_time	./slub.c	/^	long long sum_time;$/;"	m	struct:location	file:
sum_vm_events	./vmstat.c	/^static void sum_vm_events(unsigned long *ret)$/;"	f	file:
surplus_hugepages	./hugetlb.c	/^HSTATE_ATTR_RO(surplus_hugepages);$/;"	v
surplus_hugepages_show	./hugetlb.c	/^static ssize_t surplus_hugepages_show(struct kobject *kobj,$/;"	f	file:
swap_aops	./swap_state.c	/^static const struct address_space_operations swap_aops = {$/;"	v	typeref:struct:address_space_operations	file:
swap_backing_dev_info	./swap_state.c	/^static struct backing_dev_info swap_backing_dev_info = {$/;"	v	typeref:struct:backing_dev_info	file:
swap_cache_info	./swap_state.c	/^} swap_cache_info;$/;"	v	typeref:struct:__anon1	file:
swap_cgroup	./page_cgroup.c	/^struct swap_cgroup {$/;"	s	file:
swap_cgroup_cmpxchg	./page_cgroup.c	/^unsigned short swap_cgroup_cmpxchg(swp_entry_t ent,$/;"	f
swap_cgroup_ctrl	./page_cgroup.c	/^static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];$/;"	v	typeref:struct:swap_cgroup_ctrl	file:
swap_cgroup_ctrl	./page_cgroup.c	/^struct swap_cgroup_ctrl {$/;"	s	file:
swap_cgroup_prepare	./page_cgroup.c	/^static int swap_cgroup_prepare(int type)$/;"	f	file:
swap_cgroup_record	./page_cgroup.c	/^unsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id)$/;"	f
swap_cgroup_swapoff	./page_cgroup.c	/^void swap_cgroup_swapoff(int type)$/;"	f
swap_cgroup_swapon	./page_cgroup.c	/^int swap_cgroup_swapon(int type, unsigned long max_pages)$/;"	f
swap_cluster_schedule_discard	./swapfile.c	/^static void swap_cluster_schedule_discard(struct swap_info_struct *si,$/;"	f	file:
swap_count	./swapfile.c	/^static inline unsigned char swap_count(unsigned char ent)$/;"	f	file:
swap_count_continued	./swapfile.c	/^static bool swap_count_continued(struct swap_info_struct *si,$/;"	f	file:
swap_discard_work	./swapfile.c	/^static void swap_discard_work(struct work_struct *work)$/;"	f	file:
swap_discardable	./swapfile.c	/^static bool swap_discardable(struct swap_info_struct *si)$/;"	f	file:
swap_do_scheduled_discard	./swapfile.c	/^static void swap_do_scheduled_discard(struct swap_info_struct *si)$/;"	f	file:
swap_duplicate	./swapfile.c	/^int swap_duplicate(swp_entry_t entry)$/;"	f
swap_entry_free	./swapfile.c	/^static unsigned char swap_entry_free(struct swap_info_struct *p,$/;"	f	file:
swap_free	./swapfile.c	/^void swap_free(swp_entry_t entry)$/;"	f
swap_info	./swapfile.c	/^struct swap_info_struct *swap_info[MAX_SWAPFILES];$/;"	v	typeref:struct:swap_info_struct
swap_info_get	./swapfile.c	/^static struct swap_info_struct *swap_info_get(swp_entry_t entry)$/;"	f	file:
swap_list	./swapfile.c	/^struct swap_list_t swap_list = {-1, -1};$/;"	v	typeref:struct:swap_list_t
swap_lock	./swapfile.c	/^DEFINE_SPINLOCK(swap_lock);$/;"	v
swap_next	./swapfile.c	/^static void *swap_next(struct seq_file *swap, void *v, loff_t *pos)$/;"	f	file:
swap_readpage	./page_io.c	/^int swap_readpage(struct page *page)$/;"	f
swap_set_page_dirty	./page_io.c	/^int swap_set_page_dirty(struct page *page)$/;"	f
swap_setup	./swap.c	/^void __init swap_setup(void)$/;"	f
swap_shmem_alloc	./swapfile.c	/^void swap_shmem_alloc(swp_entry_t entry)$/;"	f
swap_show	./swapfile.c	/^static int swap_show(struct seq_file *swap, void *v)$/;"	f	file:
swap_start	./swapfile.c	/^static void *swap_start(struct seq_file *swap, loff_t *pos)$/;"	f	file:
swap_stop	./swapfile.c	/^static void swap_stop(struct seq_file *swap, void *v)$/;"	f	file:
swap_type_of	./swapfile.c	/^int swap_type_of(dev_t device, sector_t offset, struct block_device **bdev_p)$/;"	f
swap_writepage	./page_io.c	/^int swap_writepage(struct page *page, struct writeback_control *wbc)$/;"	f
swapbacked	./memory-failure.c	749;"	d	file:
swapbacked	./memory-failure.c	806;"	d	file:
swapcache_free	./swapfile.c	/^void swapcache_free(swp_entry_t entry, struct page *page)$/;"	f
swapcache_prepare	./swapfile.c	/^int swapcache_prepare(swp_entry_t entry)$/;"	f
swapdev_block	./swapfile.c	/^sector_t swapdev_block(int type, pgoff_t offset)$/;"	f
swapin_nr_pages	./swap_state.c	/^static unsigned long swapin_nr_pages(unsigned long offset)$/;"	f	file:
swapin_readahead	./swap_state.c	/^struct page *swapin_readahead(swp_entry_t entry, gfp_t gfp_mask,$/;"	f
swapin_readahead_hits	./swap_state.c	/^static atomic_t swapin_readahead_hits = ATOMIC_INIT(4);$/;"	v	file:
swapin_walk_pmd_entry	./madvise.c	/^static int swapin_walk_pmd_entry(pmd_t *pmd, unsigned long start,$/;"	f	file:
swapper_spaces	./swap_state.c	/^struct address_space swapper_spaces[MAX_SWAPFILES] = {$/;"	v	typeref:struct:address_space
swappiness	./memcontrol.c	/^	int	swappiness;$/;"	m	struct:mem_cgroup	file:
swaps_op	./swapfile.c	/^static const struct seq_operations swaps_op = {$/;"	v	typeref:struct:seq_operations	file:
swaps_open	./swapfile.c	/^static int swaps_open(struct inode *inode, struct file *file)$/;"	f	file:
swaps_poll	./swapfile.c	/^static unsigned swaps_poll(struct file *file, poll_table *wait)$/;"	f	file:
swpentry	./zswap.c	/^	swp_entry_t swpentry;$/;"	m	struct:zswap_header	file:
sync	./internal.h	/^	bool sync;			\/* Synchronous migration *\/$/;"	m	struct:compact_control
sync_mm_rss	./memory.c	/^void sync_mm_rss(struct mm_struct *mm)$/;"	f
sys_pos_check_seg_addr	./pos.c	/^asmlinkage void sys_pos_check_seg_addr(char __user *name, void __user *buffer)$/;"	f
sys_pos_create	./pos.c	/^asmlinkage void *sys_pos_create(char __user *name, unsigned long size)$/;"	f
sys_pos_delete	./pos.c	/^asmlinkage int sys_pos_delete(char __user *name)$/;"	f
sys_pos_is_mapped	./pos.c	/^asmlinkage  void *sys_pos_is_mapped(char __user *name)$/;"	f
sys_pos_map	./pos.c	/^asmlinkage void *sys_pos_map(char __user *name)$/;"	f
sys_pos_seg_alloc	./pos.c	/^asmlinkage void *sys_pos_seg_alloc(char __user *name, unsigned long len)$/;"	f
sys_pos_seg_free	./pos.c	/^asmlinkage int sys_pos_seg_free(char __user *name, void *addr, unsigned long len)$/;"	f
sys_pos_unmap	./pos.c	/^asmlinkage int sys_pos_unmap(char __user *name)$/;"	f
sysctl_compact_memory	./compaction.c	/^int sysctl_compact_memory;$/;"	v
sysctl_compaction_handler	./compaction.c	/^int sysctl_compaction_handler(struct ctl_table *table, int write,$/;"	f
sysctl_extfrag_handler	./compaction.c	/^int sysctl_extfrag_handler(struct ctl_table *table, int write,$/;"	f
sysctl_extfrag_threshold	./compaction.c	/^int sysctl_extfrag_threshold = 500;$/;"	v
sysctl_lowmem_reserve_ratio	./page_alloc.c	/^int sysctl_lowmem_reserve_ratio[MAX_NR_ZONES-1] = {$/;"	v
sysctl_max_map_count	./nommu.c	/^int sysctl_max_map_count = DEFAULT_MAX_MAP_COUNT;$/;"	v
sysctl_min_slab_ratio	./vmscan.c	/^int sysctl_min_slab_ratio = 5;$/;"	v
sysctl_min_slab_ratio_sysctl_handler	./page_alloc.c	/^int sysctl_min_slab_ratio_sysctl_handler(ctl_table *table, int write,$/;"	f
sysctl_min_unmapped_ratio	./vmscan.c	/^int sysctl_min_unmapped_ratio = 1;$/;"	v
sysctl_min_unmapped_ratio_sysctl_handler	./page_alloc.c	/^int sysctl_min_unmapped_ratio_sysctl_handler(ctl_table *table, int write,$/;"	f
sysctl_nr_trim_pages	./nommu.c	/^int sysctl_nr_trim_pages = CONFIG_NOMMU_INITIAL_TRIM_EXCESS;$/;"	v
sysctl_oom_dump_tasks	./oom_kill.c	/^int sysctl_oom_dump_tasks = 1;$/;"	v
sysctl_oom_kill_allocating_task	./oom_kill.c	/^int sysctl_oom_kill_allocating_task;$/;"	v
sysctl_overcommit_memory	./nommu.c	/^int sysctl_overcommit_memory = OVERCOMMIT_GUESS; \/* heuristic overcommit *\/$/;"	v
sysctl_overcommit_ratio	./nommu.c	/^int sysctl_overcommit_ratio = 50; \/* default is 50% *\/$/;"	v
sysctl_panic_on_oom	./oom_kill.c	/^int sysctl_panic_on_oom;$/;"	v
sysfs_compact_node	./compaction.c	/^static ssize_t sysfs_compact_node(struct device *dev,$/;"	f	file:
sysfs_slab_add	./slub.c	/^static inline int sysfs_slab_add(struct kmem_cache *s) { return 0; }$/;"	f	file:
sysfs_slab_add	./slub.c	/^static int sysfs_slab_add(struct kmem_cache *s)$/;"	f	file:
sysfs_slab_alias	./slub.c	/^static inline int sysfs_slab_alias(struct kmem_cache *s, const char *p)$/;"	f	file:
sysfs_slab_alias	./slub.c	/^static int sysfs_slab_alias(struct kmem_cache *s, const char *name)$/;"	f	file:
sysfs_slab_remove	./slub.c	/^void sysfs_slab_remove(struct kmem_cache *s)$/;"	f
tag_pages_for_writeback	./page-writeback.c	/^EXPORT_SYMBOL(tag_pages_for_writeback);$/;"	v
tag_pages_for_writeback	./page-writeback.c	/^void tag_pages_for_writeback(struct address_space *mapping,$/;"	f
tail	./memory-failure.c	751;"	d	file:
tail	./memory-failure.c	808;"	d	file:
target_mem_cgroup	./vmscan.c	/^	struct mem_cgroup *target_mem_cgroup;$/;"	m	struct:scan_control	typeref:struct:scan_control::mem_cgroup	file:
targets	./memcontrol.c	/^	unsigned long targets[MEM_CGROUP_NTARGETS];$/;"	m	struct:mem_cgroup_stat_cpu	file:
task_early_kill	./memory-failure.c	/^static int task_early_kill(struct task_struct *tsk)$/;"	f	file:
task_in_mem_cgroup	./memcontrol.c	/^bool task_in_mem_cgroup(struct task_struct *task,$/;"	f
tcp_mem	./memcontrol.c	/^	struct cg_proto tcp_mem;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::cg_proto	file:
tcp_proto_cgroup	./memcontrol.c	/^EXPORT_SYMBOL(tcp_proto_cgroup);$/;"	v
tcp_proto_cgroup	./memcontrol.c	/^struct cg_proto *tcp_proto_cgroup(struct mem_cgroup *memcg)$/;"	f
test_clear_page_writeback	./page-writeback.c	/^int test_clear_page_writeback(struct page *page)$/;"	f
test_mem_cgroup_node_reclaimable	./memcontrol.c	/^static bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,$/;"	f	file:
test_node	./kmemleak-test.c	/^struct test_node {$/;"	s	file:
test_pages_in_a_zone	./memory_hotplug.c	/^static int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn)$/;"	f	file:
test_pages_isolated	./page_isolation.c	/^int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,$/;"	f
test_set_page_writeback	./page-writeback.c	/^EXPORT_SYMBOL(test_set_page_writeback);$/;"	v
test_set_page_writeback	./page-writeback.c	/^int test_set_page_writeback(struct page *page)$/;"	f
threshold	./memcontrol.c	/^	u64 threshold;$/;"	m	struct:mem_cgroup_threshold	file:
thresholds	./memcontrol.c	/^	struct mem_cgroup_thresholds thresholds;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::mem_cgroup_thresholds	file:
thresholds_lock	./memcontrol.c	/^	struct mutex thresholds_lock;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::mutex	file:
throttle_direct_reclaim	./vmscan.c	/^static bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,$/;"	f	file:
throttle_vm_writeout	./page-writeback.c	/^void throttle_vm_writeout(gfp_t gfp_mask)$/;"	f
tid_to_cpu	./slub.c	/^static inline unsigned int tid_to_cpu(unsigned long tid)$/;"	f	file:
tid_to_event	./slub.c	/^static inline unsigned long tid_to_event(unsigned long tid)$/;"	f	file:
tlb_finish_mmu	./memory.c	/^void tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long end)$/;"	f
tlb_flush_mmu	./memory.c	/^void tlb_flush_mmu(struct mmu_gather *tlb)$/;"	f
tlb_flush_mmu_free	./memory.c	/^static void tlb_flush_mmu_free(struct mmu_gather *tlb)$/;"	f	file:
tlb_flush_mmu_tlbonly	./memory.c	/^static void tlb_flush_mmu_tlbonly(struct mmu_gather *tlb)$/;"	f	file:
tlb_gather_mmu	./memory.c	/^void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm, unsigned long start, unsigned long end)$/;"	f
tlb_next_batch	./memory.c	/^static int tlb_next_batch(struct mmu_gather *tlb)$/;"	f	file:
tlb_remove_table	./memory.c	/^void tlb_remove_table(struct mmu_gather *tlb, void *table)$/;"	f
tlb_remove_table_one	./memory.c	/^static void tlb_remove_table_one(void *table)$/;"	f	file:
tlb_remove_table_rcu	./memory.c	/^static void tlb_remove_table_rcu(struct rcu_head *head)$/;"	f	file:
tlb_remove_table_smp_sync	./memory.c	/^static void tlb_remove_table_smp_sync(void *arg)$/;"	f	file:
tlb_table_flush	./memory.c	/^void tlb_table_flush(struct mmu_gather *tlb)$/;"	f
to	./hugetlb.c	/^	long to;$/;"	m	struct:file_region	file:
to	./memcontrol.c	/^	struct mem_cgroup *to;$/;"	m	struct:move_charge_struct	typeref:struct:move_charge_struct::mem_cgroup	file:
to_kill	./memory-failure.c	/^struct to_kill {$/;"	s	file:
to_slab	./slub.c	4399;"	d	file:
to_slab_attr	./slub.c	4398;"	d	file:
too_many_isolated	./compaction.c	/^static bool too_many_isolated(struct zone *zone)$/;"	f	file:
too_many_isolated	./vmscan.c	/^static int too_many_isolated(struct zone *zone, int file,$/;"	f	file:
total_objects	./slab.h	/^	atomic_long_t total_objects;$/;"	m	struct:kmem_cache_node
total_objects	./slub.c	/^SLAB_ATTR_RO(total_objects);$/;"	v
total_objects_show	./slub.c	/^static ssize_t total_objects_show(struct kmem_cache *s, char *buf)$/;"	f	file:
total_swap_pages	./swapfile.c	/^long total_swap_pages;$/;"	v
total_swapcache_pages	./swap_state.c	/^unsigned long total_swapcache_pages(void)$/;"	f
total_usage	./page_cgroup.c	/^static unsigned long total_usage;$/;"	v	file:
totalhigh_pages	./highmem.c	/^EXPORT_SYMBOL(totalhigh_pages);$/;"	v
totalram_pages	./page_alloc.c	/^EXPORT_SYMBOL(totalram_pages);$/;"	v
touched	./slab.c	/^	unsigned int touched;$/;"	m	struct:array_cache	file:
trace	./kmemleak.c	/^	unsigned long trace[MAX_TRACE];	\/* stack trace *\/$/;"	m	struct:early_log	file:
trace	./kmemleak.c	/^	unsigned long trace[MAX_TRACE];$/;"	m	struct:kmemleak_object	file:
trace	./slub.c	/^SLAB_ATTR(trace);$/;"	v
trace	./slub.c	/^static void trace(struct kmem_cache *s, struct page *page, void *object,$/;"	f	file:
trace_len	./kmemleak.c	/^	unsigned int trace_len;		\/* stack trace length *\/$/;"	m	struct:early_log	file:
trace_len	./kmemleak.c	/^	unsigned int trace_len;$/;"	m	struct:kmemleak_object	file:
trace_show	./slub.c	/^static ssize_t trace_show(struct kmem_cache *s, char *buf)$/;"	f	file:
trace_store	./slub.c	/^static ssize_t trace_store(struct kmem_cache *s, const char *buf,$/;"	f	file:
track	./slub.c	/^struct track {$/;"	s	file:
track_item	./slub.c	/^enum track_item { TRACK_ALLOC, TRACK_FREE };$/;"	g	file:
transfer_objects	./slab.c	/^static int transfer_objects(struct array_cache *to,$/;"	f	file:
trapno	./memory-failure.c	/^	int trapno;$/;"	m	struct:memory_failure_entry	file:
tree_node	./memcontrol.c	/^	struct rb_node		tree_node;	\/* RB tree node *\/$/;"	m	struct:mem_cgroup_per_zone	typeref:struct:mem_cgroup_per_zone::rb_node	file:
truncate_complete_page	./truncate.c	/^truncate_complete_page(struct address_space *mapping, struct page *page)$/;"	f	file:
truncate_inode_page	./truncate.c	/^int truncate_inode_page(struct address_space *mapping, struct page *page)$/;"	f
truncate_inode_pages	./truncate.c	/^EXPORT_SYMBOL(truncate_inode_pages);$/;"	v
truncate_inode_pages	./truncate.c	/^void truncate_inode_pages(struct address_space *mapping, loff_t lstart)$/;"	f
truncate_inode_pages_final	./truncate.c	/^EXPORT_SYMBOL(truncate_inode_pages_final);$/;"	v
truncate_inode_pages_final	./truncate.c	/^void truncate_inode_pages_final(struct address_space *mapping)$/;"	f
truncate_inode_pages_range	./truncate.c	/^EXPORT_SYMBOL(truncate_inode_pages_range);$/;"	v
truncate_inode_pages_range	./truncate.c	/^void truncate_inode_pages_range(struct address_space *mapping,$/;"	f
truncate_pagecache	./truncate.c	/^EXPORT_SYMBOL(truncate_pagecache);$/;"	v
truncate_pagecache	./truncate.c	/^void truncate_pagecache(struct inode *inode, loff_t newsize)$/;"	f
truncate_pagecache_range	./truncate.c	/^EXPORT_SYMBOL(truncate_pagecache_range);$/;"	v
truncate_pagecache_range	./truncate.c	/^void truncate_pagecache_range(struct inode *inode, loff_t lstart, loff_t lend)$/;"	f
truncate_setsize	./truncate.c	/^EXPORT_SYMBOL(truncate_setsize);$/;"	v
truncate_setsize	./truncate.c	/^void truncate_setsize(struct inode *inode, loff_t newsize)$/;"	f
try_context_readahead	./readahead.c	/^static int try_context_readahead(struct address_space *mapping,$/;"	f	file:
try_get_mem_cgroup_from_page	./memcontrol.c	/^struct mem_cgroup *try_get_mem_cgroup_from_page(struct page *page)$/;"	f
try_offline_node	./memory_hotplug.c	/^EXPORT_SYMBOL(try_offline_node);$/;"	v
try_offline_node	./memory_hotplug.c	/^void try_offline_node(int nid)$/;"	f
try_online_node	./memory_hotplug.c	/^int try_online_node(int nid)$/;"	f
try_purge_vmap_area_lazy	./vmalloc.c	/^static void try_purge_vmap_area_lazy(void)$/;"	f	file:
try_set_zonelist_oom	./oom_kill.c	/^int try_set_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)$/;"	f
try_to_compact_pages	./compaction.c	/^unsigned long try_to_compact_pages(struct zonelist *zonelist,$/;"	f
try_to_free_low	./hugetlb.c	/^static inline void try_to_free_low(struct hstate *h, unsigned long count,$/;"	f	file:
try_to_free_low	./hugetlb.c	/^static void try_to_free_low(struct hstate *h, unsigned long count,$/;"	f	file:
try_to_free_mem_cgroup_pages	./vmscan.c	/^unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,$/;"	f
try_to_free_pages	./vmscan.c	/^unsigned long try_to_free_pages(struct zonelist *zonelist, int order,$/;"	f
try_to_free_swap	./swapfile.c	/^int try_to_free_swap(struct page *page)$/;"	f
try_to_merge_one_page	./ksm.c	/^static int try_to_merge_one_page(struct vm_area_struct *vma,$/;"	f	file:
try_to_merge_two_pages	./ksm.c	/^static struct page *try_to_merge_two_pages(struct rmap_item *rmap_item,$/;"	f	file:
try_to_merge_with_ksm_page	./ksm.c	/^static int try_to_merge_with_ksm_page(struct rmap_item *rmap_item,$/;"	f	file:
try_to_munlock	./rmap.c	/^int try_to_munlock(struct page *page)$/;"	f
try_to_release_page	./filemap.c	/^EXPORT_SYMBOL(try_to_release_page);$/;"	v
try_to_release_page	./filemap.c	/^int try_to_release_page(struct page *page, gfp_t gfp_mask)$/;"	f
try_to_steal_freepages	./page_alloc.c	/^static int try_to_steal_freepages(struct zone *zone, struct page *page,$/;"	f	file:
try_to_unmap	./rmap.c	/^int try_to_unmap(struct page *page, enum ttu_flags flags)$/;"	f
try_to_unmap_cluster	./rmap.c	/^static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,$/;"	f	file:
try_to_unmap_nonlinear	./rmap.c	/^static int try_to_unmap_nonlinear(struct page *page,$/;"	f	file:
try_to_unmap_one	./rmap.c	/^int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,$/;"	f
try_to_unuse	./swapfile.c	/^int try_to_unuse(unsigned int type, bool frontswap,$/;"	f
tsk	./memory-failure.c	/^	struct task_struct *tsk;$/;"	m	struct:to_kill	typeref:struct:to_kill::task_struct	file:
uevent_filter	./slub.c	/^static int uevent_filter(struct kset *kset, struct kobject *kobj)$/;"	f	file:
unbuddied	./zbud.c	/^	struct list_head unbuddied[NCHUNKS];$/;"	m	struct:zbud_pool	typeref:struct:zbud_pool::list_head	file:
under_oom	./memcontrol.c	/^	atomic_t	under_oom;$/;"	m	struct:mem_cgroup	file:
under_reclaim	./zbud.c	/^	bool under_reclaim;$/;"	m	struct:zbud_header	file:
undo_isolate_page_range	./page_isolation.c	/^int undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,$/;"	f
unevict	./memory-failure.c	745;"	d	file:
unevict	./memory-failure.c	802;"	d	file:
unfreeze_partials	./slub.c	/^static void unfreeze_partials(struct kmem_cache *s,$/;"	f	file:
units	./slob.c	/^	slobidx_t units;$/;"	m	struct:slob_block	file:
unlink_anon_vmas	./rmap.c	/^void unlink_anon_vmas(struct vm_area_struct *vma)$/;"	f
unlink_file_vma	./mmap.c	/^void unlink_file_vma(struct vm_area_struct *vma)$/;"	f
unlock_anon_vma_root	./rmap.c	/^static inline void unlock_anon_vma_root(struct anon_vma *root)$/;"	f	file:
unlock_kmap	./highmem.c	85;"	d	file:
unlock_kmap	./highmem.c	90;"	d	file:
unlock_kmap_any	./highmem.c	87;"	d	file:
unlock_kmap_any	./highmem.c	93;"	d	file:
unlock_memory_hotplug	./memory_hotplug.c	/^void unlock_memory_hotplug(void)$/;"	f
unlock_or_release_subpool	./hugetlb.c	/^static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)$/;"	f	file:
unlock_page	./filemap.c	/^EXPORT_SYMBOL(unlock_page);$/;"	v
unlock_page	./filemap.c	/^void unlock_page(struct page *page)$/;"	f
unmap_and_move	./migrate.c	/^static int unmap_and_move(new_page_t get_new_page, unsigned long private,$/;"	f	file:
unmap_and_move_huge_page	./migrate.c	/^static int unmap_and_move_huge_page(new_page_t get_new_page,$/;"	f	file:
unmap_cpu_on_node	./memory_hotplug.c	/^static void unmap_cpu_on_node(pg_data_t *pgdat)$/;"	f	file:
unmap_hugepage_range	./hugetlb.c	/^void unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,$/;"	f
unmap_kernel_range	./vmalloc.c	/^void unmap_kernel_range(unsigned long addr, unsigned long size)$/;"	f
unmap_kernel_range_noflush	./vmalloc.c	/^EXPORT_SYMBOL_GPL(unmap_kernel_range_noflush);$/;"	v
unmap_kernel_range_noflush	./vmalloc.c	/^void unmap_kernel_range_noflush(unsigned long addr, unsigned long size)$/;"	f
unmap_mapping_range	./memory.c	/^EXPORT_SYMBOL(unmap_mapping_range);$/;"	v
unmap_mapping_range	./memory.c	/^void unmap_mapping_range(struct address_space *mapping,$/;"	f
unmap_mapping_range	./nommu.c	/^EXPORT_SYMBOL(unmap_mapping_range);$/;"	v
unmap_mapping_range	./nommu.c	/^void unmap_mapping_range(struct address_space *mapping,$/;"	f
unmap_mapping_range_list	./memory.c	/^static inline void unmap_mapping_range_list(struct list_head *head,$/;"	f	file:
unmap_mapping_range_tree	./memory.c	/^static inline void unmap_mapping_range_tree(struct rb_root *root,$/;"	f	file:
unmap_mapping_range_vma	./memory.c	/^static void unmap_mapping_range_vma(struct vm_area_struct *vma,$/;"	f	file:
unmap_page_range	./memory.c	/^static void unmap_page_range(struct mmu_gather *tlb,$/;"	f	file:
unmap_ref_private	./hugetlb.c	/^static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
unmap_region	./mmap.c	/^static void unmap_region(struct mm_struct *mm,$/;"	f	file:
unmap_single_vma	./memory.c	/^static void unmap_single_vma(struct mmu_gather *tlb,$/;"	f	file:
unmap_vmap_area	./vmalloc.c	/^static void unmap_vmap_area(struct vmap_area *va)$/;"	f	file:
unmap_vmas	./memory.c	/^void unmap_vmas(struct mmu_gather *tlb,$/;"	f
unmapped_area	./mmap.c	/^unsigned long unmapped_area(struct vm_unmapped_area_info *info)$/;"	f
unmapped_area_topdown	./mmap.c	/^unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)$/;"	f
unmerge_and_remove_all_rmap_items	./ksm.c	/^static int unmerge_and_remove_all_rmap_items(void)$/;"	f	file:
unmerge_ksm_pages	./ksm.c	/^static int unmerge_ksm_pages(struct vm_area_struct *vma,$/;"	f	file:
unpack_shadow	./workingset.c	/^static void unpack_shadow(void *shadow,$/;"	f	file:
unpoison_memory	./memory-failure.c	/^EXPORT_SYMBOL(unpoison_memory);$/;"	v
unpoison_memory	./memory-failure.c	/^int unpoison_memory(unsigned long pfn)$/;"	f
unpoison_page	./debug-pagealloc.c	/^static void unpoison_page(struct page *page)$/;"	f	file:
unpoison_pages	./debug-pagealloc.c	/^static void unpoison_pages(struct page *page, int n)$/;"	f	file:
unreferenced_object	./kmemleak.c	/^static bool unreferenced_object(struct kmemleak_object *object)$/;"	f	file:
unregister_event	./memcontrol.c	/^	void (*unregister_event)(struct mem_cgroup *memcg,$/;"	m	struct:mem_cgroup_event	file:
unregister_oom_notifier	./oom_kill.c	/^EXPORT_SYMBOL_GPL(unregister_oom_notifier);$/;"	v
unregister_oom_notifier	./oom_kill.c	/^int unregister_oom_notifier(struct notifier_block *nb)$/;"	f
unregister_shrinker	./vmscan.c	/^EXPORT_SYMBOL(unregister_shrinker);$/;"	v
unregister_shrinker	./vmscan.c	/^void unregister_shrinker(struct shrinker *shrinker)$/;"	f
unset_migratetype_isolate	./page_isolation.c	/^void unset_migratetype_isolate(struct page *page, unsigned migratetype)$/;"	f
unstable_tree_search_insert	./ksm.c	/^struct rmap_item *unstable_tree_search_insert(struct rmap_item *rmap_item,$/;"	f	file:
unusable_file_ops	./vmstat.c	/^static const struct file_operations unusable_file_ops = {$/;"	v	typeref:struct:file_operations	file:
unusable_free_index	./vmstat.c	/^static int unusable_free_index(unsigned int order,$/;"	f	file:
unusable_op	./vmstat.c	/^static const struct seq_operations unusable_op = {$/;"	v	typeref:struct:seq_operations	file:
unusable_open	./vmstat.c	/^static int unusable_open(struct inode *inode, struct file *file)$/;"	f	file:
unusable_show	./vmstat.c	/^static int unusable_show(struct seq_file *m, void *arg)$/;"	f	file:
unusable_show_print	./vmstat.c	/^static void unusable_show_print(struct seq_file *m,$/;"	f	file:
unuse_mm	./mmu_context.c	/^EXPORT_SYMBOL_GPL(unuse_mm);$/;"	v
unuse_mm	./mmu_context.c	/^void unuse_mm(struct mm_struct *mm)$/;"	f
unuse_mm	./swapfile.c	/^static int unuse_mm(struct mm_struct *mm,$/;"	f	file:
unuse_pmd_range	./swapfile.c	/^static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,$/;"	f	file:
unuse_pte	./swapfile.c	/^static int unuse_pte(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f	file:
unuse_pte_range	./swapfile.c	/^static int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,$/;"	f	file:
unuse_pud_range	./swapfile.c	/^static inline int unuse_pud_range(struct vm_area_struct *vma, pgd_t *pgd,$/;"	f	file:
unuse_vma	./swapfile.c	/^static int unuse_vma(struct vm_area_struct *vma,$/;"	f	file:
update_and_free_page	./hugetlb.c	/^static void update_and_free_page(struct hstate *h, struct page *page)$/;"	f	file:
update_checksum	./kmemleak.c	/^static bool update_checksum(struct kmemleak_object *object)$/;"	f	file:
update_dirty_limit	./page-writeback.c	/^static void update_dirty_limit(unsigned long thresh, unsigned long dirty)$/;"	f	file:
update_nr_listpages	./compaction.c	/^static void update_nr_listpages(struct compact_control *cc)$/;"	f	file:
update_page_reclaim_stat	./swap.c	/^static void update_page_reclaim_stat(struct lruvec *lruvec,$/;"	f	file:
update_pageblock_skip	./compaction.c	/^static void update_pageblock_skip(struct compact_control *cc,$/;"	f	file:
usage_in_excess	./memcontrol.c	/^	unsigned long long	usage_in_excess;\/* Set to the value by which *\/$/;"	m	struct:mem_cgroup_per_zone	file:
use_count	./kmemleak.c	/^	atomic_t use_count;$/;"	m	struct:kmemleak_object	file:
use_hierarchy	./memcontrol.c	/^	bool use_hierarchy;$/;"	m	struct:mem_cgroup	file:
use_mm	./mmu_context.c	/^EXPORT_SYMBOL_GPL(use_mm);$/;"	v
use_mm	./mmu_context.c	/^void use_mm(struct mm_struct *mm)$/;"	f
use_zero_page_attr	./huge_memory.c	/^static struct kobj_attribute use_zero_page_attr =$/;"	v	typeref:struct:kobj_attribute	file:
use_zero_page_show	./huge_memory.c	/^static ssize_t use_zero_page_show(struct kobject *kobj,$/;"	f	file:
use_zero_page_store	./huge_memory.c	/^static ssize_t use_zero_page_store(struct kobject *kobj,$/;"	f	file:
usemap_size	./page_alloc.c	/^static unsigned long __init usemap_size(unsigned long zone_start_pfn, unsigned long zonesize)$/;"	f	file:
usemap_size	./sparse.c	/^unsigned long usemap_size(void)$/;"	f
user_min_free_kbytes	./page_alloc.c	/^int user_min_free_kbytes = -1;$/;"	v
user_shm_lock	./mlock.c	/^int user_shm_lock(size_t size, struct user_struct *user)$/;"	f
user_shm_unlock	./mlock.c	/^void user_shm_unlock(size_t size, struct user_struct *user)$/;"	f
user_zonelist_order	./page_alloc.c	/^static int user_zonelist_order = ZONELIST_ORDER_DEFAULT;$/;"	v	file:
uuids	./cleancache.c	/^static char *uuids[MAX_INITIALIZABLE_FS];$/;"	v	file:
va	./vmalloc.c	/^	struct vmap_area *va;$/;"	m	struct:vmap_block	typeref:struct:vmap_block::vmap_area	file:
vaddr	./dmapool.c	/^	void *vaddr;$/;"	m	struct:dma_page	file:
validate	./slub.c	/^SLAB_ATTR(validate);$/;"	v
validate_mm	./mmap.c	/^static void validate_mm(struct mm_struct *mm)$/;"	f	file:
validate_mm	./mmap.c	443;"	d	file:
validate_mm_rb	./mmap.c	/^static void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)$/;"	f	file:
validate_mm_rb	./mmap.c	442;"	d	file:
validate_mmap_request	./nommu.c	/^static int validate_mmap_request(struct file *file,$/;"	f	file:
validate_nommu_regions	./nommu.c	/^static noinline void validate_nommu_regions(void)$/;"	f	file:
validate_nommu_regions	./nommu.c	/^static void validate_nommu_regions(void)$/;"	f	file:
validate_show	./slub.c	/^static ssize_t validate_show(struct kmem_cache *s, char *buf)$/;"	f	file:
validate_slab	./slub.c	/^static int validate_slab(struct kmem_cache *s, struct page *page,$/;"	f	file:
validate_slab_cache	./slub.c	/^static long validate_slab_cache(struct kmem_cache *s)$/;"	f	file:
validate_slab_node	./slub.c	/^static int validate_slab_node(struct kmem_cache *s,$/;"	f	file:
validate_slab_slab	./slub.c	/^static void validate_slab_slab(struct kmem_cache *s, struct page *page,$/;"	f	file:
validate_store	./slub.c	/^static ssize_t validate_store(struct kmem_cache *s,$/;"	f	file:
vb_alloc	./vmalloc.c	/^static void *vb_alloc(unsigned long size, gfp_t gfp_mask)$/;"	f	file:
vb_free	./vmalloc.c	/^static void vb_free(const void *addr, unsigned long size)$/;"	f	file:
verify_mm_writelocked	./mmap.c	/^static inline void verify_mm_writelocked(struct mm_struct *mm)$/;"	f	file:
verify_redzone_free	./slab.c	/^static inline void verify_redzone_free(struct kmem_cache *cache, void *obj)$/;"	f	file:
vfree	./nommu.c	/^EXPORT_SYMBOL(vfree);$/;"	v
vfree	./nommu.c	/^void vfree(const void *addr)$/;"	f
vfree	./vmalloc.c	/^EXPORT_SYMBOL(vfree);$/;"	v
vfree	./vmalloc.c	/^void vfree(const void *addr)$/;"	f
vfree_deferred	./vmalloc.c	/^struct vfree_deferred {$/;"	s	file:
virt_to_cache	./slab.c	/^static inline struct kmem_cache *virt_to_cache(const void *obj)$/;"	f	file:
virtual	./highmem.c	/^	void *virtual;$/;"	m	struct:page_address_map	file:
vm	./zsmalloc.c	/^	struct vm_struct *vm; \/* vm area for mapping object that span pages *\/$/;"	m	struct:mapping_area	typeref:struct:mapping_area::vm_struct	file:
vm_addr	./zsmalloc.c	/^	char *vm_addr; \/* address of kmap_atomic()'ed pages *\/$/;"	m	struct:mapping_area	file:
vm_area_add_early	./vmalloc.c	/^void __init vm_area_add_early(struct vm_struct *vm)$/;"	f
vm_area_register_early	./vmalloc.c	/^void __init vm_area_register_early(struct vm_struct *vm, size_t align)$/;"	f
vm_brk	./mmap.c	/^EXPORT_SYMBOL(vm_brk);$/;"	v
vm_brk	./mmap.c	/^unsigned long vm_brk(unsigned long addr, unsigned long len)$/;"	f
vm_brk	./nommu.c	/^unsigned long vm_brk(unsigned long addr, unsigned long len)$/;"	f
vm_commit_limit	./util.c	/^unsigned long vm_commit_limit(void)$/;"	f
vm_committed_as	./nommu.c	/^struct percpu_counter vm_committed_as;$/;"	v	typeref:struct:percpu_counter
vm_committed_as_batch	./mm_init.c	/^s32 vm_committed_as_batch = 32;$/;"	v
vm_dirty_bytes	./page-writeback.c	/^unsigned long vm_dirty_bytes;$/;"	v
vm_dirty_ratio	./page-writeback.c	/^int vm_dirty_ratio = 20;$/;"	v
vm_event_states	./vmstat.c	/^EXPORT_PER_CPU_SYMBOL(vm_event_states);$/;"	v
vm_events_fold_cpu	./vmstat.c	/^void vm_events_fold_cpu(int cpu)$/;"	f
vm_flags	./rmap.c	/^	unsigned long vm_flags;$/;"	m	struct:page_referenced_arg	file:
vm_get_page_prot	./mmap.c	/^EXPORT_SYMBOL(vm_get_page_prot);$/;"	v
vm_get_page_prot	./mmap.c	/^pgprot_t vm_get_page_prot(unsigned long vm_flags)$/;"	f
vm_highmem_is_dirtyable	./page-writeback.c	/^int vm_highmem_is_dirtyable;$/;"	v
vm_insert_mixed	./memory.c	/^EXPORT_SYMBOL(vm_insert_mixed);$/;"	v
vm_insert_mixed	./memory.c	/^int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,$/;"	f
vm_insert_page	./memory.c	/^EXPORT_SYMBOL(vm_insert_page);$/;"	v
vm_insert_page	./memory.c	/^int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,$/;"	f
vm_insert_page	./nommu.c	/^EXPORT_SYMBOL(vm_insert_page);$/;"	v
vm_insert_page	./nommu.c	/^int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,$/;"	f
vm_insert_pfn	./memory.c	/^EXPORT_SYMBOL(vm_insert_pfn);$/;"	v
vm_insert_pfn	./memory.c	/^int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,$/;"	f
vm_iomap_memory	./memory.c	/^EXPORT_SYMBOL(vm_iomap_memory);$/;"	v
vm_iomap_memory	./memory.c	/^int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)$/;"	f
vm_iomap_memory	./nommu.c	/^EXPORT_SYMBOL(vm_iomap_memory);$/;"	v
vm_iomap_memory	./nommu.c	/^int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)$/;"	f
vm_is_stack	./util.c	/^pid_t vm_is_stack(struct task_struct *task,$/;"	f
vm_is_stack_for_task	./util.c	/^static int vm_is_stack_for_task(struct task_struct *t,$/;"	f	file:
vm_lock_anon_vma	./mmap.c	/^static void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)$/;"	f	file:
vm_lock_mapping	./mmap.c	/^static void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)$/;"	f	file:
vm_map_ram	./nommu.c	/^EXPORT_SYMBOL(vm_map_ram);$/;"	v
vm_map_ram	./nommu.c	/^void *vm_map_ram(struct page **pages, unsigned int count, int node, pgprot_t prot)$/;"	f
vm_map_ram	./vmalloc.c	/^EXPORT_SYMBOL(vm_map_ram);$/;"	v
vm_map_ram	./vmalloc.c	/^void *vm_map_ram(struct page **pages, unsigned int count, int node, pgprot_t prot)$/;"	f
vm_memory_committed	./mmap.c	/^EXPORT_SYMBOL_GPL(vm_memory_committed);$/;"	v
vm_memory_committed	./mmap.c	/^unsigned long vm_memory_committed(void)$/;"	f
vm_memory_committed	./nommu.c	/^EXPORT_SYMBOL_GPL(vm_memory_committed);$/;"	v
vm_memory_committed	./nommu.c	/^unsigned long vm_memory_committed(void)$/;"	f
vm_mm	./zsmalloc.c	/^	enum zs_mapmode vm_mm; \/* mapping mode *\/$/;"	m	struct:mapping_area	typeref:enum:mapping_area::zs_mapmode	file:
vm_mmap	./util.c	/^EXPORT_SYMBOL(vm_mmap);$/;"	v
vm_mmap	./util.c	/^unsigned long vm_mmap(struct file *file, unsigned long addr,$/;"	f
vm_mmap_pgoff	./util.c	/^unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,$/;"	f
vm_munmap	./mmap.c	/^EXPORT_SYMBOL(vm_munmap);$/;"	v
vm_munmap	./mmap.c	/^int vm_munmap(unsigned long start, size_t len)$/;"	f
vm_munmap	./nommu.c	/^EXPORT_SYMBOL(vm_munmap);$/;"	v
vm_munmap	./nommu.c	/^int vm_munmap(unsigned long addr, size_t len)$/;"	f
vm_normal_page	./memory.c	/^struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,$/;"	f
vm_region_jar	./nommu.c	/^static struct kmem_cache *vm_region_jar;$/;"	v	typeref:struct:kmem_cache	file:
vm_stat	./vmstat.c	/^EXPORT_SYMBOL(vm_stat);$/;"	v
vm_stat_account	./mmap.c	/^void vm_stat_account(struct mm_struct *mm, unsigned long flags,$/;"	f
vm_swappiness	./vmscan.c	/^int vm_swappiness = 60;$/;"	v
vm_total_pages	./vmscan.c	/^unsigned long vm_total_pages;	\/* The total number of pages which the VM controls *\/$/;"	v
vm_unlock_anon_vma	./mmap.c	/^static void vm_unlock_anon_vma(struct anon_vma *anon_vma)$/;"	f	file:
vm_unlock_mapping	./mmap.c	/^static void vm_unlock_mapping(struct address_space *mapping)$/;"	f	file:
vm_unmap_aliases	./nommu.c	/^EXPORT_SYMBOL_GPL(vm_unmap_aliases);$/;"	v
vm_unmap_aliases	./nommu.c	/^void vm_unmap_aliases(void)$/;"	f
vm_unmap_aliases	./vmalloc.c	/^EXPORT_SYMBOL_GPL(vm_unmap_aliases);$/;"	v
vm_unmap_aliases	./vmalloc.c	/^void vm_unmap_aliases(void)$/;"	f
vm_unmap_ram	./nommu.c	/^EXPORT_SYMBOL(vm_unmap_ram);$/;"	v
vm_unmap_ram	./nommu.c	/^void vm_unmap_ram(const void *mem, unsigned int count)$/;"	f
vm_unmap_ram	./vmalloc.c	/^EXPORT_SYMBOL(vm_unmap_ram);$/;"	v
vm_unmap_ram	./vmalloc.c	/^void vm_unmap_ram(const void *mem, unsigned int count)$/;"	f
vma_address	./rmap.c	/^vma_address(struct page *page, struct vm_area_struct *vma)$/;"	f
vma_adjust	./mmap.c	/^int vma_adjust(struct vm_area_struct *vma, unsigned long start,$/;"	f
vma_commit_reservation	./hugetlb.c	/^static void vma_commit_reservation(struct hstate *h,$/;"	f	file:
vma_compute_subtree_gap	./mmap.c	/^static long vma_compute_subtree_gap(struct vm_area_struct *vma)$/;"	f	file:
vma_dup_policy	./mempolicy.c	/^int vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)$/;"	f
vma_expandable	./mremap.c	/^static int vma_expandable(struct vm_area_struct *vma, unsigned long delta)$/;"	f	file:
vma_gap_update	./mmap.c	/^static void vma_gap_update(struct vm_area_struct *vma)$/;"	f	file:
vma_has_reserves	./hugetlb.c	/^static int vma_has_reserves(struct vm_area_struct *vma, long chg)$/;"	f	file:
vma_hugecache_offset	./hugetlb.c	/^static pgoff_t vma_hugecache_offset(struct hstate *h,$/;"	f	file:
vma_interval_tree_insert_after	./interval_tree.c	/^void vma_interval_tree_insert_after(struct vm_area_struct *node,$/;"	f
vma_kernel_pagesize	./hugetlb.c	/^EXPORT_SYMBOL_GPL(vma_kernel_pagesize);$/;"	v
vma_kernel_pagesize	./hugetlb.c	/^unsigned long vma_kernel_pagesize(struct vm_area_struct *vma)$/;"	f
vma_last_pgoff	./interval_tree.c	/^static inline unsigned long vma_last_pgoff(struct vm_area_struct *v)$/;"	f	file:
vma_link	./mmap.c	/^static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
vma_merge	./mmap.c	/^struct vm_area_struct *vma_merge(struct mm_struct *mm,$/;"	f
vma_mmu_pagesize	./hugetlb.c	/^unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)$/;"	f
vma_needs_reservation	./hugetlb.c	/^static long vma_needs_reservation(struct hstate *h,$/;"	f	file:
vma_policy_mof	./mempolicy.c	/^bool vma_policy_mof(struct task_struct *task, struct vm_area_struct *vma)$/;"	f
vma_rb_erase	./mmap.c	/^static void vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)$/;"	f	file:
vma_rb_insert	./mmap.c	/^static inline void vma_rb_insert(struct vm_area_struct *vma,$/;"	f	file:
vma_replace_policy	./mempolicy.c	/^static int vma_replace_policy(struct vm_area_struct *vma,$/;"	f	file:
vma_resv_map	./hugetlb.c	/^static struct resv_map *vma_resv_map(struct vm_area_struct *vma)$/;"	f	file:
vma_shareable	./hugetlb.c	/^static int vma_shareable(struct vm_area_struct *vma, unsigned long addr)$/;"	f	file:
vma_start_pgoff	./interval_tree.c	/^static inline unsigned long vma_start_pgoff(struct vm_area_struct *v)$/;"	f	file:
vma_to_resize	./mremap.c	/^static struct vm_area_struct *vma_to_resize(unsigned long addr,$/;"	f	file:
vma_wants_writenotify	./mmap.c	/^int vma_wants_writenotify(struct vm_area_struct *vma)$/;"	f
vmacache_find	./vmacache.c	/^struct vm_area_struct *vmacache_find(struct mm_struct *mm, unsigned long addr)$/;"	f
vmacache_find_exact	./vmacache.c	/^struct vm_area_struct *vmacache_find_exact(struct mm_struct *mm,$/;"	f
vmacache_flush_all	./vmacache.c	/^void vmacache_flush_all(struct mm_struct *mm)$/;"	f
vmacache_update	./vmacache.c	/^void vmacache_update(unsigned long addr, struct vm_area_struct *newvma)$/;"	f
vmacache_valid	./vmacache.c	/^static bool vmacache_valid(struct mm_struct *mm)$/;"	f	file:
vmacache_valid_mm	./vmacache.c	/^static bool vmacache_valid_mm(struct mm_struct *mm)$/;"	f	file:
vmalloc	./nommu.c	/^EXPORT_SYMBOL(vmalloc);$/;"	v
vmalloc	./nommu.c	/^void *vmalloc(unsigned long size)$/;"	f
vmalloc	./vmalloc.c	/^EXPORT_SYMBOL(vmalloc);$/;"	v
vmalloc	./vmalloc.c	/^void *vmalloc(unsigned long size)$/;"	f
vmalloc_32	./nommu.c	/^EXPORT_SYMBOL(vmalloc_32);$/;"	v
vmalloc_32	./nommu.c	/^void *vmalloc_32(unsigned long size)$/;"	f
vmalloc_32	./vmalloc.c	/^EXPORT_SYMBOL(vmalloc_32);$/;"	v
vmalloc_32	./vmalloc.c	/^void *vmalloc_32(unsigned long size)$/;"	f
vmalloc_32_user	./nommu.c	/^EXPORT_SYMBOL(vmalloc_32_user);$/;"	v
vmalloc_32_user	./nommu.c	/^void *vmalloc_32_user(unsigned long size)$/;"	f
vmalloc_32_user	./vmalloc.c	/^EXPORT_SYMBOL(vmalloc_32_user);$/;"	v
vmalloc_32_user	./vmalloc.c	/^void *vmalloc_32_user(unsigned long size)$/;"	f
vmalloc_exec	./nommu.c	/^void *vmalloc_exec(unsigned long size)$/;"	f
vmalloc_exec	./vmalloc.c	/^void *vmalloc_exec(unsigned long size)$/;"	f
vmalloc_init	./vmalloc.c	/^void __init vmalloc_init(void)$/;"	f
vmalloc_node	./nommu.c	/^EXPORT_SYMBOL(vmalloc_node);$/;"	v
vmalloc_node	./nommu.c	/^void *vmalloc_node(unsigned long size, int node)$/;"	f
vmalloc_node	./vmalloc.c	/^EXPORT_SYMBOL(vmalloc_node);$/;"	v
vmalloc_node	./vmalloc.c	/^void *vmalloc_node(unsigned long size, int node)$/;"	f
vmalloc_op	./vmalloc.c	/^static const struct seq_operations vmalloc_op = {$/;"	v	typeref:struct:seq_operations	file:
vmalloc_open	./vmalloc.c	/^static int vmalloc_open(struct inode *inode, struct file *file)$/;"	f	file:
vmalloc_sync_all	./nommu.c	/^void __weak vmalloc_sync_all(void)$/;"	f
vmalloc_sync_all	./vmalloc.c	/^void __weak vmalloc_sync_all(void)$/;"	f
vmalloc_to_page	./nommu.c	/^EXPORT_SYMBOL(vmalloc_to_page);$/;"	v
vmalloc_to_page	./nommu.c	/^struct page *vmalloc_to_page(const void *addr)$/;"	f
vmalloc_to_page	./vmalloc.c	/^EXPORT_SYMBOL(vmalloc_to_page);$/;"	v
vmalloc_to_page	./vmalloc.c	/^struct page *vmalloc_to_page(const void *vmalloc_addr)$/;"	f
vmalloc_to_pfn	./nommu.c	/^EXPORT_SYMBOL(vmalloc_to_pfn);$/;"	v
vmalloc_to_pfn	./nommu.c	/^unsigned long vmalloc_to_pfn(const void *addr)$/;"	f
vmalloc_to_pfn	./vmalloc.c	/^EXPORT_SYMBOL(vmalloc_to_pfn);$/;"	v
vmalloc_to_pfn	./vmalloc.c	/^unsigned long vmalloc_to_pfn(const void *vmalloc_addr)$/;"	f
vmalloc_user	./nommu.c	/^EXPORT_SYMBOL(vmalloc_user);$/;"	v
vmalloc_user	./nommu.c	/^void *vmalloc_user(unsigned long size)$/;"	f
vmalloc_user	./vmalloc.c	/^EXPORT_SYMBOL(vmalloc_user);$/;"	v
vmalloc_user	./vmalloc.c	/^void *vmalloc_user(unsigned long size)$/;"	f
vmap	./nommu.c	/^EXPORT_SYMBOL(vmap);$/;"	v
vmap	./nommu.c	/^void *vmap(struct page **pages, unsigned int count, unsigned long flags, pgprot_t prot)$/;"	f
vmap	./vmalloc.c	/^EXPORT_SYMBOL(vmap);$/;"	v
vmap	./vmalloc.c	/^void *vmap(struct page **pages, unsigned int count,$/;"	f
vmap_area_list	./nommu.c	/^LIST_HEAD(vmap_area_list);$/;"	v
vmap_area_list	./vmalloc.c	/^LIST_HEAD(vmap_area_list);$/;"	v
vmap_area_pcpu_hole	./vmalloc.c	/^static unsigned long vmap_area_pcpu_hole;$/;"	v	file:
vmap_area_root	./vmalloc.c	/^static struct rb_root vmap_area_root = RB_ROOT;$/;"	v	typeref:struct:rb_root	file:
vmap_block	./vmalloc.c	/^struct vmap_block {$/;"	s	file:
vmap_block_queue	./vmalloc.c	/^struct vmap_block_queue {$/;"	s	file:
vmap_debug_free_range	./vmalloc.c	/^static void vmap_debug_free_range(unsigned long start, unsigned long end)$/;"	f	file:
vmap_lazy_nr	./vmalloc.c	/^static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);$/;"	v	file:
vmap_page_range	./vmalloc.c	/^static int vmap_page_range(unsigned long start, unsigned long end,$/;"	f	file:
vmap_page_range_noflush	./vmalloc.c	/^static int vmap_page_range_noflush(unsigned long start, unsigned long end,$/;"	f	file:
vmap_pmd_range	./vmalloc.c	/^static int vmap_pmd_range(pud_t *pud, unsigned long addr,$/;"	f	file:
vmap_pte_range	./vmalloc.c	/^static int vmap_pte_range(pmd_t *pmd, unsigned long addr,$/;"	f	file:
vmap_pud_range	./vmalloc.c	/^static int vmap_pud_range(pgd_t *pgd, unsigned long addr,$/;"	f	file:
vmemmap_alloc_block	./sparse-vmemmap.c	/^void * __meminit vmemmap_alloc_block(unsigned long size, int node)$/;"	f
vmemmap_alloc_block_buf	./sparse-vmemmap.c	/^void * __meminit vmemmap_alloc_block_buf(unsigned long size, int node)$/;"	f
vmemmap_buf	./sparse-vmemmap.c	/^static void *vmemmap_buf;$/;"	v	file:
vmemmap_buf_end	./sparse-vmemmap.c	/^static void *vmemmap_buf_end;$/;"	v	file:
vmemmap_pgd_populate	./sparse-vmemmap.c	/^pgd_t * __meminit vmemmap_pgd_populate(unsigned long addr, int node)$/;"	f
vmemmap_pmd_populate	./sparse-vmemmap.c	/^pmd_t * __meminit vmemmap_pmd_populate(pud_t *pud, unsigned long addr, int node)$/;"	f
vmemmap_populate_basepages	./sparse-vmemmap.c	/^int __meminit vmemmap_populate_basepages(unsigned long start,$/;"	f
vmemmap_populate_print_last	./sparse.c	/^void __weak __meminit vmemmap_populate_print_last(void)$/;"	f
vmemmap_pte_populate	./sparse-vmemmap.c	/^pte_t * __meminit vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node)$/;"	f
vmemmap_pud_populate	./sparse-vmemmap.c	/^pud_t * __meminit vmemmap_pud_populate(pgd_t *pgd, unsigned long addr, int node)$/;"	f
vmemmap_verify	./sparse-vmemmap.c	/^void __meminit vmemmap_verify(pte_t *pte, int node,$/;"	f
vmpressure	./memcontrol.c	/^	struct vmpressure vmpressure;$/;"	m	struct:mem_cgroup	typeref:struct:mem_cgroup::vmpressure	file:
vmpressure	./vmpressure.c	/^void vmpressure(gfp_t gfp, struct mem_cgroup *memcg,$/;"	f
vmpressure_calc_level	./vmpressure.c	/^static enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,$/;"	f	file:
vmpressure_cleanup	./vmpressure.c	/^void vmpressure_cleanup(struct vmpressure *vmpr)$/;"	f
vmpressure_event	./vmpressure.c	/^static bool vmpressure_event(struct vmpressure *vmpr,$/;"	f	file:
vmpressure_event	./vmpressure.c	/^struct vmpressure_event {$/;"	s	file:
vmpressure_init	./vmpressure.c	/^void vmpressure_init(struct vmpressure *vmpr)$/;"	f
vmpressure_level	./vmpressure.c	/^static enum vmpressure_levels vmpressure_level(unsigned long pressure)$/;"	f	file:
vmpressure_level_critical	./vmpressure.c	/^static const unsigned int vmpressure_level_critical = 95;$/;"	v	file:
vmpressure_level_critical_prio	./vmpressure.c	/^static const unsigned int vmpressure_level_critical_prio = ilog2(100 \/ 10);$/;"	v	file:
vmpressure_level_med	./vmpressure.c	/^static const unsigned int vmpressure_level_med = 60;$/;"	v	file:
vmpressure_levels	./vmpressure.c	/^enum vmpressure_levels {$/;"	g	file:
vmpressure_parent	./vmpressure.c	/^static struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)$/;"	f	file:
vmpressure_prio	./vmpressure.c	/^void vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)$/;"	f
vmpressure_register_event	./vmpressure.c	/^int vmpressure_register_event(struct mem_cgroup *memcg,$/;"	f
vmpressure_str_levels	./vmpressure.c	/^static const char * const vmpressure_str_levels[] = {$/;"	v	file:
vmpressure_to_css	./memcontrol.c	/^struct cgroup_subsys_state *vmpressure_to_css(struct vmpressure *vmpr)$/;"	f
vmpressure_unregister_event	./vmpressure.c	/^void vmpressure_unregister_event(struct mem_cgroup *memcg,$/;"	f
vmpressure_win	./vmpressure.c	/^static const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;$/;"	v	file:
vmpressure_work_fn	./vmpressure.c	/^static void vmpressure_work_fn(struct work_struct *work)$/;"	f	file:
vmscan_swappiness	./vmscan.c	/^static int vmscan_swappiness(struct scan_control *sc)$/;"	f	file:
vmstat_cpu_dead	./vmstat.c	/^static void vmstat_cpu_dead(int node)$/;"	f	file:
vmstat_cpuup_callback	./vmstat.c	/^static int vmstat_cpuup_callback(struct notifier_block *nfb,$/;"	f	file:
vmstat_next	./vmstat.c	/^static void *vmstat_next(struct seq_file *m, void *arg, loff_t *pos)$/;"	f	file:
vmstat_notifier	./vmstat.c	/^static struct notifier_block vmstat_notifier =$/;"	v	typeref:struct:notifier_block	file:
vmstat_op	./vmstat.c	/^static const struct seq_operations vmstat_op = {$/;"	v	typeref:struct:seq_operations	file:
vmstat_open	./vmstat.c	/^static int vmstat_open(struct inode *inode, struct file *file)$/;"	f	file:
vmstat_show	./vmstat.c	/^static int vmstat_show(struct seq_file *m, void *arg)$/;"	f	file:
vmstat_start	./vmstat.c	/^static void *vmstat_start(struct seq_file *m, loff_t *pos)$/;"	f	file:
vmstat_stop	./vmstat.c	/^static void vmstat_stop(struct seq_file *m, void *arg)$/;"	f	file:
vmstat_text	./vmstat.c	/^const char * const vmstat_text[] = {$/;"	v
vmstat_update	./vmstat.c	/^static void vmstat_update(struct work_struct *w)$/;"	f	file:
vread	./nommu.c	/^long vread(char *buf, char *addr, unsigned long count)$/;"	f
vread	./vmalloc.c	/^long vread(char *buf, char *addr, unsigned long count)$/;"	f
vunmap	./nommu.c	/^EXPORT_SYMBOL(vunmap);$/;"	v
vunmap	./nommu.c	/^void vunmap(const void *addr)$/;"	f
vunmap	./vmalloc.c	/^EXPORT_SYMBOL(vunmap);$/;"	v
vunmap	./vmalloc.c	/^void vunmap(const void *addr)$/;"	f
vunmap_page_range	./vmalloc.c	/^static void vunmap_page_range(unsigned long addr, unsigned long end)$/;"	f	file:
vunmap_pmd_range	./vmalloc.c	/^static void vunmap_pmd_range(pud_t *pud, unsigned long addr, unsigned long end)$/;"	f	file:
vunmap_pte_range	./vmalloc.c	/^static void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)$/;"	f	file:
vunmap_pud_range	./vmalloc.c	/^static void vunmap_pud_range(pgd_t *pgd, unsigned long addr, unsigned long end)$/;"	f	file:
vwrite	./nommu.c	/^long vwrite(char *buf, char *addr, unsigned long count)$/;"	f
vwrite	./vmalloc.c	/^long vwrite(char *buf, char *addr, unsigned long count)$/;"	f
vzalloc	./nommu.c	/^EXPORT_SYMBOL(vzalloc);$/;"	v
vzalloc	./nommu.c	/^void *vzalloc(unsigned long size)$/;"	f
vzalloc	./vmalloc.c	/^EXPORT_SYMBOL(vzalloc);$/;"	v
vzalloc	./vmalloc.c	/^void *vzalloc(unsigned long size)$/;"	f
vzalloc_node	./nommu.c	/^EXPORT_SYMBOL(vzalloc_node);$/;"	v
vzalloc_node	./nommu.c	/^void *vzalloc_node(unsigned long size, int node)$/;"	f
vzalloc_node	./vmalloc.c	/^EXPORT_SYMBOL(vzalloc_node);$/;"	v
vzalloc_node	./vmalloc.c	/^void *vzalloc_node(unsigned long size, int node)$/;"	f
wait	./memcontrol.c	/^	wait_queue_t	wait;$/;"	m	struct:oom_wait_info	file:
wait	./memcontrol.c	/^	wait_queue_t wait;$/;"	m	struct:mem_cgroup_event	file:
wait_for_stable_page	./page-writeback.c	/^EXPORT_SYMBOL_GPL(wait_for_stable_page);$/;"	v
wait_for_stable_page	./page-writeback.c	/^void wait_for_stable_page(struct page *page)$/;"	f
wait_iff_congested	./backing-dev.c	/^EXPORT_SYMBOL(wait_iff_congested);$/;"	v
wait_iff_congested	./backing-dev.c	/^long wait_iff_congested(struct zone *zone, int sync, long timeout)$/;"	f
wait_migrate_huge_page	./migrate.c	/^void wait_migrate_huge_page(struct anon_vma *anon_vma, pmd_t *pmd)$/;"	f
wait_on_page_bit	./filemap.c	/^EXPORT_SYMBOL(wait_on_page_bit);$/;"	v
wait_on_page_bit	./filemap.c	/^void wait_on_page_bit(struct page *page, int bit_nr)$/;"	f
wait_on_page_bit_killable	./filemap.c	/^int wait_on_page_bit_killable(struct page *page, int bit_nr)$/;"	f
wait_on_page_read	./filemap.c	/^static struct page *wait_on_page_read(struct page *page)$/;"	f	file:
wait_table_bits	./page_alloc.c	/^static inline unsigned long wait_table_bits(unsigned long size)$/;"	f	file:
wait_table_hash_nr_entries	./page_alloc.c	/^static inline unsigned long wait_table_hash_nr_entries(unsigned long pages)$/;"	f	file:
wait_while_offlining	./ksm.c	/^static void wait_while_offlining(void)$/;"	f	file:
waitq	./memcontrol.c	/^	wait_queue_head_t waitq;		\/* a waitq for other context *\/$/;"	m	struct:move_charge_struct	file:
wake_all_kswapds	./page_alloc.c	/^static void wake_all_kswapds(unsigned int order,$/;"	f	file:
wake_up_page	./filemap.c	/^static inline void wake_up_page(struct page *page, int bit)$/;"	f	file:
wakeup_kswapd	./vmscan.c	/^void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx)$/;"	f
walk_hugetlb_range	./pagewalk.c	/^static int walk_hugetlb_range(struct vm_area_struct *vma,$/;"	f	file:
walk_memory_range	./memory_hotplug.c	/^int walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,$/;"	f
walk_page_range	./pagewalk.c	/^int walk_page_range(unsigned long addr, unsigned long end,$/;"	f
walk_pmd_range	./pagewalk.c	/^static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,$/;"	f	file:
walk_pte_range	./pagewalk.c	/^static int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,$/;"	f	file:
walk_pud_range	./pagewalk.c	/^static int walk_pud_range(pgd_t *pgd, unsigned long addr, unsigned long end,$/;"	f	file:
walk_zones_in_node	./vmstat.c	/^static void walk_zones_in_node(struct seq_file *m, pg_data_t *pgdat,$/;"	f	file:
want_pmd_share	./hugetlb.c	3455;"	d	file:
want_pmd_share	./hugetlb.c	3461;"	d	file:
warn_alloc_failed	./page_alloc.c	/^void warn_alloc_failed(gfp_t gfp_mask, int order, const char *fmt, ...)$/;"	f
warn_scan_unevictable_pages	./vmscan.c	/^static void warn_scan_unevictable_pages(void)$/;"	f	file:
when	./slub.c	/^	unsigned long when;	\/* When did the operation occur *\/$/;"	m	struct:track	file:
work	./memcontrol.c	/^	struct work_struct work;$/;"	m	struct:create_work	typeref:struct:create_work::work_struct	file:
work	./memcontrol.c	/^	struct work_struct work;$/;"	m	struct:memcg_stock_pcp	typeref:struct:memcg_stock_pcp::work_struct	file:
work	./memory-failure.c	/^	struct work_struct work;$/;"	m	struct:memory_failure_cpu	typeref:struct:memory_failure_cpu::work_struct	file:
work_to_vmpressure	./vmpressure.c	/^static struct vmpressure *work_to_vmpressure(struct work_struct *work)$/;"	f	file:
workingset_activation	./workingset.c	/^void workingset_activation(struct page *page)$/;"	f
workingset_eviction	./workingset.c	/^void *workingset_eviction(struct address_space *mapping, struct page *page)$/;"	f
workingset_init	./workingset.c	/^module_init(workingset_init);$/;"	v
workingset_init	./workingset.c	/^static int __init workingset_init(void)$/;"	f	file:
workingset_refault	./workingset.c	/^bool workingset_refault(void *shadow)$/;"	f
workingset_shadow_nodes	./workingset.c	/^struct list_lru workingset_shadow_nodes;$/;"	v	typeref:struct:list_lru
workingset_shadow_shrinker	./workingset.c	/^static struct shrinker workingset_shadow_shrinker = {$/;"	v	typeref:struct:shrinker	file:
wp_next_time	./page-writeback.c	/^static unsigned long wp_next_time(unsigned long cur_time)$/;"	f	file:
wq	./vmalloc.c	/^	struct work_struct wq;$/;"	m	struct:vfree_deferred	typeref:struct:vfree_deferred::work_struct	file:
wqh	./memcontrol.c	/^	wait_queue_head_t *wqh;$/;"	m	struct:mem_cgroup_event	file:
write_cache_pages	./page-writeback.c	/^EXPORT_SYMBOL(write_cache_pages);$/;"	v
write_cache_pages	./page-writeback.c	/^int write_cache_pages(struct address_space *mapping,$/;"	f
write_one_page	./page-writeback.c	/^EXPORT_SYMBOL(write_one_page);$/;"	v
write_one_page	./page-writeback.c	/^int write_one_page(struct page *page, int wait)$/;"	f
write_protect_page	./ksm.c	/^static int write_protect_page(struct vm_area_struct *vma, struct page *page,$/;"	f	file:
write_scan_unevictable_node	./vmscan.c	/^static ssize_t write_scan_unevictable_node(struct device *dev,$/;"	f	file:
writeback	./memory-failure.c	747;"	d	file:
writeback	./memory-failure.c	804;"	d	file:
writeback_set_ratelimit	./page-writeback.c	/^void writeback_set_ratelimit(void)$/;"	f
writeback_stat_item	./vmstat.c	/^enum writeback_stat_item {$/;"	g	file:
writeout	./migrate.c	/^static int writeout(struct address_space *mapping, struct page *page)$/;"	f	file:
writeout_completions	./page-writeback.c	/^static struct fprop_global writeout_completions;$/;"	v	typeref:struct:fprop_global	file:
writeout_period	./page-writeback.c	/^static void writeout_period(unsigned long t)$/;"	f	file:
writeout_period_time	./page-writeback.c	/^static unsigned long writeout_period_time = 0;$/;"	v	file:
writeout_period_timer	./page-writeback.c	/^static struct timer_list writeout_period_timer =$/;"	v	typeref:struct:timer_list	file:
xip_file_fault	./filemap_xip.c	/^static int xip_file_fault(struct vm_area_struct *vma, struct vm_fault *vmf)$/;"	f	file:
xip_file_mmap	./filemap_xip.c	/^EXPORT_SYMBOL_GPL(xip_file_mmap);$/;"	v
xip_file_mmap	./filemap_xip.c	/^int xip_file_mmap(struct file * file, struct vm_area_struct * vma)$/;"	f
xip_file_read	./filemap_xip.c	/^EXPORT_SYMBOL_GPL(xip_file_read);$/;"	v
xip_file_read	./filemap_xip.c	/^xip_file_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)$/;"	f
xip_file_vm_ops	./filemap_xip.c	/^static const struct vm_operations_struct xip_file_vm_ops = {$/;"	v	typeref:struct:vm_operations_struct	file:
xip_file_write	./filemap_xip.c	/^EXPORT_SYMBOL_GPL(xip_file_write);$/;"	v
xip_file_write	./filemap_xip.c	/^xip_file_write(struct file *filp, const char __user *buf, size_t len,$/;"	f
xip_sparse_page	./filemap_xip.c	/^static struct page *xip_sparse_page(void)$/;"	f	file:
xip_sparse_seq	./filemap_xip.c	/^static seqcount_t xip_sparse_seq = SEQCNT_ZERO(xip_sparse_seq);$/;"	v	file:
xip_truncate_page	./filemap_xip.c	/^EXPORT_SYMBOL_GPL(xip_truncate_page);$/;"	v
xip_truncate_page	./filemap_xip.c	/^xip_truncate_page(struct address_space *mapping, loff_t from)$/;"	f
zap_huge_pmd	./huge_memory.c	/^int zap_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,$/;"	f
zap_page_range	./memory.c	/^void zap_page_range(struct vm_area_struct *vma, unsigned long start,$/;"	f
zap_page_range_single	./memory.c	/^static void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,$/;"	f	file:
zap_pmd_range	./memory.c	/^static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,$/;"	f	file:
zap_pte	./fremap.c	/^static void zap_pte(struct mm_struct *mm, struct vm_area_struct *vma,$/;"	f	file:
zap_pte_range	./memory.c	/^static unsigned long zap_pte_range(struct mmu_gather *tlb,$/;"	f	file:
zap_pud_range	./memory.c	/^static inline unsigned long zap_pud_range(struct mmu_gather *tlb,$/;"	f	file:
zap_vma_ptes	./memory.c	/^EXPORT_SYMBOL_GPL(zap_vma_ptes);$/;"	v
zap_vma_ptes	./memory.c	/^int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,$/;"	f
zbud_alloc	./zbud.c	/^int zbud_alloc(struct zbud_pool *pool, int size, gfp_t gfp,$/;"	f
zbud_create_pool	./zbud.c	/^struct zbud_pool *zbud_create_pool(gfp_t gfp, struct zbud_ops *ops)$/;"	f
zbud_destroy_pool	./zbud.c	/^void zbud_destroy_pool(struct zbud_pool *pool)$/;"	f
zbud_free	./zbud.c	/^void zbud_free(struct zbud_pool *pool, unsigned long handle)$/;"	f
zbud_get_pool_size	./zbud.c	/^u64 zbud_get_pool_size(struct zbud_pool *pool)$/;"	f
zbud_header	./zbud.c	/^struct zbud_header {$/;"	s	file:
zbud_map	./zbud.c	/^void *zbud_map(struct zbud_pool *pool, unsigned long handle)$/;"	f
zbud_pool	./zbud.c	/^struct zbud_pool {$/;"	s	file:
zbud_reclaim_page	./zbud.c	/^int zbud_reclaim_page(struct zbud_pool *pool, unsigned int retries)$/;"	f
zbud_unmap	./zbud.c	/^void zbud_unmap(struct zbud_pool *pool, unsigned long handle)$/;"	f
zlc_clear_zones_full	./page_alloc.c	/^static void zlc_clear_zones_full(struct zonelist *zonelist)$/;"	f	file:
zlc_mark_zone_full	./page_alloc.c	/^static void zlc_mark_zone_full(struct zonelist *zonelist, struct zoneref *z)$/;"	f	file:
zlc_setup	./page_alloc.c	/^static nodemask_t *zlc_setup(struct zonelist *zonelist, int alloc_flags)$/;"	f	file:
zlc_zone_worth_trying	./page_alloc.c	/^static int zlc_zone_worth_trying(struct zonelist *zonelist, struct zoneref *z,$/;"	f	file:
zone	./internal.h	/^	struct zone *zone;$/;"	m	struct:compact_control	typeref:struct:compact_control::zone
zone_absent_pages_in_node	./page_alloc.c	/^static inline unsigned long __meminit zone_absent_pages_in_node(int nid,$/;"	f	file:
zone_absent_pages_in_node	./page_alloc.c	/^static unsigned long __meminit zone_absent_pages_in_node(int nid,$/;"	f	file:
zone_allows_reclaim	./page_alloc.c	/^static bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)$/;"	f	file:
zone_balanced	./vmscan.c	/^static bool zone_balanced(struct zone *zone, int order,$/;"	f	file:
zone_batchsize	./page_alloc.c	/^static int __meminit zone_batchsize(struct zone *zone)$/;"	f	file:
zone_dirty_limit	./page-writeback.c	/^static unsigned long zone_dirty_limit(struct zone *zone)$/;"	f	file:
zone_dirty_ok	./page-writeback.c	/^bool zone_dirty_ok(struct zone *zone)$/;"	f
zone_dirtyable_memory	./page-writeback.c	/^static unsigned long zone_dirtyable_memory(struct zone *zone)$/;"	f	file:
zone_init_free_lists	./page_alloc.c	/^static void __meminit zone_init_free_lists(struct zone *zone)$/;"	f	file:
zone_local	./page_alloc.c	/^static bool zone_local(struct zone *local_zone, struct zone *zone)$/;"	f	file:
zone_movable_pfn	./page_alloc.c	/^static unsigned long __meminitdata zone_movable_pfn[MAX_NUMNODES];$/;"	v	file:
zone_names	./page_alloc.c	/^static char * const zone_names[MAX_NR_ZONES] = {$/;"	v	file:
zone_pagecache_reclaimable	./vmscan.c	/^static long zone_pagecache_reclaimable(struct zone *zone)$/;"	f	file:
zone_pageset_init	./page_alloc.c	/^static void __meminit zone_pageset_init(struct zone *zone, int cpu)$/;"	f	file:
zone_pcp_init	./page_alloc.c	/^static __meminit void zone_pcp_init(struct zone *zone)$/;"	f	file:
zone_pcp_reset	./page_alloc.c	/^void zone_pcp_reset(struct zone *zone)$/;"	f
zone_pcp_update	./page_alloc.c	/^void __meminit zone_pcp_update(struct zone *zone)$/;"	f
zone_reclaim	./vmscan.c	/^int zone_reclaim(struct zone *zone, gfp_t gfp_mask, unsigned int order)$/;"	f
zone_reclaimable	./vmscan.c	/^bool zone_reclaimable(struct zone *zone)$/;"	f
zone_reclaimable_pages	./vmscan.c	/^static unsigned long zone_reclaimable_pages(struct zone *zone)$/;"	f	file:
zone_spanned_pages_in_node	./page_alloc.c	/^static inline unsigned long __meminit zone_spanned_pages_in_node(int nid,$/;"	f	file:
zone_spanned_pages_in_node	./page_alloc.c	/^static unsigned long __meminit zone_spanned_pages_in_node(int nid,$/;"	f	file:
zone_statistics	./vmstat.c	/^void zone_statistics(struct zone *preferred_zone, struct zone *z, gfp_t flags)$/;"	f
zone_unmapped_file_pages	./vmscan.c	/^static inline unsigned long zone_unmapped_file_pages(struct zone *zone)$/;"	f	file:
zone_wait_table_init	./page_alloc.c	/^int zone_wait_table_init(struct zone *zone, unsigned long zone_size_pages)$/;"	f	file:
zone_watermark_ok	./page_alloc.c	/^bool zone_watermark_ok(struct zone *z, int order, unsigned long mark,$/;"	f
zone_watermark_ok_safe	./page_alloc.c	/^bool zone_watermark_ok_safe(struct zone *z, int order, unsigned long mark,$/;"	f
zoneinfo	./memcontrol.c	/^	struct mem_cgroup_per_zone zoneinfo[MAX_NR_ZONES];$/;"	m	struct:mem_cgroup_per_node	typeref:struct:mem_cgroup_per_node::mem_cgroup_per_zone	file:
zoneinfo_op	./vmstat.c	/^static const struct seq_operations zoneinfo_op = {$/;"	v	typeref:struct:seq_operations	file:
zoneinfo_open	./vmstat.c	/^static int zoneinfo_open(struct inode *inode, struct file *file)$/;"	f	file:
zoneinfo_show	./vmstat.c	/^static int zoneinfo_show(struct seq_file *m, void *arg)$/;"	f	file:
zoneinfo_show_print	./vmstat.c	/^static void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,$/;"	f	file:
zonelist_order_name	./page_alloc.c	/^static char zonelist_order_name[3][8] = {"Default", "Node", "Zone"};$/;"	v	file:
zonelists_mutex	./page_alloc.c	/^DEFINE_MUTEX(zonelists_mutex);$/;"	v
zoneref_set_zone	./page_alloc.c	/^static void zoneref_set_zone(struct zone *zone, struct zoneref *zoneref)$/;"	f	file:
zref_in_nodemask	./mmzone.c	/^static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)$/;"	f	file:
zs_cpu_nb	./zsmalloc.c	/^static struct notifier_block zs_cpu_nb = {$/;"	v	typeref:struct:notifier_block	file:
zs_cpu_notifier	./zsmalloc.c	/^static int zs_cpu_notifier(struct notifier_block *nb, unsigned long action,$/;"	f	file:
zs_create_pool	./zsmalloc.c	/^EXPORT_SYMBOL_GPL(zs_create_pool);$/;"	v
zs_create_pool	./zsmalloc.c	/^struct zs_pool *zs_create_pool(gfp_t flags)$/;"	f
zs_destroy_pool	./zsmalloc.c	/^EXPORT_SYMBOL_GPL(zs_destroy_pool);$/;"	v
zs_destroy_pool	./zsmalloc.c	/^void zs_destroy_pool(struct zs_pool *pool)$/;"	f
zs_exit	./zsmalloc.c	/^module_exit(zs_exit);$/;"	v
zs_exit	./zsmalloc.c	/^static void zs_exit(void)$/;"	f	file:
zs_free	./zsmalloc.c	/^EXPORT_SYMBOL_GPL(zs_free);$/;"	v
zs_free	./zsmalloc.c	/^void zs_free(struct zs_pool *pool, unsigned long obj)$/;"	f
zs_get_total_size_bytes	./zsmalloc.c	/^EXPORT_SYMBOL_GPL(zs_get_total_size_bytes);$/;"	v
zs_get_total_size_bytes	./zsmalloc.c	/^u64 zs_get_total_size_bytes(struct zs_pool *pool)$/;"	f
zs_init	./zsmalloc.c	/^module_init(zs_init);$/;"	v
zs_init	./zsmalloc.c	/^static int zs_init(void)$/;"	f	file:
zs_malloc	./zsmalloc.c	/^EXPORT_SYMBOL_GPL(zs_malloc);$/;"	v
zs_malloc	./zsmalloc.c	/^unsigned long zs_malloc(struct zs_pool *pool, size_t size)$/;"	f
zs_map_object	./zsmalloc.c	/^EXPORT_SYMBOL_GPL(zs_map_object);$/;"	v
zs_map_object	./zsmalloc.c	/^void *zs_map_object(struct zs_pool *pool, unsigned long handle,$/;"	f
zs_pool	./zsmalloc.c	/^struct zs_pool {$/;"	s	file:
zs_unmap_object	./zsmalloc.c	/^EXPORT_SYMBOL_GPL(zs_unmap_object);$/;"	v
zs_unmap_object	./zsmalloc.c	/^void zs_unmap_object(struct zs_pool *pool, unsigned long handle)$/;"	f
zswap_comp_exit	./zswap.c	/^static void zswap_comp_exit(void)$/;"	f	file:
zswap_comp_init	./zswap.c	/^static int __init zswap_comp_init(void)$/;"	f	file:
zswap_comp_op	./zswap.c	/^static int zswap_comp_op(enum comp_op op, const u8 *src, unsigned int slen,$/;"	f	file:
zswap_comp_pcpu_tfms	./zswap.c	/^static struct crypto_comp * __percpu *zswap_comp_pcpu_tfms;$/;"	v	typeref:struct:__percpu	file:
zswap_compressor	./zswap.c	/^static char *zswap_compressor = ZSWAP_COMPRESSOR_DEFAULT;$/;"	v	file:
zswap_cpu_init	./zswap.c	/^static int zswap_cpu_init(void)$/;"	f	file:
zswap_cpu_notifier	./zswap.c	/^static int zswap_cpu_notifier(struct notifier_block *nb,$/;"	f	file:
zswap_cpu_notifier_block	./zswap.c	/^static struct notifier_block zswap_cpu_notifier_block = {$/;"	v	typeref:struct:notifier_block	file:
zswap_debugfs_exit	./zswap.c	/^static void __exit zswap_debugfs_exit(void) { }$/;"	f	file:
zswap_debugfs_exit	./zswap.c	/^static void __exit zswap_debugfs_exit(void)$/;"	f	file:
zswap_debugfs_init	./zswap.c	/^static int __init zswap_debugfs_init(void)$/;"	f	file:
zswap_debugfs_root	./zswap.c	/^static struct dentry *zswap_debugfs_root;$/;"	v	typeref:struct:dentry	file:
zswap_duplicate_entry	./zswap.c	/^static u64 zswap_duplicate_entry;$/;"	v	file:
zswap_entry	./zswap.c	/^struct zswap_entry {$/;"	s	file:
zswap_entry_cache	./zswap.c	/^static struct kmem_cache *zswap_entry_cache;$/;"	v	typeref:struct:kmem_cache	file:
zswap_entry_cache_alloc	./zswap.c	/^static struct zswap_entry *zswap_entry_cache_alloc(gfp_t gfp)$/;"	f	file:
zswap_entry_cache_create	./zswap.c	/^static int zswap_entry_cache_create(void)$/;"	f	file:
zswap_entry_cache_destory	./zswap.c	/^static void zswap_entry_cache_destory(void)$/;"	f	file:
zswap_entry_cache_free	./zswap.c	/^static void zswap_entry_cache_free(struct zswap_entry *entry)$/;"	f	file:
zswap_entry_find_get	./zswap.c	/^static struct zswap_entry *zswap_entry_find_get(struct rb_root *root,$/;"	f	file:
zswap_entry_get	./zswap.c	/^static void zswap_entry_get(struct zswap_entry *entry)$/;"	f	file:
zswap_entry_put	./zswap.c	/^static void zswap_entry_put(struct zswap_tree *tree,$/;"	f	file:
zswap_free_entry	./zswap.c	/^static void zswap_free_entry(struct zswap_entry *entry)$/;"	f	file:
zswap_frontswap_init	./zswap.c	/^static void zswap_frontswap_init(unsigned type)$/;"	f	file:
zswap_frontswap_invalidate_area	./zswap.c	/^static void zswap_frontswap_invalidate_area(unsigned type)$/;"	f	file:
zswap_frontswap_invalidate_page	./zswap.c	/^static void zswap_frontswap_invalidate_page(unsigned type, pgoff_t offset)$/;"	f	file:
zswap_frontswap_load	./zswap.c	/^static int zswap_frontswap_load(unsigned type, pgoff_t offset,$/;"	f	file:
zswap_frontswap_ops	./zswap.c	/^static struct frontswap_ops zswap_frontswap_ops = {$/;"	v	typeref:struct:frontswap_ops	file:
zswap_frontswap_store	./zswap.c	/^static int zswap_frontswap_store(unsigned type, pgoff_t offset,$/;"	f	file:
zswap_get_swap_cache_page	./zswap.c	/^static int zswap_get_swap_cache_page(swp_entry_t entry,$/;"	f	file:
zswap_get_swap_ret	./zswap.c	/^enum zswap_get_swap_ret {$/;"	g	file:
zswap_header	./zswap.c	/^struct zswap_header {$/;"	s	file:
zswap_is_full	./zswap.c	/^static bool zswap_is_full(void)$/;"	f	file:
zswap_max_pool_percent	./zswap.c	/^static unsigned int zswap_max_pool_percent = 20;$/;"	v	file:
zswap_pool	./zswap.c	/^static struct zbud_pool *zswap_pool;$/;"	v	typeref:struct:zbud_pool	file:
zswap_pool_limit_hit	./zswap.c	/^static u64 zswap_pool_limit_hit;$/;"	v	file:
zswap_pool_pages	./zswap.c	/^static u64 zswap_pool_pages;$/;"	v	file:
zswap_rb_erase	./zswap.c	/^static void zswap_rb_erase(struct rb_root *root, struct zswap_entry *entry)$/;"	f	file:
zswap_rb_insert	./zswap.c	/^static int zswap_rb_insert(struct rb_root *root, struct zswap_entry *entry,$/;"	f	file:
zswap_rb_search	./zswap.c	/^static struct zswap_entry *zswap_rb_search(struct rb_root *root, pgoff_t offset)$/;"	f	file:
zswap_reject_alloc_fail	./zswap.c	/^static u64 zswap_reject_alloc_fail;$/;"	v	file:
zswap_reject_compress_poor	./zswap.c	/^static u64 zswap_reject_compress_poor;$/;"	v	file:
zswap_reject_kmemcache_fail	./zswap.c	/^static u64 zswap_reject_kmemcache_fail;$/;"	v	file:
zswap_reject_reclaim_fail	./zswap.c	/^static u64 zswap_reject_reclaim_fail;$/;"	v	file:
zswap_stored_pages	./zswap.c	/^static atomic_t zswap_stored_pages = ATOMIC_INIT(0);$/;"	v	file:
zswap_tree	./zswap.c	/^struct zswap_tree {$/;"	s	file:
zswap_trees	./zswap.c	/^static struct zswap_tree *zswap_trees[MAX_SWAPFILES];$/;"	v	typeref:struct:zswap_tree	file:
zswap_writeback_entry	./zswap.c	/^static int zswap_writeback_entry(struct zbud_pool *pool, unsigned long handle)$/;"	f	file:
zswap_written_back_pages	./zswap.c	/^static u64 zswap_written_back_pages;$/;"	v	file:
zswap_zbud_ops	./zswap.c	/^static struct zbud_ops zswap_zbud_ops = {$/;"	v	typeref:struct:zbud_ops	file:
